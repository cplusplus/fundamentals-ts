<!DOCTYPE html>
<!-- Sources at https://github.com/cplusplus/fundamentals-ts -->
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><!--[if lte IE 8]><script>document.createElement("nav");document.createElement("section");document.createElement("time");document.createElement("CXX-TITLEPAGE");document.createElement("CXX-DOCNUM");document.createElement("CXX-PROJECT-NUMBER");document.createElement("CXX-TOC");document.createElement("CXX-CLAUSE");document.createElement("CXX-SECTION");document.createElement("CXX-REF");document.createElement("CXX-FOREIGN-INDEX");document.createElement("CXX-EXAMPLE");document.createElement("CXX-NOTE");document.createElement("CXX-FUNCTION");document.createElement("CXX-SIGNATURE");document.createElement("CXX-REMARKS");document.createElement("CXX-EFFECTS");document.createElement("CXX-TERM");document.createElement("W-BR");document.createElement("CXX-RETURNS");document.createElement("CXX-REQUIRES");document.createElement("CXX-EDNOTE");document.createElement("CXX-POSTCONDITIONS");document.createElement("CXX-RANGE");document.createElement("CXX-THROWS");document.createElement("CXX-COMPLEXITY");document.createElement("CXX-NOTES");document.createElement("CXX-FOOTNOTE");document.createElement("CXX-EXCEPTION-SAFETY");document.createElement("CXX-FIGURE");document.createElement("CXX-GRAMMARTERM");document.createElement("CXX-PUBLISH-BUTTON");</script><![endif]--><style>template {display: none !important;} /* injected by platform.js */</style><style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } 
</style><style shim-shadowdom-css="">style { display: none !important; }
cxx-function {
	display: block; page-break-inside: avoid;
}

cxx-function:not(:last-child) {
	margin-bottom: 3ex;
}

cxx-function > dl {
	margin: 0px 0px 0px 2em;
}

cxx-function > pre {
	margin: 0px;
}cxx-signature {
	padding-left: 2em; display: block; text-indent: -2em;
}

cxx-signature.formatted {
	text-indent: 0px;
}cxx-attribute {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-attribute dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-attribute dd {
	margin-left: 0em;
}

cxx-attribute dd > ul, cxx-attribute dd > ol {
	clear: left;
}cxx-requires {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-requires dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-requires dd {
	margin-left: 0em;
}

cxx-requires dd > ul, cxx-requires dd > ol {
	clear: left;
}cxx-preconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-preconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-preconditions dd {
	margin-left: 0em;
}

cxx-preconditions dd > ul, cxx-preconditions dd > ol {
	clear: left;
}cxx-effects {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-effects dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-effects dd {
	margin-left: 0em;
}

cxx-effects dd > ul, cxx-effects dd > ol {
	clear: left;
}cxx-synchronization {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-synchronization dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-synchronization dd {
	margin-left: 0em;
}

cxx-synchronization dd > ul, cxx-synchronization dd > ol {
	clear: left;
}cxx-postconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-postconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-postconditions dd {
	margin-left: 0em;
}

cxx-postconditions dd > ul, cxx-postconditions dd > ol {
	clear: left;
}cxx-returns {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-returns dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-returns dd {
	margin-left: 0em;
}

cxx-returns dd > ul, cxx-returns dd > ol {
	clear: left;
}cxx-throws {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-throws dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-throws dd {
	margin-left: 0em;
}

cxx-throws dd > ul, cxx-throws dd > ol {
	clear: left;
}cxx-complexity {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-complexity dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-complexity dd {
	margin-left: 0em;
}

cxx-complexity dd > ul, cxx-complexity dd > ol {
	clear: left;
}cxx-exception-safety {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-exception-safety dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-exception-safety dd {
	margin-left: 0em;
}

cxx-exception-safety dd > ul, cxx-exception-safety dd > ol {
	clear: left;
}cxx-remarks {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-remarks dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-remarks dd {
	margin-left: 0em;
}

cxx-remarks dd > ul, cxx-remarks dd > ol {
	clear: left;
}cxx-error-conditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-error-conditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-error-conditions dd {
	margin-left: 0em;
}

cxx-error-conditions dd > ul, cxx-error-conditions dd > ol {
	clear: left;
}cxx-notes {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-notes dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-notes dd {
	margin-left: 0em;
}

cxx-notes dd > ul, cxx-notes dd > ol {
	clear: left;
}cxx-section {
	display: block;
}

cxx-section:target {
	background-color: inherit;
}

cxx-section:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-section header > h1 {
	display: inline; font-size: 100%;
}

cxx-section header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-section header::after {
	clear: both; display: block; content: " "; height: 0px;
}cxx-clause {
	display: block;
}

cxx-clause:target {
	background-color: inherit;
}

cxx-clause:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-clause header > h1 {
	display: inline; font-size: 100%;
}

cxx-clause header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-clause header::after {
	clear: both; display: block; content: " "; height: 0px;
}[is=cxx-table] {
	margin-left: auto; margin-right: auto; border-collapse: collapse; border: thin solid black;
}

[is=cxx-table] caption {
	white-space: nowrap;
}

[is=cxx-table] caption caption {
	display: inline;
}

[is=cxx-table] th, [is=cxx-table] td {
	border-style: solid none; border-color: black; border-width: thin; padding: 0px 0.25em;
}

[is=cxx-table].column-rules th, [is=cxx-table].column-rules td {
	border-left-style: solid; border-right-style: solid;
}

[is=cxx-table] th {
	border-bottom: medium double;
}

[is=cxx-table].single-border th {
	border-bottom: thin solid;
}

[is=cxx-table].center td {
	text-align: center;
}

[is=cxx-table].list td {
	border: medium none; vertical-align: top;
}

[is=cxx-table].list ul {
	padding-left: 0px; margin: 0px;
}

[is=cxx-table].list ul li::before {
	content: "";
}cxx-figure {
	margin-left: auto; margin-right: auto;
}

cxx-figure figcaption {
	white-space: nowrap; text-align: center;
}

cxx-figure figcaption figcaption {
	display: inline;
}[is=cxx-definition-section] dt {
	font-weight: bold;
}

[is=cxx-definition-section] dd {
	margin-left: 0px;
}cxx-toc {
	display: block;
}

cxx-toc nav > ol {
	font-weight: bold;
}

cxx-toc ol {
	font-weight: normal; padding-left: 0px; margin-left: 0px;
}

cxx-toc li {
	list-style-type: none;
}

cxx-toc .marker {
	display: inline-block;
}

cxx-toc li .marker {
	width: 2em; text-align: left;
}

cxx-toc ol ol {
	margin-left: 2em;
}

cxx-toc li li .marker {
	width: 3em;
}

cxx-toc ol ol ol {
	margin-left: 3em;
}

cxx-toc li li li .marker {
	width: 3.5em;
}

cxx-toc ol ol ol ol {
	margin-left: 3.5em;
}

cxx-toc li li li li .marker {
	width: 4.5em;
}cxx-get-element-by-id {
	display: none;
}cxx-foreign-index {
	display: none;
}cxx-titlepage, cxx-titlepage .page {
	display: block; min-height: 100%;
}

cxx-titlepage .page {
	page-break-before: always; page-break-after: always; min-height: 100vh; margin-bottom: 2em;
}

@media print {
cxx-titlepage .page {
	height: 8.8in;
}


}

cxx-titlepage .page {
	position: relative;
}

cxx-titlepage table td, cxx-titlepage table th {
	border: medium none;
}

cxx-titlepagebody.cxx-draft .header, body.cxx-draft cxx-titlepage .header {
	position: absolute; right: 0px; top: 0px;
}

cxx-titlepagebody.cxx-draft h1, body.cxx-draft cxx-titlepage h1 {
	position: absolute; top: 40%; text-align: center;
}

cxx-titlepagebody.cxx-draft p.warning, body.cxx-draft cxx-titlepage p.warning {
	position: absolute; bottom: 5%;
}

cxx-titlepagebody.cxx-pdts .header, body.cxx-pdts cxx-titlepage .header, cxx-titlepagebody.cxx-dts .header, body.cxx-dts cxx-titlepage .header, cxx-titlepagebody.cxx-ts .header, body.cxx-ts cxx-titlepage .header {
	position: absolute; right: 0px; top: 0px; text-align: right;
}

cxx-titlepagebody.cxx-pdts .header cxx-docnum, body.cxx-pdts cxx-titlepage .header cxx-docnum, cxx-titlepagebody.cxx-dts .header cxx-docnum, body.cxx-dts cxx-titlepage .header cxx-docnum, cxx-titlepagebody.cxx-ts .header cxx-docnum, body.cxx-ts cxx-titlepage .header cxx-docnum {
	font-size: 150%;
}

cxx-titlepagebody.cxx-pdts .header cxx-docnum, body.cxx-pdts cxx-titlepage .header cxx-docnum, cxx-titlepagebody.cxx-dts .header cxx-docnum, body.cxx-dts cxx-titlepage .header cxx-docnum, cxx-titlepagebody.cxx-ts .header cxx-docnum, body.cxx-ts cxx-titlepage .header cxx-docnum {
	font-size: 150%;
}

cxx-titlepagebody.cxx-pdts hgroup, body.cxx-pdts cxx-titlepage hgroup, cxx-titlepagebody.cxx-dts hgroup, body.cxx-dts cxx-titlepage hgroup, cxx-titlepagebody.cxx-ts hgroup, body.cxx-ts cxx-titlepage hgroup {
	position: absolute; top: 30%;
}

cxx-titlepagebody.cxx-pdts hgroup *, body.cxx-pdts cxx-titlepage hgroup *, cxx-titlepagebody.cxx-dts hgroup *, body.cxx-dts cxx-titlepage hgroup *, cxx-titlepagebody.cxx-ts hgroup *, body.cxx-ts cxx-titlepage hgroup * {
	margin: 0px;
}

cxx-titlepagebody.cxx-pdts hgroup h1, body.cxx-pdts cxx-titlepage hgroup h1, cxx-titlepagebody.cxx-dts hgroup h1, body.cxx-dts cxx-titlepage hgroup h1, cxx-titlepagebody.cxx-ts hgroup h1, body.cxx-ts cxx-titlepage hgroup h1 {
	font-size: 150%; font-weight: bold;
}

cxx-titlepagebody.cxx-pdts hgroup h2, body.cxx-pdts cxx-titlepage hgroup h2, cxx-titlepagebody.cxx-dts hgroup h2, body.cxx-dts cxx-titlepage hgroup h2, cxx-titlepagebody.cxx-ts hgroup h2, body.cxx-ts cxx-titlepage hgroup h2 {
	font-size: 100%; font-weight: normal;
}

cxx-titlepagebody.cxx-pdts .footer, body.cxx-pdts cxx-titlepage .footer, cxx-titlepagebody.cxx-dts .footer, body.cxx-dts cxx-titlepage .footer, cxx-titlepagebody.cxx-ts .footer, body.cxx-ts cxx-titlepage .footer {
	position: absolute; left: 0px; bottom: 5%;
}

cxx-titlepagebody.cxx-pdts figure, body.cxx-pdts cxx-titlepage figure, cxx-titlepagebody.cxx-dts figure, body.cxx-dts cxx-titlepage figure, cxx-titlepagebody.cxx-ts figure, body.cxx-ts cxx-titlepage figure {
	border: 1px solid rgb(17, 17, 17); padding: 10px; margin-left: auto; margin-right: auto;
}

cxx-titlepagebody.cxx-pdts figcaption, body.cxx-pdts cxx-titlepage figcaption, cxx-titlepagebody.cxx-dts figcaption, body.cxx-dts cxx-titlepage figcaption, cxx-titlepagebody.cxx-ts figcaption, body.cxx-ts cxx-titlepage figcaption {
	text-align: center; font-weight: bold;
}

cxx-titlepagebody.cxx-pdts .warning, body.cxx-pdts cxx-titlepage .warning, cxx-titlepagebody.cxx-dts .warning, body.cxx-dts cxx-titlepage .warning, cxx-titlepagebody.cxx-ts .warning, body.cxx-ts cxx-titlepage .warning {
	position: absolute; bottom: 20%;
}

cxx-titlepagebody.cxx-pdts .copyright address, body.cxx-pdts cxx-titlepage .copyright address, cxx-titlepagebody.cxx-dts .copyright address, body.cxx-dts cxx-titlepage .copyright address, cxx-titlepagebody.cxx-ts .copyright address, body.cxx-ts cxx-titlepage .copyright address {
	font-style: normal; margin-left: 2em;
}

cxx-titlepagebody.cxx-pdts .copyright address a, body.cxx-pdts cxx-titlepage .copyright address a, cxx-titlepagebody.cxx-dts .copyright address a, body.cxx-dts cxx-titlepage .copyright address a, cxx-titlepagebody.cxx-ts .copyright address a, body.cxx-ts cxx-titlepage .copyright address a {
	color: inherit; text-decoration: inherit;
}

cxx-titlepage th {
	text-align: left; vertical-align: top;
}cxx-foreword {
	display: block; min-height: 100%;
}

cxx-foreword {
	page-break-before: always; page-break-after: always; min-height: 100vh; margin-bottom: 2em;
}

cxx-forewordbody.cxx-draft cxx-foreword -no-combinator, body.cxx-draft cxx-foreword cxx-foreword -no-combinator {
	display: none;
}cxx-ednote {
	display: none;
}

cxx-ednotebody.cxx-draft, body.cxx-draft cxx-ednote {
	display: block;
}

cxx-ednote aside {
	float: right; max-width: 40%; margin: 1ex; border: 1px dashed rgb(136, 136, 136); padding: 1ex; background-color: rgb(238, 238, 238);
}

cxx-ednote.para aside {
	float: none; max-width: none;
}cxx-note .nowrap {
	white-space: nowrap;
}cxx-footnote {
	font-family: serif; white-space: normal; text-indent: initial;textIndent: initial; text-indent: initial; 
}

@media screen {
cxx-footnote aside {
	float: right; max-width: 30%; margin-left: 1em;
}


}

@media print {
cxx-footnote sup, cxx-footnote .marker {
	display: none;
}

cxx-footnote aside {
	
}


}cxx-example {
	display: block;
}

cxx-example.inline {
	display: inline;
}

cxx-example .nowrap {
	white-space: nowrap;
}cxx-publish-button {
	display: block;
}cxx-codeblock {
	display: block;
}bnf-grammar {
	display: block; font-style: italic; margin-left: 0.35in;
}bnf-rule {
	display: block; margin-left: 0.6in;
}bnf-alt {
	display: block; margin-left: 1.2in;
}bnf-terminal {
	font-style: normal;
}w-br {
	white-space: normal;
}

w-br::after {
	content: "​";
}</style>
  <meta charset="utf-8">
  
  <style shim-shadowdom-css="">/* Copyright 2014 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@page {
    margin: 10%;
}
@page :left {
    @top-left { content: string(docname); font-weight: bold; font-size: 10pt; }
    @top-right { content: normal; }
    @bottom-left { content: counter(page); font-size: 10pt; }
    @bottom-right { content: "© ISO/IEC " string(pubyear) " — All rights reserved";
                    font-size: 10pt; }
}
@page :right {
    @top-left { content: normal; }
    @top-right { content: string(docname); font-weight: bold; font-size: 10pt; }
    @bottom-left { content: "© ISO/IEC " string(pubyear) " — All rights reserved";
                   font-size: 10pt; }
    @bottom-right { content: counter(page); font-size: 10pt; }
}
@page :first {
    @top-left { content: normal; }
    @top-right { content: normal; }
    @bottom-left { content: normal; }
    @bottom-right { content: normal; }
}

body { margin: 0; }

@media screen {
    body { max-width: 7in;
           /* Make room for paragraph numbers. */
           margin-left: 2em }
}

@media print {
    html { font-size: 10pt; }
    *   code { font-size: 80%; }
    /* Note that only Prince generates clickable links. */
    *   a[href] { text-decoration:none; }
}

@media screen {
    /* Needed to make the <cxx-titlepage>'s vertical spacing work.
       For print see the <cxx-titlepage> definition. */
    html, body {height: 100%}
}

*   .docname { string-set: docname content(); }
*   .pubyear { string-set: pubyear content(); }

cxx-clause, cxx-foreword { page-break-before: always; }
@media screen {
    cxx-clause, cxx-toc, cxx-foreword { margin-top: 3em; }
}

cxx-clause  header, cxx-foreword  h1 { font-size: 150%; }
cxx-toc  h1 { font-size: 150%; }
cxx-clause cxx-section  header { font-size: 117%; }
cxx-clause cxx-section cxx-section  header { font-size: 100%; }

[data-bookmark-label] { bookmark-label: attr(data-bookmark-label); }
h1 { bookmark-level: 1; }
cxx-toc  h1 { bookmark-level: 2; }
cxx-clause h1, cxx-foreword h1 { bookmark-level: 2; }
cxx-clause cxx-section h1 { bookmark-level: 3; }
cxx-clause cxx-section cxx-section h1 { bookmark-level: 4; }
/* The <h2> is a subtitle, which shouldn't get a PDF bookmark. */
cxx-titlepage  h2 { bookmark-level: none; }

*  .section-number { string-set: current-section "§ " content(); }

p {margin-top: .5em; margin-bottom: .5em}
p:first-child, ul, ol {margin-top: 0}

[para_num]::before { content: attr(para_num); float: left;
                     font-size: 70%; margin-left: -2.5em; width: 1.5em; text-align: right; }

del {text-decoration: line-through; color: #8B0040;}
ins {text-decoration: underline; color: #005100;}

pre {
    margin-left: 1em;
    margin-top: .5em;
    margin-bottom: .5em;
}

*   wbr::after {
    white-space: normal;
    content: '\200B';
}
*   code {
    /* Make inline code avoid line wraps unless we override it with <wbr>. */
    white-space: nowrap;
}
*   pre code {
    /* Keep block-code wrapping according to its context. */
    white-space: inherit;
}

*   table {
    border-collapse: collapse;
}
*   td, th {
    padding-left: .2em;
    padding-right: .2em;
    border: thin solid black;
}

/* Use an em-dash for the list bullet.
   'print' is a proxy for supporting ::marker. */
@media screen {
    ul {
        list-style: none;
        /* Relative positioning on the 'ul' lets the absolutely-positioned
           marker align relative to it.*/
        position: relative;
    }
    ul li:before {
        content: "\2014";
        position: absolute; left: 10px;
    }
}
@media print {
    ul li::marker {
        content: "\2014";
    }
    [is=cxx-table].list ul li::marker {
        content: none;
    }
}

/* This is here rather than inside elements/toc.html because browsers
   don't understand leader() or target-counter(), so they drop them
   inside the CSSOM. */
@media print {
    /* Generate page numbers in the table of contents. */
    cxx-toc  a[href]::after { content: leader(" . ") target-counter(attr(href), page); }

    cxx-footnote  aside { float: footnote; footnote-policy: line; }
}</style><style shim-shadowdom-css="">/*******************************
          Flex Layout
*******************************/

html   [layout][horizontal], html   [layout][vertical] {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}

html   [layout][horizontal][inline], html   [layout][vertical][inline] {
  display: -ms-inline-flexbox;
  display: -webkit-inline-flex;
  display: inline-flex;
}

html   [layout][horizontal] {
  -ms-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

html   [layout][horizontal][reverse] {
  -ms-flex-direction: row-reverse;
  -webkit-flex-direction: row-reverse;
  flex-direction: row-reverse;
}

html   [layout][vertical] {
  -ms-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

html   [layout][vertical][reverse] {
  -ms-flex-direction: column-reverse;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
}

html   [layout][wrap] {
  -ms-flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}

html   [layout][wrap-reverse] {
  -ms-flex-wrap: wrap-reverse;
  -webkit-flex-wrap: wrap-reverse;
  flex-wrap: wrap-reverse;
}

html   [flex] {
  -ms-flex: 1 1 0.000000001px;
  -webkit-flex: 1;
  flex: 1;
  -webkit-flex-basis: 0.000000001px;
  flex-basis: 0.000000001px;
}

html   [vertical][layout] > [flex][auto-vertical], html   [vertical][layout]  [flex][auto-vertical] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html   [flex][auto] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html   [flex][none] {
  -ms-flex: none;
  -webkit-flex: none;
  flex: none;
}

html   [flex][one] {
  -ms-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

html   [flex][two] {
  -ms-flex: 2;
  -webkit-flex: 2;
  flex: 2;
}

html   [flex][three] {
  -ms-flex: 3;
  -webkit-flex: 3;
  flex: 3;
}

html   [flex][four] {
  -ms-flex: 4;
  -webkit-flex: 4;
  flex: 4;
}

html   [flex][five] {
  -ms-flex: 5;
  -webkit-flex: 5;
  flex: 5;
}

html   [flex][six] {
  -ms-flex: 6;
  -webkit-flex: 6;
  flex: 6;
}

html   [flex][seven] {
  -ms-flex: 7;
  -webkit-flex: 7;
  flex: 7;
}

html   [flex][eight] {
  -ms-flex: 8;
  -webkit-flex: 8;
  flex: 8;
}

html   [flex][nine] {
  -ms-flex: 9;
  -webkit-flex: 9;
  flex: 9;
}

html   [flex][ten] {
  -ms-flex: 10;
  -webkit-flex: 10;
  flex: 10;
}

html   [flex][eleven] {
  -ms-flex: 11;
  -webkit-flex: 11;
  flex: 11;
}

html   [flex][twelve] {
  -ms-flex: 12;
  -webkit-flex: 12;
  flex: 12;
}

/* alignment in cross axis */

html   [layout][start] {
  -ms-flex-align: start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

html   [layout][center], html   [layout][center-center] {
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}

html   [layout][end] {
  -ms-flex-align: end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

/* alignment in main axis */

html   [layout][start-justified] {
  -ms-flex-pack: start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

html   [layout][center-justified], html   [layout][center-center] {
  -ms-flex-pack: center;
  -webkit-justify-content: center;
  justify-content: center;
}

html   [layout][end-justified] {
  -ms-flex-pack: end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

html   [layout][around-justified] {
  -ms-flex-pack: distribute;
  -webkit-justify-content: space-around;
  justify-content: space-around;
}

html   [layout][justified] {
  -ms-flex-pack: justify;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

/* self alignment */

html   [self-start] {
  -ms-align-self: flex-start;
  -webkit-align-self: flex-start;
  align-self: flex-start;
}

html   [self-center] {
  -ms-align-self: center;
  -webkit-align-self: center;
  align-self: center;
}

html   [self-end] {
  -ms-align-self: flex-end;
  -webkit-align-self: flex-end;
  align-self: flex-end;
}

html   [self-stretch] {
  -ms-align-self: stretch;
  -webkit-align-self: stretch;
  align-self: stretch;
}

/*******************************
          Other Layout
*******************************/

html   [block] {
  display: block;
}

/* ie support for hidden */
html   [hidden] {
  display: none !important;
}

html   [relative] {
  position: relative;
}

html   [fit] {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

body[fullbleed] {
  margin: 0;
  height: 100vh;
}

/*******************************
            Other
*******************************/

html   [segment], html   segment {
  display: block;
  position: relative;
  -webkit-box-sizing: border-box;
  -ms-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1em 0.5em;
  padding: 1em;
  background-color: white;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  border-radius: 5px 5px 5px 5px;
}</style>
<title>C++ Extensions for Library Fundamentals, Version 2, PDTS</title></head>
<body class="cxx-pdts">
<cxx-titlepage>
    
    

    
      <div class="page">
        <div class="header">
          
            <strong>ISO/IEC JTC1 SC22 WG21 <cxx-docnum class="docname">N4564</cxx-docnum></strong><br>
            Date: <time pubdate=""><span class="pubyear">2015</span>-11-05</time><br>
            
              ISO/IEC PDTS <cxx-project-number>19568</cxx-project-number><br>
            
            
          
          
          ISO/IEC JTC1 SC22 WG21<br>
          Secretariat: ANSI
        </div>
        <hgroup>
          <h1>Programming Languages — C++ Extensions for Library Fundamentals, Version 2</h1>
          
            <h2>Langages de programmation — Extensions C++ pour la bibliothèque fondamentaux, version 2</h2>
          
        </hgroup>
        <figure class="warning">
          <figcaption>Warning</figcaption>
          <p>This document is not an ISO International Standard. It is distributed for review and comment. It is
          subject to change without notice and may not be referred to as an International Standard.
          </p>
          <p>Recipients of this draft are invited to submit, with their comments, notification of any relevant
          patent rights of which they are aware and to provide supporting documentation.</p>
        </figure>
        <div class="footer">
          
            Document type: Proposed Draft Technical Specification<br>
            Document stage: (30) Committee<br>
          
          
          
          Document language: E
        </div>
      </div>
      <div class="page">
        <figure class="copyright">
          <p>© ISO 2015</p>
          <p>
            All rights reserved. Unless otherwise specified, no part
            of this publication may be reproduced or utilized
            otherwise in any form or by any means, electronic or
            mechanical, including photocopying, or posting on the
            internet or an intranet, without prior written permission.
            Permission can be requested from either ISO at the address
            below or ISO's member body in the country of the requester.
          </p>
          <address>
            ISO copyright office<br>
            Case postale 56 · CH-1211 Geneva 20<br>
            Tel. + 41 22 749 01 11<br>
            Fax + 41 22 749 09 47<br>
            E-mail <a href="mailto:copyright@iso.org">copyright@iso.org</a><br>
            Web <a href="http://www.iso.org/">www.iso.org</a>
          </address>
          <p>Published in Switzerland.</p>
        </figure>
      </div>
    

    
  </cxx-titlepage>

<cxx-toc>
    
    <nav>
      <h1>Contents</h1>
      
        
          <ol>
            
              <li><span class="marker">1</span><a href="#general">General</a>
        
          <ol>
            
              <li><span class="marker">1.1</span><a href="#general.scope">Scope</a>
        
      </li>
            
              <li><span class="marker">1.2</span><a href="#general.references">Normative references</a>
        
      </li>
            
              <li><span class="marker">1.3</span><a href="#general.namespaces">Namespaces, headers, and modifications to standard classes</a>
        
      </li>
            
              <li><span class="marker">1.4</span><a href="#general.defns">Terms and definitions</a>
        
      </li>
            
              <li><span class="marker">1.5</span><a href="#general.plans">Future plans (Informative)</a>
        
      </li>
            
              <li><span class="marker">1.6</span><a href="#general.feature.test">Feature-testing recommendations (Informative)</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2</span><a href="#mods">Modifications to the C++ Standard Library</a>
        
          <ol>
            
              <li><span class="marker">2.1</span><a href="#mods.allocator.uses">Uses-allocator construction</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3</span><a href="#utilities">General utilities library</a>
        
          <ol>
            
              <li><span class="marker">3.1</span><a href="#utility">Utility components</a>
        
          <ol>
            
              <li><span class="marker">3.1.1</span><a href="#utility.synop">Header &lt;experimental/utility&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">3.1.2</span><a href="#utility.erased.type">Class erased_type</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3.2</span><a href="#tuple">Tuples</a>
        
          <ol>
            
              <li><span class="marker">3.2.1</span><a href="#header.tuple.synop">Header &lt;experimental/tuple&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">3.2.2</span><a href="#tuple.apply">Calling a function with a tuple of arguments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3.3</span><a href="#meta">Metaprogramming and type traits</a>
        
          <ol>
            
              <li><span class="marker">3.3.1</span><a href="#meta.type.synop">Header &lt;experimental/type_traits&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">3.3.2</span><a href="#meta.trans.other">Other type transformations</a>
        
      </li>
            
              <li><span class="marker">3.3.3</span><a href="#meta.logical">Logical operator traits</a>
        
      </li>
            
              <li><span class="marker">3.3.4</span><a href="#meta.detect">Detection idiom</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3.4</span><a href="#ratio">Compile-time rational arithmetic</a>
        
          <ol>
            
              <li><span class="marker">3.4.1</span><a href="#header.ratio.synop">Header &lt;experimental/ratio&gt; synopsis</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3.5</span><a href="#time">Time utilities</a>
        
          <ol>
            
              <li><span class="marker">3.5.1</span><a href="#header.chrono.synop">Header &lt;experimental/chrono&gt; synopsis</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3.6</span><a href="#syserror">System error support</a>
        
          <ol>
            
              <li><span class="marker">3.6.1</span><a href="#header.system_error.synop">Header &lt;experimental/system_error&gt; synopsis</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3.7</span><a href="#propagate_const">Class template propagate_const</a>
        
          <ol>
            
              <li><span class="marker">3.7.1</span><a href="#propagate_const.general">Class template propagate_const general</a>
        
      </li>
            
              <li><span class="marker">3.7.2</span><a href="#propagate_const.synopsis">Header &lt;experimental/propagate_const&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">3.7.3</span><a href="#propagate_const.requirements">propagate_const requirements on T</a>
        
          <ol>
            
              <li><span class="marker">3.7.3.1</span><a href="#propagate_const.class_type_requirements">propagate_const requirements on class type T</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3.7.4</span><a href="#propagate_const.ctor">propagate_const constructors</a>
        
      </li>
            
              <li><span class="marker">3.7.5</span><a href="#propagate_const.assignment">propagate_const assignment</a>
        
      </li>
            
              <li><span class="marker">3.7.6</span><a href="#propagate_const.const_observers">propagate_const const observers</a>
        
      </li>
            
              <li><span class="marker">3.7.7</span><a href="#propagate_const.non_const_observers">propagate_const non-const observers</a>
        
      </li>
            
              <li><span class="marker">3.7.8</span><a href="#propagate_const.modifiers">propagate_const modifiers</a>
        
      </li>
            
              <li><span class="marker">3.7.9</span><a href="#propagate_const.relational">propagate_const relational operators</a>
        
      </li>
            
              <li><span class="marker">3.7.10</span><a href="#propagate_const.algorithms">propagate_const specialized algorithms</a>
        
      </li>
            
              <li><span class="marker">3.7.11</span><a href="#propagate_const.underlying">propagate_const underlying pointer access</a>
        
      </li>
            
              <li><span class="marker">3.7.12</span><a href="#propagate_const.hash">propagate_const hash support</a>
        
      </li>
            
              <li><span class="marker">3.7.13</span><a href="#propagate_const.comparison_function_objects">propagate_const comparison function objects</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">4</span><a href="#func">Function objects</a>
        
          <ol>
            
              <li><span class="marker">4.1</span><a href="#header.functional.synop">Header &lt;experimental/functional&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">4.2</span><a href="#func.wrap.func">Class template function</a>
        
          <ol>
            
              <li><span class="marker">4.2.1</span><a href="#func.wrap.func.con">function construct/copy/destroy</a>
        
      </li>
            
              <li><span class="marker">4.2.2</span><a href="#func.wrap.func.mod">function modifiers</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">4.3</span><a href="#func.searchers">Searchers</a>
        
          <ol>
            
              <li><span class="marker">4.3.1</span><a href="#func.searchers.default">Class template default_searcher</a>
        
          <ol>
            
              <li><span class="marker">4.3.1.1</span><a href="#func.searchers.default.creation">default_searcher creation functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">4.3.2</span><a href="#func.searchers.boyer_moore">Class template boyer_moore_searcher</a>
        
          <ol>
            
              <li><span class="marker">4.3.2.1</span><a href="#func.searchers.boyer_moore.creation">boyer_moore_searcher creation functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">4.3.3</span><a href="#func.searchers.boyer_moore_horspool">Class template boyer_moore_horspool_searcher</a>
        
          <ol>
            
              <li><span class="marker">4.3.3.1</span><a href="#func.searchers.boyer_moore_horspool.creation">boyer_moore_horspool_searcher creation functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">4.4</span><a href="#func.not_fn">Function template not_fn</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">5</span><a href="#optional">Optional objects</a>
        
          <ol>
            
              <li><span class="marker">5.1</span><a href="#optional.general">In general</a>
        
      </li>
            
              <li><span class="marker">5.2</span><a href="#optional.synop">Header &lt;experimental/optional&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">5.3</span><a href="#optional.object">optional for object types</a>
        
          <ol>
            
              <li><span class="marker">5.3.1</span><a href="#optional.object.ctor">Constructors</a>
        
      </li>
            
              <li><span class="marker">5.3.2</span><a href="#optional.object.dtor">Destructor</a>
        
      </li>
            
              <li><span class="marker">5.3.3</span><a href="#optional.object.assign">Assignment</a>
        
      </li>
            
              <li><span class="marker">5.3.4</span><a href="#optional.object.swap">Swap</a>
        
      </li>
            
              <li><span class="marker">5.3.5</span><a href="#optional.object.observe">Observers</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">5.4</span><a href="#optional.inplace">In-place construction</a>
        
      </li>
            
              <li><span class="marker">5.5</span><a href="#optional.nullopt">No-value state indicator</a>
        
      </li>
            
              <li><span class="marker">5.6</span><a href="#optional.bad_optional_access">Class bad_optional_access</a>
        
      </li>
            
              <li><span class="marker">5.7</span><a href="#optional.relops">Relational operators</a>
        
      </li>
            
              <li><span class="marker">5.8</span><a href="#optional.nullops">Comparison with nullopt</a>
        
      </li>
            
              <li><span class="marker">5.9</span><a href="#optional.comp_with_t">Comparison with T</a>
        
      </li>
            
              <li><span class="marker">5.10</span><a href="#optional.specalg">Specialized algorithms</a>
        
      </li>
            
              <li><span class="marker">5.11</span><a href="#optional.hash">Hash support</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">6</span><a href="#any">Class any</a>
        
          <ol>
            
              <li><span class="marker">6.1</span><a href="#any.synop">Header &lt;experimental/any&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">6.2</span><a href="#any.bad_any_cast">Class bad_any_cast</a>
        
      </li>
            
              <li><span class="marker">6.3</span><a href="#any.class">Class any</a>
        
          <ol>
            
              <li><span class="marker">6.3.1</span><a href="#any.cons">any construct/destruct</a>
        
      </li>
            
              <li><span class="marker">6.3.2</span><a href="#any.assign">any assignments</a>
        
      </li>
            
              <li><span class="marker">6.3.3</span><a href="#any.modifiers">any modifiers</a>
        
      </li>
            
              <li><span class="marker">6.3.4</span><a href="#any.observers">any observers</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">6.4</span><a href="#any.nonmembers">Non-member functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7</span><a href="#string.view">string_view</a>
        
          <ol>
            
              <li><span class="marker">7.1</span><a href="#string.view.synop">Header &lt;experimental/string_view&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">7.2</span><a href="#string.view.template">Class template basic_string_view</a>
        
      </li>
            
              <li><span class="marker">7.3</span><a href="#string.view.cons">basic_string_view constructors and assignment operators</a>
        
      </li>
            
              <li><span class="marker">7.4</span><a href="#string.view.iterators">basic_string_view iterator support</a>
        
      </li>
            
              <li><span class="marker">7.5</span><a href="#string.view.capacity">basic_string_view capacity</a>
        
      </li>
            
              <li><span class="marker">7.6</span><a href="#string.view.access">basic_string_view element access</a>
        
      </li>
            
              <li><span class="marker">7.7</span><a href="#string.view.modifiers">basic_string_view modifiers</a>
        
      </li>
            
              <li><span class="marker">7.8</span><a href="#string.view.ops">basic_string_view string operations</a>
        
          <ol>
            
              <li><span class="marker">7.8.1</span><a href="#string.view.find">Searching basic_string_view</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7.9</span><a href="#string.view.comparison">basic_string_view non-member comparison functions</a>
        
      </li>
            
              <li><span class="marker">7.10</span><a href="#string.view.io">Inserters and extractors</a>
        
      </li>
            
              <li><span class="marker">7.11</span><a href="#string.view.hash">Hash support</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8</span><a href="#memory">Memory</a>
        
          <ol>
            
              <li><span class="marker">8.1</span><a href="#header.memory.synop">Header &lt;experimental/memory&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.2</span><a href="#memory.smartptr">Shared-ownership pointers</a>
        
          <ol>
            
              <li><span class="marker">8.2.1</span><a href="#memory.smartptr.shared">Class template shared_ptr</a>
        
          <ol>
            
              <li><span class="marker">8.2.1.1</span><a href="#memory.smartptr.shared.const">shared_ptr constructors</a>
        
      </li>
            
              <li><span class="marker">8.2.1.2</span><a href="#memory.smartptr.shared.obs">shared_ptr observers</a>
        
      </li>
            
              <li><span class="marker">8.2.1.3</span><a href="#memory.smartptr.shared.cast">shared_ptr casts</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.2.2</span><a href="#memory.smartptr.weak">Class template weak_ptr</a>
        
          <ol>
            
              <li><span class="marker">8.2.2.1</span><a href="#memory.smartptr.weak.const">weak_ptr constructors</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.3</span><a href="#memory.type.erased.allocator">Type-erased allocator</a>
        
      </li>
            
              <li><span class="marker">8.4</span><a href="#memory.resource.synop">Header &lt;experimental/memory_resource&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.5</span><a href="#memory.resource">Class memory_resource</a>
        
          <ol>
            
              <li><span class="marker">8.5.1</span><a href="#memory.resource.overview">Class memory_resource overview</a>
        
      </li>
            
              <li><span class="marker">8.5.2</span><a href="#memory.resource.public">memory_resource public member functions</a>
        
      </li>
            
              <li><span class="marker">8.5.3</span><a href="#memory.resource.priv">memory_resource protected virtual member functions</a>
        
      </li>
            
              <li><span class="marker">8.5.4</span><a href="#memory.resource.eq">memory_resource equality</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.6</span><a href="#memory.polymorphic.allocator.class">Class template polymorphic_allocator</a>
        
          <ol>
            
              <li><span class="marker">8.6.1</span><a href="#memory.polymorphic.allocator.overview">Class template polymorphic_allocator overview</a>
        
      </li>
            
              <li><span class="marker">8.6.2</span><a href="#memory.polymorphic.allocator.ctor">polymorphic_allocator constructors</a>
        
      </li>
            
              <li><span class="marker">8.6.3</span><a href="#memory.polymorphic.allocator.mem">polymorphic_allocator member functions</a>
        
      </li>
            
              <li><span class="marker">8.6.4</span><a href="#memory.polymorphic.allocator.eq">polymorphic_allocator equality</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.7</span><a href="#memory.resource.adaptor">template alias resource_adaptor</a>
        
          <ol>
            
              <li><span class="marker">8.7.1</span><a href="#memory.resource.adaptor.overview">resource_adaptor</a>
        
      </li>
            
              <li><span class="marker">8.7.2</span><a href="#memory.resource.adaptor.ctor">resource_adaptor_imp constructors</a>
        
      </li>
            
              <li><span class="marker">8.7.3</span><a href="#memory.resource.adaptor.mem">resource_adaptor_imp member functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.8</span><a href="#memory.resource.global">Access to program-wide memory_resource objects</a>
        
      </li>
            
              <li><span class="marker">8.9</span><a href="#memory.resource.pool">Pool resource classes</a>
        
          <ol>
            
              <li><span class="marker">8.9.1</span><a href="#memory.resource.pool.overview">Classes synchronized_pool_resource and unsynchronized_pool_resource</a>
        
      </li>
            
              <li><span class="marker">8.9.2</span><a href="#memory.resource.pool.options">pool_options data members</a>
        
      </li>
            
              <li><span class="marker">8.9.3</span><a href="#memory.resource.pool.ctor">pool resource constructors and destructors</a>
        
      </li>
            
              <li><span class="marker">8.9.4</span><a href="#memory.resource.pool.mem">pool resource members</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.10</span><a href="#memory.resource.monotonic.buffer">Class monotonic_buffer_resource</a>
        
          <ol>
            
              <li><span class="marker">8.10.1</span><a href="#memory.resource.monotonic.buffer.overview">Class monotonic_buffer_resource overview</a>
        
      </li>
            
              <li><span class="marker">8.10.2</span><a href="#memory.resource.monotonic.buffer.ctor">monotonic_buffer_resource constructor and destructor</a>
        
      </li>
            
              <li><span class="marker">8.10.3</span><a href="#memory.resource.monotonic.buffer.mem">monotonic_buffer_resource members</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.11</span><a href="#memory.resource.aliases">Alias templates using polymorphic memory resources</a>
        
          <ol>
            
              <li><span class="marker">8.11.1</span><a href="#header.string.synop">Header &lt;experimental/string&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.11.2</span><a href="#header.deque.synop">Header &lt;experimental/deque&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.11.3</span><a href="#header.forward_list.synop">Header &lt;experimental/forward_list&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.11.4</span><a href="#header.list.synop">Header &lt;experimental/list&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.11.5</span><a href="#header.vector.synop">Header &lt;experimental/vector&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.11.6</span><a href="#header.map.synop">Header &lt;experimental/map&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.11.7</span><a href="#header.set.synop">Header &lt;experimental/set&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.11.8</span><a href="#header.unordered_map.synop">Header &lt;experimental/unordered_map&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.11.9</span><a href="#header.unordered_set.synop">Header &lt;experimental/unordered_set&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">8.11.10</span><a href="#header.regex.synop">Header &lt;experimental/regex&gt; synopsis</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.12</span><a href="#memory.observer.ptr">Non-owning pointers</a>
        
          <ol>
            
              <li><span class="marker">8.12.1</span><a href="#memory.observer.ptr.overview">Class template observer_ptr overview</a>
        
      </li>
            
              <li><span class="marker">8.12.2</span><a href="#memory.observer.ptr.ctor">observer_ptr constructors</a>
        
      </li>
            
              <li><span class="marker">8.12.3</span><a href="#memory.observer.ptr.obs">observer_ptr observers</a>
        
      </li>
            
              <li><span class="marker">8.12.4</span><a href="#memory.observer.ptr.conv">observer_ptr conversions</a>
        
      </li>
            
              <li><span class="marker">8.12.5</span><a href="#memory.observer.ptr.mod">observer_ptr modifiers</a>
        
      </li>
            
              <li><span class="marker">8.12.6</span><a href="#memory.observer.ptr.special">observer_ptr specialized algorithms</a>
        
      </li>
            
              <li><span class="marker">8.12.7</span><a href="#memory.observer.ptr.hash">observer_ptr hash support</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">9</span><a href="#container">Containers</a>
        
          <ol>
            
              <li><span class="marker">9.1</span><a href="#container.erasure">Uniform container erasure</a>
        
          <ol>
            
              <li><span class="marker">9.1.1</span><a href="#container.erasure.syn">Header synopsis</a>
        
      </li>
            
              <li><span class="marker">9.1.2</span><a href="#container.erasure.erase_if">Function template erase_if</a>
        
      </li>
            
              <li><span class="marker">9.1.3</span><a href="#container.erasure.erase">Function template erase</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">9.2</span><a href="#container.array">Class template array</a>
        
          <ol>
            
              <li><span class="marker">9.2.1</span><a href="#header.array.synop">Header &lt;experimental/array&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">9.2.2</span><a href="#container.array.creation">Array creation functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">10</span><a href="#iterator">Iterators library</a>
        
          <ol>
            
              <li><span class="marker">10.1</span><a href="#iterator.synopsis">Header &lt;experimental/iterator&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">10.2</span><a href="#iterator.ostream.joiner">Class template ostream_joiner</a>
        
          <ol>
            
              <li><span class="marker">10.2.1</span><a href="#iterator.ostream.joiner.cons">ostream_joiner constructor</a>
        
      </li>
            
              <li><span class="marker">10.2.2</span><a href="#iterator.ostream.joiner.ops">ostream_joiner operations</a>
        
      </li>
            
              <li><span class="marker">10.2.3</span><a href="#iterator.ostream.joiner.creation">ostream_joiner creation function</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">11</span><a href="#futures">Futures</a>
        
          <ol>
            
              <li><span class="marker">11.1</span><a href="#header.future.synop">Header &lt;experimental/future&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">11.2</span><a href="#futures.promise">Class template promise</a>
        
      </li>
            
              <li><span class="marker">11.3</span><a href="#futures.task">Class template packaged_task</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">12</span><a href="#algorithms">Algorithms library</a>
        
          <ol>
            
              <li><span class="marker">12.1</span><a href="#header.algorithm.synop">Header &lt;experimental/algorithm&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">12.2</span><a href="#alg.search">Search</a>
        
      </li>
            
              <li><span class="marker">12.3</span><a href="#alg.random.sample">Sampling</a>
        
      </li>
            
              <li><span class="marker">12.4</span><a href="#alg.random.shuffle">Shuffle</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">13</span><a href="#numeric">Numerics library</a>
        
          <ol>
            
              <li><span class="marker">13.1</span><a href="#numeric.ops">Generalized numeric operations</a>
        
          <ol>
            
              <li><span class="marker">13.1.1</span><a href="#numeric.ops.overview">Header &lt;experimental/numeric&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">13.1.2</span><a href="#numeric.ops.gcd">Greatest common divisor</a>
        
      </li>
            
              <li><span class="marker">13.1.3</span><a href="#numeric.ops.lcm">Least common multiple</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">13.2</span><a href="#rand">Random number generation</a>
        
          <ol>
            
              <li><span class="marker">13.2.1</span><a href="#rand.synopsis">Header &lt;experimental/random&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">13.2.2</span><a href="#rand.util">Utilities</a>
        
          <ol>
            
              <li><span class="marker">13.2.2.1</span><a href="#rand.util.randint">Function template randint</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14</span><a href="#reflection">Reflection library</a>
        
          <ol>
            
              <li><span class="marker">14.1</span><a href="#reflection.src_loc">Class source_location</a>
        
          <ol>
            
              <li><span class="marker">14.1.1</span><a href="#reflection.src_loc.synop">Header &lt;experimental/source_location&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">14.1.2</span><a href="#reflection.src_loc.creation">source_location creation</a>
        
      </li>
            
              <li><span class="marker">14.1.3</span><a href="#reflection.src_loc.fields">source_location field access</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      
    </nav>
  </cxx-toc>

<cxx-clause id="general">
    

    <section>
      <header><span class="section-number">1</span> <h1 data-bookmark-label="1 General">General</h1> <span style="float:right"><a href="#general">[general]</a></span></header>
      
  
  <cxx-section id="general.scope">
    

    <section>
      <header><span class="section-number">1.1</span> <h1 data-bookmark-label="1.1 Scope">Scope</h1> <span style="float:right"><a href="#general.scope">[general.scope]</a></span></header>
      
    
    <p para_num="1" id="general.scope.1">This technical specification describes extensions to the C++
    Standard Library (<cxx-ref to="general.references"><a title="general.references" href="#general.references">1.2</a></cxx-ref>). These extensions are classes
    and functions that are likely to be used widely within a program
    and/or on the interface boundaries between libraries written by
    different organizations.</p>

    <p para_num="2" id="general.scope.2">This technical specification is non-normative. Some of the
    library components in this technical specification may be
    considered for standardization in a future version of C++, but
    they are not currently part of any C++ standard. Some of the
    components in this technical specification may never be
    standardized, and others may be standardized in a substantially
    changed form.</p>

    <p para_num="3" id="general.scope.3">The goal of this technical specification is to build more
    widespread existing practice for an expanded C++ standard
    library. It gives advice on extensions to those vendors who wish
    to provide them.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.references">
    

    <section>
      <header><span class="section-number">1.2</span> <h1 data-bookmark-label="1.2 Normative references">Normative references</h1> <span style="float:right"><a href="#general.references">[general.references]</a></span></header>
      
    

    <p para_num="1" id="general.references.1">The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>

    <ul>
      <li>ISO/IEC 14882:2014, <cite>Programming Languages — C++</cite>
      </li>
    </ul>

    <p para_num="2" id="general.references.2">ISO/IEC 14882:— is herein called the <dfn>C++ Standard</dfn>.
    References to clauses within the C++ Standard are written as "C++14
    §3.2". The library described in ISO/IEC 14882:— clauses 17–30 is
    herein called the <dfn>C++ Standard Library</dfn>.</p>

    <p para_num="3" id="general.references.3">Unless otherwise specified, the whole of the C++ Standard's Library
    introduction (<cxx-ref in="cxx" to="library">C++14 <span title="library">§17</span></cxx-ref>) is included into this
    Technical Specification by reference.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.namespaces">
    

    <section>
      <header><span class="section-number">1.3</span> <h1 data-bookmark-label="1.3 Namespaces, headers, and modifications to standard classes">Namespaces, headers, and modifications to standard classes</h1> <span style="float:right"><a href="#general.namespaces">[general.namespaces]</a></span></header>
      
    

    <p para_num="1" id="general.namespaces.1">Since the extensions described in this technical specification
    are experimental and not part of the C++ standard library, they
    should not be declared directly within namespace
    <code>std</code>.
    Unless otherwise specified, all components described in this technical specification either:
    </p>
    <ul>
      <li>modify an existing interface in the C++ Standard Library in-place,</li>
      <li>
        are declared in a namespace whose name appends <code>::experimental::fundamentals_v2</code>
        to a namespace defined in the C++ Standard Library,
        such as <code>std</code> or <code>std::chrono</code>, or
      </li>
      <li>
        are declared in a subnamespace of a namespace described in the previous bullet,
        whose name is not the same as an existing subnamespace of namespace <code>std</code>.
      </li>
    </ul>

    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      This TS does not define <code>std::experimental::fundamentals_v2::chrono</code>
      because the C++ Standard Library defines <code>std::chrono</code>.
      This TS does not define <code>std::pmr::experimental::fundamentals_v2</code>
      because the C++ Standard Library does not define <code>std::pmr</code>.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

    <p para_num="2" id="general.namespaces.2">Each header described in this technical
    specification shall import the contents of
    <code>std::experimental::fundamentals_v2</code> into
    <code>std::experimental</code> as if by</p>

    <pre><code>namespace std {
  namespace experimental {
    inline namespace fundamentals_v2 {}
  }
}</code></pre>

    <p para_num="3" id="general.namespaces.3">
      This technical specification also describes some experimental 
modifications to existing interfaces in the C++ Standard Library.
      These modifications are described by quoting the affected parts of
 the standard
      and using <ins>underlining</ins> to represent added text and <del>strike-through</del> to represent deleted text.
    </p>

    <p para_num="4" id="general.namespaces.4">Unless otherwise specified, references to other entities
    described in this technical specification are assumed to be
    qualified with <code>std::experimental::fundamentals_v2::</code>,
    and references to entities described in the standard are assumed
    to be qualified with <code>std::</code>.</p>

    <p para_num="5" id="general.namespaces.5">Extensions that are expected to eventually be added to an
    existing header <code>&lt;meow&gt;</code> are provided inside the
    <code>&lt;experimental/meow&gt;</code> header, which shall include
    the standard contents of <code>&lt;meow&gt;</code> as if by</p>
    <pre><code>#include &lt;meow&gt;</code></pre>

    <p para_num="6" id="general.namespaces.6">New headers are also provided in the
    <code>&lt;experimental/&gt;</code> directory, but without such an
    <code>#include</code>.</p>

    <table role="presentation" is="cxx-table" id="tab.cxx.headers" class="list" columns="3">
    

    <caption>Table 1 — <wbr><span>C++ library headers</span></caption>
    
      
      <tbody><tr><td><ul><li><code>&lt;experimental/algorithm&gt;</code></li><li><code>&lt;experimental/any&gt;</code></li><li><code>&lt;experimental/array&gt;</code></li><li><code>&lt;experimental/chrono&gt;</code></li><li><code>&lt;experimental/deque&gt;</code></li><li><code>&lt;experimental/forward_list&gt;</code></li><li><code>&lt;experimental/functional&gt;</code></li><li><code>&lt;experimental/future&gt;</code></li><li><code>&lt;experimental/iterator&gt;</code></li><li><code>&lt;experimental/list&gt;</code></li></ul></td><td><ul><li><code>&lt;experimental/map&gt;</code></li><li><code>&lt;experimental/memory&gt;</code></li><li><code>&lt;experimental/memory_resource&gt;</code></li><li><code>&lt;experimental/optional&gt;</code></li><li><code>&lt;experimental/propagate_const&gt;</code></li><li><code>&lt;experimental/random&gt;</code></li><li><code>&lt;experimental/ratio&gt;</code></li><li><code>&lt;experimental/regex&gt;</code></li><li><code>&lt;experimental/set&gt;</code></li><li><code>&lt;experimental/source_location&gt;</code></li></ul></td><td><ul><li><code>&lt;experimental/string&gt;</code></li><li><code>&lt;experimental/string_view&gt;</code></li><li><code>&lt;experimental/system_error&gt;</code></li><li><code>&lt;experimental/tuple&gt;</code></li><li><code>&lt;experimental/type_traits&gt;</code></li><li><code>&lt;experimental/unordered_map&gt;</code></li><li><code>&lt;experimental/unordered_set&gt;</code></li><li><code>&lt;experimental/utility&gt;</code></li><li><code>&lt;experimental/vector&gt;</code></li></ul></td></tr>
    </tbody>
  </table>
  
    </section>
  </cxx-section>

  <cxx-section id="general.defns">
    

    <section>
      <header><span class="section-number">1.4</span> <h1 data-bookmark-label="1.4 Terms and definitions">Terms and definitions</h1> <span style="float:right"><a href="#general.defns">[general.defns]</a></span></header>
      
    

    <p para_num="1" id="general.defns.1">For the purposes of this document, the terms and definitions
    given in the C++ Standard and the following apply.</p>

    <dl is="cxx-definition-section">
    

    
      <dt id="general.defns.direct-non-list-init">
    1.4.1
    <span style="float:right"><a href="#general.defns.direct-non-list-init">[general.defns.direct-non-list-init]</a></span>
    <br clear="all">
    direct-non-list-initialization
  </dt>
      <dd>A direct-initialization that is not list-initialization.</dd>
    
  </dl>
  
    </section>
  </cxx-section>

  <cxx-section id="general.plans">
    

    <section>
      <header><span class="section-number">1.5</span> <h1 data-bookmark-label="1.5 Future plans (Informative)">Future plans (Informative)</h1> <span style="float:right"><a href="#general.plans">[general.plans]</a></span></header>
      
    

    <p para_num="1" id="general.plans.1">This section describes tentative plans for future versions of
    this technical specification and plans for moving content into
    future versions of the C++ Standard.</p>

    <p para_num="2" id="general.plans.2">The C++ committee intends to release a new version of this
    technical specification approximately every year, containing the
    library extensions we hope to add to a near-future version of the
    C++ Standard.  Future versions will define their contents in
    <code>std::experimental::fundamentals_v3</code>,
    <code>std::experimental::fundamentals_v4</code>, etc., with the
    most recent implemented version inlined into
    <code>std::experimental</code>.</p>

    <p para_num="3" id="general.plans.3">When an extension defined in this or a future version of this
    technical specification represents enough existing practice, it
    will be moved into the next version of the C++ Standard by
    removing the <code>experimental::fundamentals_v<var>N</var></code>
    segment of its namespace and by removing the
    <code>experimental/</code> prefix from its header's path.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.feature.test">
    

    <section>
      <header><span class="section-number">1.6</span> <h1 data-bookmark-label="1.6 Feature-testing recommendations (Informative)">Feature-testing recommendations (Informative)</h1> <span style="float:right"><a href="#general.feature.test">[general.feature.test]</a></span></header>
      
    

    <p para_num="1" id="general.feature.test.1">
      For the sake of improved portability between partial implementations of various C++ standards,
      WG21 (the ISO technical committee for the C++ programming language) recommends
      that implementers and programmers follow the guidelines in this section concerning feature-test macros.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    <a href="http://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">WG21's SD-6</a> makes similar recommendations for the C++ Standard itself.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <p para_num="2" id="general.feature.test.2">
      Implementers who provide a new standard feature should define a 
macro with the recommended name,
      in the same circumstances under which the feature is available 
(for example, taking into account relevant command-line options),
      to indicate the presence of support for that feature.
      Implementers should define that macro with the value specified in
      the most recent version of this technical specification that they 
have implemented.
      The recommended macro name is "<code>__cpp_lib_experimental_</code>" followed by the string in the "Macro Name Suffix" column.
    </p>

    <p para_num="3" id="general.feature.test.3">
      Programmers who wish to determine whether a feature is available in an implementation should base that determination on
      the presence of the header (determined with <code>__has_include(&lt;header/name&gt;)</code>)
 and
      the state of the macro with the recommended name.
      (The absence of a tested feature may result in a program with 
decreased functionality, or the relevant functionality may be provided 
in a different way.
      A program that strictly depends on support for a feature can just 
try to use the feature unconditionally;
      presumably, on an implementation lacking necessary support, 
translation will fail.)
    </p>

    <table is="cxx-table" class="column-rules">
    

    <caption>Table 2 — <wbr><span>Significant features in this technical specification</span></caption>
    
      

      <thead>
        <tr>
          <th>Doc. No.</th>
          <th>Title</th>
          <th>Primary Section</th>
          <th>Macro Name Suffix</th>
          <th>Value</th>
          <th>Header</th>
        </tr>
      </thead>

      <!-- These rows are in the same order as their feature appears in this document. -->
      <tbody><tr>
        <td>N3915</td>
        <td>apply() call a function with arguments from a tuple</td>
        <td><cxx-ref to="tuple.apply"><a title="tuple.apply" href="#tuple.apply">3.2.2</a></cxx-ref></td>
        <td><code>apply</code></td>
        <td>201402</td>
        <td><code>&lt;experimental/tuple&gt;</code></td>
      </tr>
      <tr>
        <td>N3932</td>
        <td>Variable Templates For Type Traits</td>
        <td><cxx-ref to="meta.type.synop"><a title="meta.type.synop" href="#meta.type.synop">3.3.1</a></cxx-ref></td>
        <td><code>type_trait_variable_templates</code></td>
        <td>201402</td>
        <td><code>&lt;experimental/type_traits&gt;</code></td>
      </tr>
      <tr>
        <td>N3866</td>
        <td>Invocation type traits</td>
        <td><cxx-ref to="meta.trans.other"><a title="meta.trans.other" href="#meta.trans.other">3.3.2</a></cxx-ref></td>
        <td><code>invocation_type</code></td>
        <td>201406</td>
        <td><code>&lt;experimental/type_traits&gt;</code></td>
      </tr>
      <tr>
        <td>P0013R1</td>
        <td>Logical Operator Type Traits</td>
        <td><cxx-ref to="meta.logical"><a title="meta.logical" href="#meta.logical">3.3.3</a></cxx-ref></td>
        <td><code>logical_traits</code></td>
        <td>201511</td>
        <td><code>&lt;experimental/type_traits&gt;</code></td>
      </tr>
      <tr>
        <td>N4502</td>
        <td>The C++ Detection Idiom</td>
        <td><cxx-ref to="meta.detect"><a title="meta.detect" href="#meta.detect">3.3.4</a></cxx-ref></td>
        <td><code>detect</code></td>
        <td>201505</td>
        <td><code>&lt;experimental/type_traits&gt;</code></td>
      </tr>
      <tr>
        <td>N4388</td>
        <td>A Proposal to Add a Const-Propagating Wrapper to the Standard Library
        </td><td><cxx-ref to="propagate_const"><a title="propagate_const" href="#propagate_const">3.7</a></cxx-ref>
        </td><td><code>propagate_const</code>
        </td><td>201505
        </td><td><code>&lt;experimental/propagate_const&gt;</code>
      </td></tr>
      <tr>
        <td>N3916</td>
        <td>Type-erased allocator for <code>std::function</code></td>
        <td><cxx-ref to="func.wrap.func"><a title="func.wrap.func" href="#func.wrap.func">4.2</a></cxx-ref></td>
        <td><code>function_erased_allocator</code></td>
        <td>201406</td>
        <td><code>&lt;experimental/functional&gt;</code></td>
      </tr>
      <tr>
        <td>N3905</td>
        <td>Extending <code>std::search</code> to use Additional Searching Algorithms</td>
        <td><cxx-ref to="func.searchers"><a title="func.searchers" href="#func.searchers">4.3</a></cxx-ref></td>
        <td><code>boyer_moore_searching</code></td>
        <td>201411</td>
        <td><code>&lt;experimental/functional&gt;</code></td>
      </tr>
      <tr>
        <td>N4076</td>
        <td>A proposal to add a generalized callable negator
        </td><td><cxx-ref to="func.not_fn"><a title="func.not_fn" href="#func.not_fn">4.4</a></cxx-ref>
        </td><td><code>not_fn</code>
        </td><td>201406
        </td><td><code>&lt;experimental/functional&gt;</code>
      </td></tr>
      <tr>
        <td>N3672, N3793</td>
        <td>A utility class to represent optional objects</td>
        <td><cxx-ref to="optional"><a title="optional" href="#optional">5</a></cxx-ref></td>
        <td><code>optional</code></td>
        <td>201411</td>
        <td><code>&lt;experimental/optional&gt;</code></td>
      </tr>
      <tr>
        <td>N3804</td>
        <td>Any Library Proposal</td>
        <td><cxx-ref to="any"><a title="any" href="#any">6</a></cxx-ref></td>
        <td><code>any</code></td>
        <td>201411</td>
        <td><code>&lt;experimental/any&gt;</code></td>
      </tr>
      <tr>
        <td>N3921</td>
        <td><code>string_view</code>: a non-owning reference to a string</td>
        <td><cxx-ref to="string.view"><a title="string.view" href="#string.view">7</a></cxx-ref></td>
        <td><code>string_view</code></td>
        <td>201411</td>
        <td><code>&lt;experimental/string_view&gt;</code></td>
      </tr>
      <tr>
        <td>N3920</td>
        <td>Extending shared_ptr to Support Arrays</td>
        <td><cxx-ref to="memory.smartptr"><a title="memory.smartptr" href="#memory.smartptr">8.2</a></cxx-ref></td>
        <td><code>shared_ptr_arrays</code></td>
        <td>201406</td>
        <td><code>&lt;experimental/memory&gt;</code></td>
      </tr>
      <tr>
        <td>N3916</td>
        <td>Polymorphic Memory Resources</td>
        <td><cxx-ref to="memory.resource.synop"><a title="memory.resource.synop" href="#memory.resource.synop">8.4</a></cxx-ref></td>
        <td><code>memory_resources</code></td>
        <td>201402</td>
        <td><code>&lt;experimental/memory_resource&gt;</code></td>
      </tr>
      <tr>
        <td>N4282</td>
        <td>The World’s Dumbest Smart Pointer
        </td><td><cxx-ref to="memory.observer.ptr"><a title="memory.observer.ptr" href="#memory.observer.ptr">8.12</a></cxx-ref>
        </td><td><code>observer_ptr</code>
        </td><td>201411
        </td><td><code>&lt;experimental/memory&gt;</code>
      </td></tr>
      <tr>
        <td>N4273</td>
        <td>Uniform Container Erasure</td>
        <td><cxx-ref to="container.erasure"><a title="container.erasure" href="#container.erasure">9.1</a></cxx-ref></td>
        <td><code>erase_if</code></td>
        <td>201411</td>
        <td><code>&lt;experimental/vector&gt;</code></td>
      </tr>
      <tr>
        <td>N4391</td>
        <td>make_array</td>
        <td><cxx-ref to="container.array.creation"><a title="container.array.creation" href="#container.array.creation">9.2.2</a></cxx-ref></td>
        <td><code>make_array</code></td>
        <td>201505</td>
        <td><code>&lt;experimental/array&gt;</code></td>
      </tr>
      <tr>
        <td>N4257</td>
        <td>Delimited iterators</td>
        <td><cxx-ref to="iterator.ostream.joiner"><a title="iterator.ostream.joiner" href="#iterator.ostream.joiner">10.2</a></cxx-ref></td>
        <td><code>ostream_joiner</code></td>
        <td>201411</td>
        <td><code>&lt;experimental/iterator&gt;</code></td>
      </tr>
      <tr>
        <td>N3916</td>
        <td>Type-erased allocator for <code>std::promise</code></td>
        <td><cxx-ref to="futures.promise"><a title="futures.promise" href="#futures.promise">11.2</a></cxx-ref></td>
        <td><code>promise_erased_allocator</code></td>
        <td>201406</td>
        <td><code>&lt;experimental/future&gt;</code></td>
      </tr>
      <tr>
        <td>N3916</td>
        <td>Type-erased allocator for <code>std::packaged_task</code></td>
        <td><cxx-ref to="futures.task"><a title="futures.task" href="#futures.task">11.3</a></cxx-ref></td>
        <td><code>packaged_task_erased_allocator</code></td>
        <td>201406</td>
        <td><code>&lt;experimental/future&gt;</code></td>
      </tr>
      <tr>
        <td>N3925</td>
        <td>A <code>sample</code> Proposal</td>
        <td><cxx-ref to="alg.random.sample"><a title="alg.random.sample" href="#alg.random.sample">12.3</a></cxx-ref></td>
        <td><code>sample</code></td>
        <td>201402</td>
        <td><code>&lt;experimental/algorithm&gt;</code></td>
      </tr>
      <tr>
        <td>N4061</td>
        <td>Greatest Common Divisor and Least Common Multiple</td>
        <td><cxx-ref to="numeric.ops.gcd"><a title="numeric.ops.gcd" href="#numeric.ops.gcd">13.1.2</a></cxx-ref>, <cxx-ref to="numeric.ops.lcm"><a title="numeric.ops.lcm" href="#numeric.ops.lcm">13.1.3</a></cxx-ref></td>
        <td><code>gcd_lcm</code></td>
        <td>201411</td>
        <td><code>&lt;experimental/numeric&gt;</code></td>
      </tr>
      <tr>
        <td>N4531</td>
        <td><code>std::rand</code> replacement</td>
        <td><cxx-ref to="rand.util.randint"><a title="rand.util.randint" href="#rand.util.randint">13.2.2.1</a></cxx-ref></td>
        <td><code>randint</code></td>
        <td>201511</td>
        <td><code>&lt;experimental/random&gt;</code></td>
      </tr>
      <tr>
        <td>N4519</td>
        <td>Source-Code Information Capture</td>
        <td><cxx-ref to="reflection.src_loc"><a title="reflection.src_loc" href="#reflection.src_loc">14.1</a></cxx-ref></td>
        <td><code>source_location</code></td>
        <td>201505</td>
        <td><code>&lt;experimental/source_location&gt;</code></td>
      </tr>
    </tbody>
  </table>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="mods">
    

    <section>
      <header><span class="section-number">2</span> <h1 data-bookmark-label="2 Modifications to the C++ Standard Library">Modifications to the C++ Standard Library</h1> <span style="float:right"><a href="#mods">[mods]</a></span></header>
      
  

  <p para_num="1" id="mods.1">
    Implementations that conform to this technical specification shall
    behave as if the modifications contained in this section are made to the C++ Standard.
  </p>

  <cxx-section id="mods.allocator.uses">
    

    <section>
      <header><span class="section-number">2.1</span> <h1 data-bookmark-label="2.1 Uses-allocator construction">Uses-allocator construction</h1> <span style="float:right"><a href="#mods.allocator.uses">[mods.allocator.uses]</a></span></header>
      
    

    <p para_num="1" id="mods.allocator.uses.1">
      The following changes to the <code>uses_allocator</code> trait and to the description of uses-allocator construction
      allow a <code>memory_resource</code> pointer act as an allocator in many circumstances.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Existing programs that use standard allocators would be unaffected by this change.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <blockquote>
      <p><b>20.7.7 uses_allocator [allocator.uses]</b></p>
      <p><b>20.7.7.1 uses_allocator trait [allocator.uses.trait]</b></p>

      <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T, class Alloc&gt; struct uses_allocator;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-remarks>
    
    <dt>Remarks:</dt><dd>
          Automatically detects whether <code>T</code> has a nested <code>allocator_type</code> that is convertible from <code>Alloc</code>.
          Meets the BinaryTypeTrait requirements (<cxx-ref in="cxx" to="meta.rqmts">C++14 <span title="meta.rqmts">§20.10.1</span></cxx-ref>).
          The implementation shall provide a definition that is derived from <code>true_type</code> if a type <code>T::allocator_type</code> exists
          and <ins>either</ins> <code>is_convertible_v&lt;Alloc, T::allocator_type&gt; != false</code>
          <ins>or <code>T::allocator_type</code> is an alias for <code>std::experimental::erased_type</code> (<cxx-ref to="utility.erased.type"><a title="utility.erased.type" href="#utility.erased.type">3.1.2</a></cxx-ref>)</ins>,
          otherwise it shall be derived from <code>false_type</code>.
          A program may specialize this template to derive from <code>true_type</code> for a user-defined type <code>T</code> that does not have a nested <code>allocator_type</code> but nonetheless can be constructed with an allocator where either:
          <ul>
            <li>the first argument of a constructor has type <code>allocator_arg_t</code> and the second argument has type <code>Alloc</code> or</li>
            <li>the last argument of a constructor has type <code>Alloc</code>.</li>
          </ul>
        </dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <p><b>20.7.7.2 uses-allocator construction [allocator.uses.construction]</b></p>

      <p>
        <dfn>Uses-allocator construction</dfn> with allocator <code>Alloc</code> refers to the construction of an object <code>obj</code> of type <code>T</code>,
        using constructor arguments <code>v1, v2, ..., vN</code> of types <code>V1, V2, ..., VN</code>, respectively,
        and an allocator <code>alloc</code> of type <code>Alloc</code>,
        <ins>where <code>Alloc</code> either (1) meets the requirements of an allocator (<cxx-ref in="cxx" to="allocator.requirements">C++14 <span title="allocator.requirements">§17.6.3.5</span></cxx-ref>),
        or (2) is a pointer type convertible to <code>std::experimental::pmr::memory_resource*</code> (<cxx-ref to="memory.resource"><a title="memory.resource" href="#memory.resource">8.5</a></cxx-ref>),</ins>
        according to the following rules:
      </p>
    </blockquote>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="utilities">
    

    <section>
      <header><span class="section-number">3</span> <h1 data-bookmark-label="3 General utilities library">General utilities library</h1> <span style="float:right"><a href="#utilities">[utilities]</a></span></header>
      
  

  <cxx-section id="utility">
    

    <section>
      <header><span class="section-number">3.1</span> <h1 data-bookmark-label="3.1 Utility components">Utility components</h1> <span style="float:right"><a href="#utility">[utility]</a></span></header>
      
    

    <cxx-section id="utility.synop">
    

    <section>
      <header><span class="section-number">3.1.1</span> <h1 data-bookmark-label="3.1.1 Header &lt;experimental/utility&gt; synopsis">Header <code>&lt;experimental/utility&gt;</code> synopsis</h1> <span style="float:right"><a href="#utility.synop">[utility.synop]</a></span></header>
      
      

<pre><code>#include &lt;utility&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="utility.erased.type">// <i><a title="utility.erased.type" href="#utility.erased.type">3.1.2</a>, Class erased_type</i></cxx-ref>
  struct erased_type { };

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>

    
    </section>
  </cxx-section>

    <cxx-section id="utility.erased.type">
    

    <section>
      <header><span class="section-number">3.1.2</span> <h1 data-bookmark-label="3.1.2 Class erased_type">Class <code>erased_type</code></h1> <span style="float:right"><a href="#utility.erased.type">[utility.erased.type]</a></span></header>
      
      

      <cxx-function para_num="1" id="utility.erased.type.1">
    
    <pre><code><cxx-signature>struct erased_type { };</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="utility.erased.type.2">
          The <code>erased_type</code> <code>struct</code> is an empty <code>struct</code> that serves as a placeholder for a type <code>T</code> in situations where the actual type <code>T</code> is determined at runtime.
          For example, the nested type, <code>allocator_type</code>, is an alias for <code>erased_type</code> in classes that use <i>type-erased allocators</i> (see <cxx-ref to="memory.type.erased.allocator"><a title="memory.type.erased.allocator" href="#memory.type.erased.allocator">8.3</a></cxx-ref>).
        </p>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="tuple">
    

    <section>
      <header><span class="section-number">3.2</span> <h1 data-bookmark-label="3.2 Tuples">Tuples</h1> <span style="float:right"><a href="#tuple">[tuple]</a></span></header>
      
    

    <cxx-section id="header.tuple.synop">
    

    <section>
      <header><span class="section-number">3.2.1</span> <h1 data-bookmark-label="3.2.1 Header &lt;experimental/tuple&gt; synopsis">Header &lt;experimental/tuple&gt; synopsis</h1> <span style="float:right"><a href="#header.tuple.synop">[header.tuple.synop]</a></span></header>
      
      

<pre><code>#include &lt;tuple&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  // See <cxx-ref in="cxx" to="tuple.helper">C++14 <span title="tuple.helper">§20.4.2.5</span></cxx-ref>, tuple helper classes
  template &lt;class T&gt; constexpr size_t tuple_size_v
    = tuple_size&lt;T&gt;::value;

  <cxx-ref insynopsis="" to="tuple.apply">// <i><a title="tuple.apply" href="#tuple.apply">3.2.2</a>, Calling a function with a tuple of arguments</i></cxx-ref>
  template &lt;class F, class Tuple&gt;
  constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t);

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="tuple.apply">
    

    <section>
      <header><span class="section-number">3.2.2</span> <h1 data-bookmark-label="3.2.2 Calling a function with a tuple of arguments">Calling a function with a <code>tuple</code> of arguments</h1> <span style="float:right"><a href="#tuple.apply">[tuple.apply]</a></span></header>
      
      

      <cxx-function para_num="1" id="tuple.apply.1">
    
    <pre><code><cxx-signature>template &lt;class F, class Tuple&gt;
constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="tuple.apply.2">
    
    <dt>Effects:</dt><dd>
          <p>Given the exposition only function</p>
          <pre><code>template &lt;class F, class Tuple, size_t... I&gt;
constexpr decltype(auto) apply_impl(  // <i>exposition only</i>
    F&amp;&amp; f, Tuple&amp;&amp; t, index_sequence&lt;I...&gt;) {
  return <em>INVOKE</em>(std::forward&lt;F&gt;(f), std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);
}</code></pre>
          <p>Equivalent to</p>
          <pre><code>return apply_impl(std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t),
    make_index_sequence&lt;tuple_size_v&lt;decay_t&lt;Tuple&gt;&gt;&gt;{});</code></pre>
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="meta">
    

    <section>
      <header><span class="section-number">3.3</span> <h1 data-bookmark-label="3.3 Metaprogramming and type traits">Metaprogramming and type traits</h1> <span style="float:right"><a href="#meta">[meta]</a></span></header>
      
    

    <cxx-section id="meta.type.synop">
    

    <section>
      <header><span class="section-number">3.3.1</span> <h1 data-bookmark-label="3.3.1 Header &lt;experimental/type_traits&gt; synopsis">Header &lt;experimental/type_traits&gt; synopsis</h1> <span style="float:right"><a href="#meta.type.synop">[meta.type.synop]</a></span></header>
      
      

<pre><code>#include &lt;type_traits&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  // See <cxx-ref in="cxx" to="meta.unary.cat">C++14 <span title="meta.unary.cat">§20.10.4.1</span></cxx-ref>, primary type categories
  template &lt;class T&gt; constexpr bool is_void_v
    = is_void&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_null_pointer_v
    = is_null_pointer&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_integral_v
    = is_integral&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_floating_point_v
    = is_floating_point&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_array_v
    = is_array&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_pointer_v
    = is_pointer&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_lvalue_reference_v
    = is_lvalue_reference&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_rvalue_reference_v
    = is_rvalue_reference&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_member_object_pointer_v
    = is_member_object_pointer&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_member_function_pointer_v
    = is_member_function_pointer&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_enum_v
    = is_enum&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_union_v
    = is_union&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_class_v
    = is_class&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_function_v
    = is_function&lt;T&gt;::value;

  // See <cxx-ref in="cxx" to="meta.unary.comp">C++14 <span title="meta.unary.comp">§20.10.4.2</span></cxx-ref>, composite type categories
  template &lt;class T&gt; constexpr bool is_reference_v
    = is_reference&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_arithmetic_v
    = is_arithmetic&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_fundamental_v
    = is_fundamental&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_object_v
    = is_object&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_scalar_v
    = is_scalar&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_compound_v
    = is_compound&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_member_pointer_v
    = is_member_pointer&lt;T&gt;::value;

  // See <cxx-ref in="cxx" to="meta.unary.prop">C++14 <span title="meta.unary.prop">§20.10.4.3</span></cxx-ref>, type properties
  template &lt;class T&gt; constexpr bool is_const_v
    = is_const&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_volatile_v
    = is_volatile&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivial_v
    = is_trivial&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_copyable_v
    = is_trivially_copyable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_standard_layout_v
    = is_standard_layout&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_pod_v
    = is_pod&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_literal_type_v
    = is_literal_type&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_empty_v
    = is_empty&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_polymorphic_v
    = is_polymorphic&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_abstract_v
    = is_abstract&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_final_v
    = is_final&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_signed_v
    = is_signed&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_unsigned_v
    = is_unsigned&lt;T&gt;::value;
  template &lt;class T, class... Args&gt; constexpr bool is_constructible_v
    = is_constructible&lt;T, Args...&gt;::value;
  template &lt;class T&gt; constexpr bool is_default_constructible_v
    = is_default_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_copy_constructible_v
    = is_copy_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_move_constructible_v
    = is_move_constructible&lt;T&gt;::value;
  template &lt;class T, class U&gt; constexpr bool is_assignable_v
    = is_assignable&lt;T, U&gt;::value;
  template &lt;class T&gt; constexpr bool is_copy_assignable_v
    = is_copy_assignable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_move_assignable_v
    = is_move_assignable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_destructible_v
    = is_destructible&lt;T&gt;::value;
  template &lt;class T, class... Args&gt; constexpr bool is_trivially_constructible_v
    = is_trivially_constructible&lt;T, Args...&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_default_constructible_v
    = is_trivially_default_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_copy_constructible_v
    = is_trivially_copy_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_move_constructible_v
    = is_trivially_move_constructible&lt;T&gt;::value;
  template &lt;class T, class U&gt; constexpr bool is_trivially_assignable_v
    = is_trivially_assignable&lt;T, U&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_copy_assignable_v
    = is_trivially_copy_assignable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_move_assignable_v
    = is_trivially_move_assignable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_destructible_v
    = is_trivially_destructible&lt;T&gt;::value;
  template &lt;class T, class... Args&gt; constexpr bool is_nothrow_constructible_v
    = is_nothrow_constructible&lt;T, Args...&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_default_constructible_v
    = is_nothrow_default_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_copy_constructible_v
    = is_nothrow_copy_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_move_constructible_v
    = is_nothrow_move_constructible&lt;T&gt;::value;
  template &lt;class T, class U&gt; constexpr bool is_nothrow_assignable_v
    = is_nothrow_assignable&lt;T, U&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_copy_assignable_v
    = is_nothrow_copy_assignable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_move_assignable_v
    = is_nothrow_move_assignable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_destructible_v
    = is_nothrow_destructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool has_virtual_destructor_v
    = has_virtual_destructor&lt;T&gt;::value;

  // See <cxx-ref in="cxx" to="meta.unary.prop.query">C++14 <span title="meta.unary.prop.query">§20.10.5</span></cxx-ref>, type property queries
  template &lt;class T&gt; constexpr size_t alignment_of_v
    = alignment_of&lt;T&gt;::value;
  template &lt;class T&gt; constexpr size_t rank_v
    = rank&lt;T&gt;::value;
  template &lt;class T, unsigned I = 0&gt; constexpr size_t extent_v
    = extent&lt;T, I&gt;::value;

  // See <cxx-ref in="cxx" to="meta.rel">C++14 <span title="meta.rel">§20.10.6</span></cxx-ref>, type relations
  template &lt;class T, class U&gt; constexpr bool is_same_v
    = is_same&lt;T, U&gt;::value;
  template &lt;class Base, class Derived&gt; constexpr bool is_base_of_v
    = is_base_of&lt;Base, Derived&gt;::value;
  template &lt;class From, class To&gt; constexpr bool is_convertible_v
    = is_convertible&lt;From, To&gt;::value;

  <cxx-ref insynopsis="" to="meta.trans.other">// <i><a title="meta.trans.other" href="#meta.trans.other">3.3.2</a>, Other type transformations</i></cxx-ref>
  template &lt;class&gt; class invocation_type; // <i>not defined</i>
  template &lt;class F, class... ArgTypes&gt; class invocation_type&lt;F(ArgTypes...)&gt;;
  template &lt;class&gt; class raw_invocation_type; // <i>not defined</i>
  template &lt;class F, class... ArgTypes&gt; class raw_invocation_type&lt;F(ArgTypes...)&gt;;

  template &lt;class T&gt;
    using invocation_type_t = typename invocation_type&lt;T&gt;::type;
  template &lt;class T&gt;
    using raw_invocation_type_t = typename raw_invocation_type&lt;T&gt;::type;

  <cxx-ref insynopsis="" to="meta.logical">// <i><a title="meta.logical" href="#meta.logical">3.3.3</a>, Logical operator traits</i></cxx-ref>
  template&lt;class... B&gt; struct conjunction;
  template&lt;class... B&gt; constexpr bool conjunction_v = conjunction&lt;B...&gt;::value;
  template&lt;class... B&gt; struct disjunction;
  template&lt;class... B&gt; constexpr bool disjunction_v = disjunction&lt;B...&gt;::value;
  template&lt;class B&gt; struct negation;
  template&lt;class B&gt; constexpr bool negation_v = negation&lt;B&gt;::value;

  <cxx-ref insynopsis="" to="meta.detect">// <i><a title="meta.detect" href="#meta.detect">3.3.4</a>, Detection idiom</i></cxx-ref>
  template &lt;class...&gt; using void_t = void;

  struct nonesuch {
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&amp;) = delete;

    void operator=(nonesuch const&amp;) = delete;
  };

  template &lt;template&lt;class...&gt; class Op, class... Args&gt;
    using is_detected = <i>see below</i>;
  template &lt;template&lt;class...&gt; class Op, class... Args&gt;
    constexpr bool is_detected_v = is_detected&lt;Op, Args...&gt;::value;
  template &lt;template&lt;class...&gt; class Op, class... Args&gt;
    using detected_t = <i>see below</i>;
  template &lt;class Default, template&lt;class...&gt; class Op, class... Args&gt;
    using detected_or = <i>see below</i>;
  template &lt;class Default, template&lt;class...&gt; class Op, class... Args&gt;
    using detected_or_t = typename detected_or&lt;Default, Op, Args...&gt;::type;
  template &lt;class Expected, template&lt;class...&gt; class Op, class... Args&gt;
    using is_detected_exact = is_same&lt;Expected, detected_t&lt;Op, Args...&gt;&gt;;
  template &lt;class Expected, template&lt;class...&gt; class Op, class... Args&gt;
    constexpr bool is_detected_exact_v
      = is_detected_exact&lt;Expected, Op, Args...&gt;::value;
  template &lt;class To, template&lt;class...&gt; class Op, class... Args&gt;
    using is_detected_convertible = is_convertible&lt;detected_t&lt;Op, Args...&gt;, To&gt;;
  template &lt;class To, template&lt;class...&gt; class Op, class... Args&gt;
    constexpr bool is_detected_convertible_v
      = is_detected_convertible&lt;To, Op, Args...&gt;::value;

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>

    
    </section>
  </cxx-section>

    <cxx-section id="meta.trans.other">
    

    <section>
      <header><span class="section-number">3.3.2</span> <h1 data-bookmark-label="3.3.2 Other type transformations">Other type transformations</h1> <span style="float:right"><a href="#meta.trans.other">[meta.trans.other]</a></span></header>
      
      

      <p para_num="1" id="meta.trans.other.1">
        This sub-clause contains templates that may be used to transform one type to another following some predefined rule.
      </p>

      <p para_num="2" id="meta.trans.other.2">
        Each of the templates in this subclause shall be a <cxx-term><i>TransformationTrait</i></cxx-term> (<cxx-ref in="cxx" to="meta.rqmts">C++14 <span title="meta.rqmts">§20.10.1</span></cxx-ref>).
      </p>

      <p para_num="3" id="meta.trans.other.3">
        Within this section, define the <dfn>invocation parameters</dfn> of <code><em>INVOKE</em>(f, t1, t2, ..., tN)</code> as follows,
        in which <code>T1</code> is the possibly <var>cv</var>-qualified type of <code>t1</code>
        and <code>U1</code> denotes <code>T1&amp;</code> if <code>t1</code> is an lvalue
        or <code>T1&amp;&amp;</code> if <code>t1</code> is an rvalue:
      </p>
      <ul>
        <li>
          When <code>f</code> is a pointer to a member function of a class <code>T</code>
          the <cxx-term><i>invocation parameters</i></cxx-term> are <code>U1</code> followed by
          the parameters of <code>f</code> matched by <code>t2</code>, ..., <code>tN</code>.
        </li>
        <li>
          When <code>N == 1</code> and <code>f</code> is a pointer to member data of a class <code>T</code>
          the <cxx-term><i>invocation parameter</i></cxx-term> is <code>U1</code>.
        </li>
        <li>
          If <code>f</code> is a class object,
          the <cxx-term><i>invocation parameters</i></cxx-term> are the parameters matching <code>t1</code>, ..., <code>tN</code>
          of the best viable function (<cxx-ref in="cxx" to="over.match.best">C++14 <span title="over.match.best">§13.3.3</span></cxx-ref>)
          for the arguments <code>t1</code>, ..., <code>tN</code>
          among the function call operators of <code>f</code>.
        </li>
        <li>
          In all other cases,
          the <cxx-term><i>invocation parameters</i></cxx-term> are the parameters of <code>f</code>
          matching <code>t1</code>, ... <code>tN</code>.
        </li>
      </ul>
      <p para_num="4" id="meta.trans.other.4">
        In all of the above cases,
        if an argument <code>tI</code> matches the ellipsis in the function's <cxx-term><i>parameter-declaration-clause</i></cxx-term>,
        the corresponding <cxx-term><i>invocation parameter</i></cxx-term> is defined to be
        the result of applying the default argument promotions (<cxx-ref in="cxx" to="expr.call">C++14 <span title="expr.call">§5.2.2</span></cxx-ref>) to <code>tI</code>.
      </p>

      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        Assume <code>S</code> is defined as
        <pre><code>struct S {
  int f(double const &amp;) const;
  void operator()(int, int);
  void operator()(char const *, int i = 2, int j = 3);
  void operator()(...);
};</code></pre>
        <ul>
          <li>The invocation parameters of <code><em>INVOKE</em>(&amp;S::f, S(), 3.5)</code> are <code>(S &amp;&amp;, double const &amp;)</code>.</li>
          <li>The invocation parameters of <code><em>INVOKE</em>(S(), 1, 2)</code> are <code>(int, int)</code>.</li>
          <li>The invocation parameters of <code><em>INVOKE</em>(S(), "abc", 5)</code> are <code>(const char *, int)</code>.
          The defaulted parameter <code>j</code> does not correspond to an argument.</li>
          <li>The invocation parameters of <code><em>INVOKE</em>(S(), locale(), 5)</code> are <code>(locale, int)</code>.
          Arguments corresponding to ellipsis maintain their types.</li>
        </ul>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

      <table is="cxx-table" id="tab:meta.trans.other">
    

    <caption>Table 3 — <wbr><span>Other type transformations</span></caption>
    
        
        <thead>
          <tr><th>Template</th><th>Condition</th><th>Comments</th></tr>
        </thead>
        <tbody><tr>
          <td>
            <code>template &lt;class Fn, class... ArgTypes&gt;<br>
            struct raw_invocation_type&lt;<w-br><wbr></w-br>Fn(ArgTypes...)&gt;;</code>
          </td>
          <td>
            <code>Fn</code> and all types in the parameter pack <code>ArgTypes</code>
            shall be complete types, (possibly cv-qualified) <code>void</code>, or arrays of unknown bound.
          </td>

          <td>
            <em>see below</em>
          </td>
        </tr>
        <tr>
          <td>
            <code>template &lt;class Fn, class... ArgTypes&gt;<br>
            struct invocation_type&lt;<w-br><wbr></w-br>Fn(ArgTypes...)&gt;;</code>
          </td>
          <td>
            <code>Fn</code> and all types in the parameter pack <code>ArgTypes</code>
            shall be complete types, (possibly cv-qualified) <code>void</code>,
            or arrays of unknown bound.
          </td>
          <td>
            <em>see below</em>
          </td>
        </tr>
      </tbody>
  </table>

      <p para_num="5" id="meta.trans.other.5">
        Access checking is performed as if in a context unrelated to <code>Fn</code> and <code>ArgTypes</code>.
        Only the validity of the immediate context of the expression is considered.
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The compilation of the expression can result in side effects
        such as the instantiation of class template specializations and function template specializations,
        the generation of implicitly-defined functions, and so on.
        Such side effects are not in the "immediate context"
        and can result in the program being ill-formed.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>

      <p para_num="6" id="meta.trans.other.6">
        The nested typedef <code>raw_invocation_type&lt;Fn(ArgTypes...)&gt;::type</code> shall be defined as follows.
        If the expression <code><em>INVOKE</em>(declval&lt;Fn&gt;(), declval&lt;ArgTypes&gt;()...)</code>
        is ill-formed when treated as an unevaluated operand (<cxx-ref in="cxx" to="expr">C++14 <span title="expr">§5</span></cxx-ref>),
        there shall be no member <code>type</code>. Otherwise:
      </p>
      <ul>
        <li>Let <code>R</code> denote <code>result_of_t&lt;Fn(ArgTypes...)&gt;</code>.</li>
        <li>Let the types <code>Ti</code> be the <cxx-term><i>invocation parameters</i></cxx-term>
        of <code><em>INVOKE</em>(declval&lt;Fn&gt;(), <nobr>declval&lt;ArgTypes&gt;()...)</nobr></code>.</li>
        <li>Then the member typedef <code>type</code> shall name the function type <code>R(T1, T2, ...)</code>.</li>
      </ul>

      <p para_num="7" id="meta.trans.other.7">
        The nested typedef <code>invocation_type&lt;Fn(ArgTypes...)&gt;::type</code> shall be defined as follows.
        If <code>raw_invocation_type&lt;Fn(ArgTypes...)&gt;::type</code> does not exist, there shall be no member typedef <code>type</code>.
        Otherwise:
      </p>
      <ul>
        <li>Let <code>A1, A2,</code> … denote <code>ArgTypes...</code></li>
        <li>Let <code>R(T1, T2, …)</code> denote <code>raw_invocation_type_t&lt;Fn(ArgTypes...)&gt;</code></li>
        <li>
          Then the member typedef <code>type</code> shall name the function type <code>R(U1, U2, …)</code>
          where <code>Ui</code> is <code>decay_t&lt;Ai&gt;</code> if <code>declval&lt;Ai&gt;()</code> is an rvalue
          otherwise <code>Ti</code>.
        </li>
      </ul>
    
    </section>
  </cxx-section>

    <cxx-section id="meta.logical">
    

    <section>
      <header><span class="section-number">3.3.3</span> <h1 data-bookmark-label="3.3.3 Logical operator traits">Logical operator traits</h1> <span style="float:right"><a href="#meta.logical">[meta.logical]</a></span></header>
      
      
      <p para_num="1" id="meta.logical.1">This subclause describes type traits for applying logical operators to
      other type traits.</p>

      <pre><code>template&lt;class... B&gt; struct conjunction : <i>see below</i> { };</code></pre>

      <p para_num="2" id="meta.logical.2">The class template <code>conjunction</code> forms the logical
      conjunction of its template type arguments. Every template type argument
      shall be usable as a base class and shall have a static data member
      <code>value</code> which is convertible to <code>bool</code>, is not
      hidden, and is unambiguously available in the type.</p>

      <p para_num="3" id="meta.logical.3">The BaseCharacteristic of a specialization <code>conjunction&lt;B1, …, BN&gt;</code>
      is the first type <code>B</code> in the list <code>true_type</code>,
      <code>B1</code>, …, <code>BN</code> for which <code>B::value == false</code>,
      or if every <code>B::value != false</code> the BaseCharacteristic
      is <code>BN</code>. <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    This means a specialization of <code>conjunction</code>
      does not necessarily have a BaseCharacteristic of either <code>true_type</code>
      or <code>false_type</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>

      <p para_num="4" id="meta.logical.4">For a specialization <code>conjunction&lt;B1, …, BN&gt;</code> if
      there is a template type argument <code>B<var>i</var></code> with <code>B<var>i</var>::value == false</code>
      then instantiating <code>conjunction&lt;B1, …, BN&gt;::value</code> does
      not require the instantiation of <code>B<var>j</var>::value</code> for <code><var>j</var></code> &gt; <code><var>i</var></code>.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    This is analogous to the short-circuiting behavior of <code>&amp;&amp;</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>

      <pre><code>template&lt;class... B&gt; struct disjunction : <i>see below</i> { };</code></pre>

      <p para_num="5" id="meta.logical.5">The class template <code>disjunction</code> forms the logical
      disjunction of its template type arguments. Every template type argument
      shall be usable as a base class and shall have a static data member
      <code>value</code> which is convertible to <code>bool</code>, is not
      hidden, and is unambiguously available in the type.</p>

      <p para_num="6" id="meta.logical.6">The BaseCharacteristic of a specialization <code>disjunction&lt;B1, …, BN&gt;</code>
      is the first type <code>B</code> in the list <code>false_type</code>,
      <code>B1</code>, …, <code>BN</code> for which <code>B::value != false</code>,
      or if every <code>B::value == false</code> the BaseCharacteristic
      is <code>BN</code>. <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    This means a specialization of <code>disjunction</code>
      does not necessarily have a BaseCharacteristic of either <code>true_type</code>
      or <code>false_type</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>

      <p para_num="7" id="meta.logical.7">For a specialization <code>disjunction&lt;B1, …, BN&gt;</code> if
      there is a template type argument <code>B<var>i</var></code> with <code>B<var>i</var>::value != false</code>
      then instantiating <code>disjunction&lt;B1, …, BN&gt;::value</code> does
      not require the instantiation of <code>B<var>j</var>::value</code> for <code><var>j</var></code> &gt; <code><var>i</var></code>.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    This is analogous to the short-circuiting behavior of <code>||</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>

      <pre><code>template&lt;class B&gt; struct negation : integral_constant&lt;bool, !B::value&gt; { };</code></pre>

      <p para_num="8" id="meta.logical.8">The class template <code>negation</code> forms the logical negation of
      its template type argument. The type <code>negation&lt;B&gt;</code> is a
      UnaryTypeTrait with a BaseCharacteristic of <code>integral_constant&lt;bool, !B::value&gt;</code>.</p>

    
    </section>
  </cxx-section>

    <cxx-section id="meta.detect">
    

    <section>
      <header><span class="section-number">3.3.4</span> <h1 data-bookmark-label="3.3.4 Detection idiom">Detection idiom</h1> <span style="float:right"><a href="#meta.detect">[meta.detect]</a></span></header>
      
      

      <pre><code>template &lt;class Default, class AlwaysVoid,
          template&lt;class...&gt; class Op, class... Args&gt;
struct DETECTOR { // <i>exposition only</i>
  using value_t = false_type;
  using type = Default;
};

template &lt;class Default, template&lt;class...&gt; class Op, class... Args&gt;
struct DETECTOR&lt;Default, void_t&lt;Op&lt;Args...&gt;&gt;, Op, Args...&gt; { // <i>exposition only</i>
  using value_t = true_type;
  using type = Op&lt;Args...&gt;;
};

template &lt;template&lt;class...&gt; class Op, class... Args&gt;
  using is_detected = typename DETECTOR&lt;nonesuch, void, Op, Args...&gt;::value_t;

template &lt;template&lt;class...&gt; class Op, class... Args&gt;
  using detected_t = typename DETECTOR&lt;nonesuch, void, Op, Args...&gt;::type;

template &lt;class Default, template&lt;class...&gt; class Op, class... Args&gt;
  using detected_or = DETECTOR&lt;Default, void, Op, Args...&gt;;</code></pre>

      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <pre><code>// <i>archetypal helper alias for a copy assignment operation:</i>
template &lt;class T&gt;
  using copy_assign_t = decltype(declval&lt;T&amp;&gt;() = declval&lt;T const &amp;&gt;());

// <i>plausible implementation for the is_assignable type trait:</i>
template &lt;class T&gt;
  using is_copy_assignable = is_detected&lt;copy_assign_t, T&gt;;

// <i>plausible implementation for an augmented is_assignable type trait</i>
// <i>that also checks the return type:</i>
template &lt;class T&gt;
  using is_canonical_copy_assignable = is_detected_exact&lt;T&amp;, copy_assign_t, T&gt;;</code></pre>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <pre><code>// <i>archetypal helper alias for a particular type member:</i>
template &lt;class T&gt;
  using diff_t = typename T::difference_type;

// <i>alias the type member, if it exists, otherwise alias </i>ptrdiff_t<i>:</i>
template &lt;class Ptr&gt;
  using difference_type = detected_or_t&lt;ptrdiff_t, diff_t, Ptr&gt;;</code></pre>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="ratio">
    

    <section>
      <header><span class="section-number">3.4</span> <h1 data-bookmark-label="3.4 Compile-time rational arithmetic">Compile-time rational arithmetic</h1> <span style="float:right"><a href="#ratio">[ratio]</a></span></header>
      
    

    <cxx-section id="header.ratio.synop">
    

    <section>
      <header><span class="section-number">3.4.1</span> <h1 data-bookmark-label="3.4.1 Header &lt;experimental/ratio&gt; synopsis">Header &lt;experimental/ratio&gt; synopsis</h1> <span style="float:right"><a href="#header.ratio.synop">[header.ratio.synop]</a></span></header>
      
      

<pre><code>#include &lt;ratio&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  // See <cxx-ref in="cxx" to="ratio.comparison">C++14 <span title="ratio.comparison">§20.11.5</span></cxx-ref>, ratio comparison
  template &lt;class R1, class R2&gt; constexpr bool ratio_equal_v
    = ratio_equal&lt;R1, R2&gt;::value;
  template &lt;class R1, class R2&gt; constexpr bool ratio_not_equal_v
    = ratio_not_equal&lt;R1, R2&gt;::value;
  template &lt;class R1, class R2&gt; constexpr bool ratio_less_v
    = ratio_less&lt;R1, R2&gt;::value;
  template &lt;class R1, class R2&gt; constexpr bool ratio_less_equal_v
    = ratio_less_equal&lt;R1, R2&gt;::value;
  template &lt;class R1, class R2&gt; constexpr bool ratio_greater_v
    = ratio_greater&lt;R1, R2&gt;::value;
  template &lt;class R1, class R2&gt; constexpr bool ratio_greater_equal_v
    = ratio_greater_equal&lt;R1, R2&gt;::value;

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="time">
    

    <section>
      <header><span class="section-number">3.5</span> <h1 data-bookmark-label="3.5 Time utilities">Time utilities</h1> <span style="float:right"><a href="#time">[time]</a></span></header>
      
    

    <cxx-section id="header.chrono.synop">
    

    <section>
      <header><span class="section-number">3.5.1</span> <h1 data-bookmark-label="3.5.1 Header &lt;experimental/chrono&gt; synopsis">Header &lt;experimental/chrono&gt; synopsis</h1> <span style="float:right"><a href="#header.chrono.synop">[header.chrono.synop]</a></span></header>
      
      

<pre><code>#include &lt;chrono&gt;

namespace std {
namespace chrono {
namespace experimental {
inline namespace fundamentals_v2 {

  // See <cxx-ref in="cxx" to="time.traits">C++14 <span title="time.traits">§20.12.4</span></cxx-ref>, customization traits
  template &lt;class Rep&gt; constexpr bool treat_as_floating_point_v
    = treat_as_floating_point&lt;Rep&gt;::value;

} // namespace fundamentals_v2
} // namespace experimental
} // namespace chrono
} // namespace std</code></pre>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="syserror">
    

    <section>
      <header><span class="section-number">3.6</span> <h1 data-bookmark-label="3.6 System error support">System error support</h1> <span style="float:right"><a href="#syserror">[syserror]</a></span></header>
      
    

    <cxx-section id="header.system_error.synop">
    

    <section>
      <header><span class="section-number">3.6.1</span> <h1 data-bookmark-label="3.6.1 Header &lt;experimental/system_error&gt; synopsis">Header &lt;experimental/system_error&gt; synopsis</h1> <span style="float:right"><a href="#header.system_error.synop">[header.system_error.synop]</a></span></header>
      
      

<pre><code>#include &lt;system_error&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  // See <cxx-ref in="cxx" to="syserr">C++14 <span title="syserr">§19.5</span></cxx-ref>, System error support
  template &lt;class T&gt; constexpr bool is_error_code_enum_v
    = is_error_code_enum&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_error_condition_enum_v
    = is_error_condition_enum&lt;T&gt;::value;

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="propagate_const">
    

    <section>
      <header><span class="section-number">3.7</span> <h1 data-bookmark-label="3.7 Class template propagate_const">Class template <code>propagate_const</code></h1> <span style="float:right"><a href="#propagate_const">[propagate_const]</a></span></header>
      
    

    <cxx-section id="propagate_const.general">
    

    <section>
      <header><span class="section-number">3.7.1</span> <h1 data-bookmark-label="3.7.1 Class template propagate_const general">Class template <code>propagate_const general</code></h1> <span style="float:right"><a href="#propagate_const.general">[propagate_const.general]</a></span></header>
      
      

      <p para_num="1" id="propagate_const.general.1">
        <code>propagate_const</code> is a wrapper around a pointer-like object type <code>T</code>
        which treats the wrapped pointer as a pointer to <code>const</code> when
        the wrapper is accessed through a <code>const</code> access path.
      </p>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.synopsis">
    

    <section>
      <header><span class="section-number">3.7.2</span> <h1 data-bookmark-label="3.7.2 Header &lt;experimental/propagate_const&gt; synopsis">Header <code>&lt;experimental/propagate_const&gt;</code> synopsis</h1> <span style="float:right"><a href="#propagate_const.synopsis">[propagate_const.synopsis]</a></span></header>
      
      

<pre><code>namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {
    template &lt;class T&gt; class propagate_const {
    public:
      typedef remove_reference_t&lt;decltype(*declval&lt;T&amp;&gt;())&gt; element_type;

      <cxx-ref insynopsis="" to="propagate_const.ctor">// <i><a title="propagate_const.ctor" href="#propagate_const.ctor">3.7.4</a>, propagate_const constructors</i></cxx-ref>
      constexpr propagate_const() = default;
      propagate_const(const propagate_const&amp; p) = delete;
      constexpr propagate_const(propagate_const&amp;&amp; p) = default;
      template &lt;class U&gt;
        <i>see below</i> constexpr propagate_const(propagate_const&lt;U&gt;&amp;&amp; pu);
      template &lt;class U&gt;
        <i>see below</i> constexpr propagate_const(U&amp;&amp; u);

      <cxx-ref insynopsis="" to="propagate_const.assignment">// <i><a title="propagate_const.assignment" href="#propagate_const.assignment">3.7.5</a>, propagate_const assignment</i></cxx-ref>
      propagate_const&amp; operator=(const propagate_const&amp; p) = delete;
      constexpr propagate_const&amp; operator=(propagate_const&amp;&amp; p) = default;
      template &lt;class U&gt;
        constexpr propagate_const&amp; operator=(propagate_const&lt;U&gt;&amp;&amp; pu);
      template &lt;class U&gt;
        constexpr propagate_const&amp; operator=(U&amp;&amp; u);

      <cxx-ref insynopsis="" to="propagate_const.const_observers">// <i><a title="propagate_const.const_observers" href="#propagate_const.const_observers">3.7.6</a>, propagate_const const observers</i></cxx-ref>
      explicit constexpr operator bool() const;
      constexpr const element_type* operator-&gt;() const;
      constexpr operator const element_type*() const; // <i>Not always defined</i>
      constexpr const element_type&amp; operator*() const;
      constexpr const element_type* get() const;

      <cxx-ref insynopsis="" to="propagate_const.non_const_observers">// <i><a title="propagate_const.non_const_observers" href="#propagate_const.non_const_observers">3.7.7</a>, propagate_const non-const observers</i></cxx-ref>
      constexpr element_type* operator-&gt;();
      constexpr operator element_type*(); // <i>Not always defined</i>
      constexpr element_type&amp; operator*();
      constexpr element_type* get();

      <cxx-ref insynopsis="" to="propagate_const.modifiers">// <i><a title="propagate_const.modifiers" href="#propagate_const.modifiers">3.7.8</a>, propagate_const modifiers</i></cxx-ref>
      constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);

    private:
      T t_; //<i>exposition only</i>
    };

    <cxx-ref insynopsis="" to="propagate_const.relational">// <i><a title="propagate_const.relational" href="#propagate_const.relational">3.7.9</a>, propagate_const relational operators</i></cxx-ref>
    template &lt;class T&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);
    template &lt;class T&gt;
      constexpr bool operator==(nullptr_t, const propagate_const&lt;T&gt;&amp; pu);

    template &lt;class T&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);
    template &lt;class T&gt;
      constexpr bool operator!=(nullptr_t, const propagate_const&lt;T&gt;&amp; pu);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);

    <cxx-ref insynopsis="" to="propagate_const.algorithms">// <i><a title="propagate_const.algorithms" href="#propagate_const.algorithms">3.7.10</a>, propagate_const specialized algorithms</i></cxx-ref>
    template &lt;class T&gt;
      constexpr void swap(propagate_const&lt;T&gt;&amp; pt, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>);

    <cxx-ref insynopsis="" to="propagate_const.underlying">// <i><a title="propagate_const.underlying" href="#propagate_const.underlying">3.7.11</a>, propagate_const underlying pointer access</i></cxx-ref>
    template &lt;class T&gt;
      constexpr const T&amp; get_underlying(const propagate_const&lt;T&gt;&amp; pt) noexcept;
    template &lt;class T&gt;
      constexpr T&amp; get_underlying(propagate_const&lt;T&gt;&amp; pt) noexcept;
  } // inline namespace fundamentals_v2
  } // namespace experimental

  <cxx-ref insynopsis="" to="propagate_const.hash">// <i><a title="propagate_const.hash" href="#propagate_const.hash">3.7.12</a>, propagate_const hash support</i></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt;
    struct hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;

  <cxx-ref insynopsis="" to="propagate_const.comparison_function_objects">// <i><a title="propagate_const.comparison_function_objects" href="#propagate_const.comparison_function_objects">3.7.13</a>, propagate_const comparison function objects</i></cxx-ref>
  template &lt;class T&gt; struct equal_to;
  template &lt;class T&gt;
    struct equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct not_equal_to;
  template &lt;class T&gt;
    struct not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct less;
  template &lt;class T&gt;
    struct less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct greater;
  template &lt;class T&gt;
    struct greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct less_equal;
  template &lt;class T&gt;
    struct less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct greater_equal;
  template &lt;class T&gt;
    struct greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.requirements">
    

    <section>
      <header><span class="section-number">3.7.3</span> <h1 data-bookmark-label="3.7.3 propagate_const requirements on T"><code>propagate_const</code> requirements on <code>T</code></h1> <span style="float:right"><a href="#propagate_const.requirements">[propagate_const.requirements]</a></span></header>
      
      

      <p para_num="1" id="propagate_const.requirements.1">
        <code>T</code> shall be an object pointer type or a class type for which
        <code>decltype(*declval&lt;T&amp;&gt;())</code> is an lvalue reference; otherwise
        the program is ill-formed.
      </p>
      <p para_num="2" id="propagate_const.requirements.2">
        If <code>T</code> is an array type, reference type, pointer to function type or
        pointer to (possibly cv-qualified) <code>void</code>, then the program is
        ill-formed.
      </p>
      <p para_num="3" id="propagate_const.requirements.3">
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    <code>propagate_const&lt;const int*&gt;</code> is well-formed
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>

      <cxx-section id="propagate_const.class_type_requirements">
    

    <section>
      <header><span class="section-number">3.7.3.1</span> <h1 data-bookmark-label="3.7.3.1 propagate_const requirements on class type T"><code>propagate_const</code> requirements on class type <code>T</code></h1> <span style="float:right"><a href="#propagate_const.class_type_requirements">[propagate_const.class_type_requirements]</a></span></header>
      
        

        <p para_num="1" id="propagate_const.class_type_requirements.1">
          If <code>T</code> is class
          type then it shall satisfy the following requirements. In this sub-clause
          <code>t</code> denotes a non-<code>const</code> lvalue of type <code>T</code>, <code>ct</code>
          is a <code>const T&amp;</code> bound to <code>t</code>,  <code>element_type</code> denotes
          an object type.
        </p>

        <p para_num="2" id="propagate_const.class_type_requirements.2">
          <code>T</code> and <code>const T</code> shall be contextually convertible to <code>bool</code>.
        </p>
        <p para_num="3" id="propagate_const.class_type_requirements.3">If <code>T</code> is implicitly convertible to <code>element_type*</code>,
          <code>(element_type*)t == t.get()</code> shall be <code>true</code>.
        </p>
        <p para_num="4" id="propagate_const.class_type_requirements.4">
          If <code>const T</code> is implicitly convertible to <code>const element_type*</code>,
          <code>(const element_type*)ct == ct.get()</code> shall be <code>true</code>.
        </p>

        <table is="cxx-table">
    

    <caption>Table 4 — <wbr><span>Requirements on class types <code>T</code></span></caption>
    
          
          <tbody><tr>
            <th>Expression</th>
            <th>Return type</th>
            <th>Pre-conditions</th>
            <th>Operational semantics</th>
          </tr>
          <tr>
            <td><code>t.get()</code></td>
            <td><code>element_type*</code></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>ct.get()</code></td>
            <td><code>const element_type*</code> or <code>element_type*</code></td>
            <td><code></code></td>
            <td><code>t.get() == ct.get()</code>.</td>
          </tr>
          <tr>
            <td><code>*t</code></td>
            <td><code>element_type&amp;</code></td>
            <td><code>t.get() != nullptr</code></td>
            <td><code>*t</code> refers to the same object as <code>*(t.get())</code></td>
          </tr>
          <tr>
            <td><code>*ct</code></td>
            <td><code>const element_type&amp;</code> or <code>element_type&amp;</code>
            </td>
            <td><code>ct.get() != nullptr</code></td>
            <td><code>*ct</code> refers to the same object as <code>*(ct.get())</code>
            </td></tr>
          <tr>
            <td><code>t.operator-&gt;()</code></td>
            <td><code>element_type*</code></td>
            <td><code>t.get() != nullptr</code></td>
            <td><code>t.operator-&gt;() == t.get()</code></td></tr>
          <tr>
            <td><code>ct.operator-&gt;()</code></td>
            <td><code>const element_type*</code> or <code>element_type*</code></td>
            <td><code>ct.get() != nullptr</code></td>
            <td><code>ct.operator-&gt;() == ct.get()</code></td></tr>
          <tr>
            <td><code>(bool)t</code></td>
            <td><code>bool</code></td>
            <td><code></code></td>
            <td><code>(bool)t</code> is equivalent to <code>t.get() != nullptr</code></td>
          </tr>
          <tr>
            <td><code>(bool)ct</code></td>
            <td><code>bool</code></td>
            <td><code></code></td>
            <td><code>(bool)ct</code> is equivalent to <code>ct.get() != nullptr</code></td>
          </tr>
        </tbody>
  </table>
      
    </section>
  </cxx-section>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.ctor">
    

    <section>
      <header><span class="section-number">3.7.4</span> <h1 data-bookmark-label="3.7.4 propagate_const constructors"><code>propagate_const</code> constructors</h1> <span style="float:right"><a href="#propagate_const.ctor">[propagate_const.ctor]</a></span></header>
      
      

      <p para_num="1" id="propagate_const.ctor.1">
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The following constructors are conditionally specified as
          <code>explicit</code>.  This is typically implemented by declaring two such
          constructors, of which at most one  participates in overload resolution.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>
      <cxx-function para_num="2" id="propagate_const.ctor.2">
    
    <pre><code><cxx-signature>template &lt;class U&gt;
<i>see below</i> constexpr propagate_const(propagate_const&lt;U&gt;&amp;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-remarks para_num="3" id="propagate_const.ctor.3">
    
    <dt>Remarks:</dt><dd>
          This constructor shall not participate in overload resolution unless
          <code>is_constructible_v&lt;T, U&amp;&amp;&gt;</code>.
          The constructor is specified as <code>explicit</code> if and only if
          <code>!is_convertible_v&lt;U&amp;&amp;, T&gt;.</code>
        </dd>
  </cxx-remarks>
        <cxx-effects para_num="4" id="propagate_const.ctor.4">
    
    <dt>Effects:</dt><dd>
          Initializes <code>t_</code> as if
          direct-non-list-initializing an object of type <code>T</code> with the
          expression <code>std::move(pu.t_)</code>.
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="propagate_const.ctor.5">
    
    <pre><code><cxx-signature>template &lt;class U&gt;
<i>see below</i> constexpr propagate_const(U&amp;&amp; u);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-remarks para_num="6" id="propagate_const.ctor.6">
    
    <dt>Remarks:</dt><dd>
          This constructor shall not participate in overload resolution unless
          <code>is_constructible_v&lt;T, U&amp;&amp;&gt;</code>
          and <code>decay_t&lt;U&gt;</code> is not a specialization of <code>propagate_const</code>.
          The constructor is specified as <code>explicit</code> if and only if
          <code>!is_convertible_v&lt;U&amp;&amp;, T&gt;.</code>
        </dd>
  </cxx-remarks>
        <cxx-effects para_num="7" id="propagate_const.ctor.7">
    
    <dt>Effects:</dt><dd>
          Initializes <code>t_</code> as if
          direct-non-list-initializing an object of type <code>T</code> with
          the expression <code>std::forward&lt;U&gt;(u)</code>.
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.assignment">
    

    <section>
      <header><span class="section-number">3.7.5</span> <h1 data-bookmark-label="3.7.5 propagate_const assignment"><code>propagate_const</code> assignment</h1> <span style="float:right"><a href="#propagate_const.assignment">[propagate_const.assignment]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.assignment.1">
    
    <pre><code><cxx-signature>template &lt;class U&gt;
constexpr propagate_const&amp; operator=(propagate_const&lt;U&gt;&amp;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-remarks para_num="2" id="propagate_const.assignment.2">
    
    <dt>Remarks:</dt><dd>
          This function shall not participate in overload resolution unless
          <code>U</code> is implicitly convertible to <code>T</code>.
        </dd>
  </cxx-remarks>
        <cxx-effects para_num="3" id="propagate_const.assignment.3">
    
    <dt>Effects:</dt><dd><code>t_ = std::move(pu.t_)</code>.</dd>
  </cxx-effects>
        <cxx-returns para_num="4" id="propagate_const.assignment.4">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="propagate_const.assignment.5">
    
    <pre><code><cxx-signature>template &lt;class U&gt;
constexpr propagate_const&amp; operator=(U&amp;&amp; u);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-remarks para_num="6" id="propagate_const.assignment.6">
    
    <dt>Remarks:</dt><dd>
          This function shall not participate in overload resolution unless
          <code>U</code> is implicitly convertible to <code>T</code> and
          <code>decay_t&lt;U&gt;</code> is not a specialization of <code>propagate_const</code>.
        </dd>
  </cxx-remarks>
        <cxx-effects para_num="7" id="propagate_const.assignment.7">
    
    <dt>Effects:</dt><dd><code>t_ = std::forward&lt;U&gt;(u)</code>.</dd>
  </cxx-effects>
        <cxx-returns para_num="8" id="propagate_const.assignment.8">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.const_observers">
    

    <section>
      <header><span class="section-number">3.7.6</span> <h1 data-bookmark-label="3.7.6 propagate_const const observers"><code>propagate_const</code> const observers</h1> <span style="float:right"><a href="#propagate_const.const_observers">[propagate_const.const_observers]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.const_observers.1">
    
    <pre><code><cxx-signature>explicit constexpr operator bool() const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="propagate_const.const_observers.2">
    
    <dt>Returns:</dt><dd><code>(bool)t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="propagate_const.const_observers.3">
    
    <pre><code><cxx-signature>constexpr const element_type* operator-&gt;() const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="4" id="propagate_const.const_observers.4">
    
    <dt>Requires:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-requires>
        <cxx-returns para_num="5" id="propagate_const.const_observers.5">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="propagate_const.const_observers.6">
    
    <pre><code><cxx-signature>constexpr operator const element_type*() const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="7" id="propagate_const.const_observers.7">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="8" id="propagate_const.const_observers.8">
    
    <dt>Remarks:</dt><dd>
          This function shall not participate in overload resolution unless
          <code>T</code> is an object pointer type or
          has an implicit conversion to <code>const element_type*</code>.
        </dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="propagate_const.const_observers.9">
    
    <pre><code><cxx-signature>constexpr const element_type&amp; operator*() const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="10" id="propagate_const.const_observers.10">
    
    <dt>Requires:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-requires>
        <cxx-returns para_num="11" id="propagate_const.const_observers.11">
    
    <dt>Returns:</dt><dd><code>*get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="12" id="propagate_const.const_observers.12">
    
    <pre><code><cxx-signature>constexpr const element_type* get() const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="13" id="propagate_const.const_observers.13">
    
    <dt>Returns:</dt><dd>
          <code>t_</code> if <code>T</code> is an object pointer type,
          otherwise <code>t_.get()</code>.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.non_const_observers">
    

    <section>
      <header><span class="section-number">3.7.7</span> <h1 data-bookmark-label="3.7.7 propagate_const non-const observers"><code>propagate_const</code> non-const observers</h1> <span style="float:right"><a href="#propagate_const.non_const_observers">[propagate_const.non_const_observers]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.non_const_observers.1">
    
    <pre><code><cxx-signature>constexpr element_type* operator-&gt;();</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="propagate_const.non_const_observers.2">
    
    <dt>Requires:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-requires>
        <cxx-returns para_num="3" id="propagate_const.non_const_observers.3">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="propagate_const.non_const_observers.4">
    
    <pre><code><cxx-signature>constexpr operator element_type*();</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="5" id="propagate_const.non_const_observers.5">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="6" id="propagate_const.non_const_observers.6">
    
    <dt>Remarks:</dt><dd>
          This function shall not participate in overload resolution unless
          <code>T</code> is an object pointer type or
          has an implicit conversion to <code>element_type*</code>.
        </dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="propagate_const.non_const_observers.7">
    
    <pre><code><cxx-signature>constexpr element_type&amp; operator*();</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="8" id="propagate_const.non_const_observers.8">
    
    <dt>Requires:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-requires>
        <cxx-returns para_num="9" id="propagate_const.non_const_observers.9">
    
    <dt>Returns:</dt><dd><code>*get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="10" id="propagate_const.non_const_observers.10">
    
    <pre><code><cxx-signature>constexpr element_type* get();</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="11" id="propagate_const.non_const_observers.11">
    
    <dt>Returns:</dt><dd>
          <code>t_</code> if <code>T</code> is an object pointer type,
          otherwise <code>t_.get()</code>.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.modifiers">
    

    <section>
      <header><span class="section-number">3.7.8</span> <h1 data-bookmark-label="3.7.8 propagate_const modifiers"><code>propagate_const</code> modifiers</h1> <span style="float:right"><a href="#propagate_const.modifiers">[propagate_const.modifiers]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.modifiers.1">
    
    <pre><code><cxx-signature>constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="propagate_const.modifiers.2">
          The constant-expression in the exception-specification is <code>noexcept(swap(t_, pt.t_))</code>.
        </p>

        <cxx-effects para_num="3" id="propagate_const.modifiers.3">
    
    <dt>Effects:</dt><dd><code>swap(t_, pt.t_)</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.relational">
    

    <section>
      <header><span class="section-number">3.7.9</span> <h1 data-bookmark-label="3.7.9 propagate_const relational operators"><code>propagate_const</code> relational operators</h1> <span style="float:right"><a href="#propagate_const.relational">[propagate_const.relational]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.relational.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="propagate_const.relational.2">
    
    <dt>Returns:</dt><dd><code>pt.t_ == nullptr</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="propagate_const.relational.3">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr bool operator==(nullptr_t, const propagate_const&lt;T&gt;&amp; pt);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="4" id="propagate_const.relational.4">
    
    <dt>Returns:</dt><dd><code>nullptr == pt.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="propagate_const.relational.5">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="6" id="propagate_const.relational.6">
    
    <dt>Returns:</dt><dd><code>pt.t_ != nullptr</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="propagate_const.relational.7">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr bool operator!=(nullptr_t, const propagate_const&lt;T&gt;&amp; pt);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="8" id="propagate_const.relational.8">
    
    <dt>Returns:</dt><dd><code>nullptr != pt.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="propagate_const.relational.9">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="10" id="propagate_const.relational.10">
    
    <dt>Returns:</dt><dd><code>pt.t_ == pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="11" id="propagate_const.relational.11">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="12" id="propagate_const.relational.12">
    
    <dt>Returns:</dt><dd><code>pt.t_ != pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="13" id="propagate_const.relational.13">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="14" id="propagate_const.relational.14">
    
    <dt>Returns:</dt><dd><code>pt.t_ &lt; pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="15" id="propagate_const.relational.15">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="16" id="propagate_const.relational.16">
    
    <dt>Returns:</dt><dd><code>pt.t_ &gt; pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="17" id="propagate_const.relational.17">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="18" id="propagate_const.relational.18">
    
    <dt>Returns:</dt><dd><code>pt.t_ &lt;= pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="19" id="propagate_const.relational.19">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="20" id="propagate_const.relational.20">
    
    <dt>Returns:</dt><dd><code>pt.t_ &gt;= pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="21" id="propagate_const.relational.21">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="22" id="propagate_const.relational.22">
    
    <dt>Returns:</dt><dd><code>pt.t_ == u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="23" id="propagate_const.relational.23">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="24" id="propagate_const.relational.24">
    
    <dt>Returns:</dt><dd><code>pt.t_ != u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="25" id="propagate_const.relational.25">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="26" id="propagate_const.relational.26">
    
    <dt>Returns:</dt><dd><code>pt.t_ &lt; u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="27" id="propagate_const.relational.27">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="28" id="propagate_const.relational.28">
    
    <dt>Returns:</dt><dd><code>pt.t_ &gt; u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="29" id="propagate_const.relational.29">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="30" id="propagate_const.relational.30">
    
    <dt>Returns:</dt><dd><code>pt.t_ &lt;= u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="31" id="propagate_const.relational.31">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="32" id="propagate_const.relational.32">
    
    <dt>Returns:</dt><dd><code>pt.t_ &gt;= u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="33" id="propagate_const.relational.33">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="34" id="propagate_const.relational.34">
    
    <dt>Returns:</dt><dd><code>t == pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="35" id="propagate_const.relational.35">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="36" id="propagate_const.relational.36">
    
    <dt>Returns:</dt><dd><code>t != pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="37" id="propagate_const.relational.37">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="38" id="propagate_const.relational.38">
    
    <dt>Returns:</dt><dd><code>t &lt; pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="39" id="propagate_const.relational.39">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="40" id="propagate_const.relational.40">
    
    <dt>Returns:</dt><dd><code>t &gt; pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="41" id="propagate_const.relational.41">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="42" id="propagate_const.relational.42">
    
    <dt>Returns:</dt><dd><code>t &lt;= pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="43" id="propagate_const.relational.43">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="44" id="propagate_const.relational.44">
    
    <dt>Returns:</dt><dd><code>t &gt;= pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
    <cxx-section id="propagate_const.algorithms">
    

    <section>
      <header><span class="section-number">3.7.10</span> <h1 data-bookmark-label="3.7.10 propagate_const specialized algorithms"><code>propagate_const</code> specialized algorithms</h1> <span style="float:right"><a href="#propagate_const.algorithms">[propagate_const.algorithms]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.algorithms.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr void swap(propagate_const&lt;T&gt;&amp; pt1, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>);</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="propagate_const.algorithms.2">
          The constant-expression in the exception-specification is <code>noexcept(swap(pt1.t_, pt2.t_))</code>.
        </p>

        <cxx-effects para_num="3" id="propagate_const.algorithms.3">
    
    <dt>Effects:</dt><dd><code>swap(pt1.t_, pt2.t_)</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.underlying">
    

    <section>
      <header><span class="section-number">3.7.11</span> <h1 data-bookmark-label="3.7.11 propagate_const underlying pointer access"><code>propagate_const</code> underlying pointer access</h1> <span style="float:right"><a href="#propagate_const.underlying">[propagate_const.underlying]</a></span></header>
      
      

      <p para_num="1" id="propagate_const.underlying.1">
        Access to the underlying object pointer type is
        through free functions rather than member functions.
        These functions are intended to resemble cast operations to encourage caution when using them.
      </p>

      <cxx-function para_num="2" id="propagate_const.underlying.2">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr const T&amp; get_underlying(const propagate_const&lt;T&gt;&amp; pt) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="3" id="propagate_const.underlying.3">
    
    <dt>Returns:</dt><dd>
          a reference to the underlying object pointer type.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="propagate_const.underlying.4">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr T&amp; get_underlying(propagate_const&lt;T&gt;&amp; pt) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="5" id="propagate_const.underlying.5">
    
    <dt>Returns:</dt><dd>
          a reference to the underlying object pointer type.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.hash">
    

    <section>
      <header><span class="section-number">3.7.12</span> <h1 data-bookmark-label="3.7.12 propagate_const hash support"><code>propagate_const</code> hash support</h1> <span style="float:right"><a href="#propagate_const.hash">[propagate_const.hash]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.hash.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="propagate_const.hash.2">
          For an object <code>p</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p)</code>
          shall evaluate to the same value as <code>hash&lt;T&gt;()(p.t_)</code>.
        </p>

        <cxx-requires para_num="3" id="propagate_const.hash.3">
    
    <dt>Requires:</dt><dd>
          The specialization <code>hash&lt;T&gt;</code> shall be well-formed and well-defined,
          and shall meet the requirements of class template hash.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.comparison_function_objects">
    

    <section>
      <header><span class="section-number">3.7.13</span> <h1 data-bookmark-label="3.7.13 propagate_const comparison function objects"><code>propagate_const</code> comparison function objects</h1> <span style="float:right"><a href="#propagate_const.comparison_function_objects">[propagate_const.comparison_function_objects]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.comparison_function_objects.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="propagate_const.comparison_function_objects.2">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>equal_to&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires para_num="3" id="propagate_const.comparison_function_objects.3">
    
    <dt>Requires:</dt><dd>
          The specialization <code>equal_to&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="propagate_const.comparison_function_objects.4">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="5" id="propagate_const.comparison_function_objects.5">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p, q)</code>
          shall evaluate to the same value as <code>not_equal_to&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-requires para_num="6" id="propagate_const.comparison_function_objects.6">
    
    <dt>Requires:</dt><dd>
          The specialization <code>not_equal_to&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="propagate_const.comparison_function_objects.7">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="8" id="propagate_const.comparison_function_objects.8">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>less&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires para_num="9" id="propagate_const.comparison_function_objects.9">
    
    <dt>Requires:</dt><dd>
          The specialization <code>less&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="10" id="propagate_const.comparison_function_objects.10">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="11" id="propagate_const.comparison_function_objects.11">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>greater&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires para_num="12" id="propagate_const.comparison_function_objects.12">
    
    <dt>Requires:</dt><dd>
          The specialization <code>greater&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="13" id="propagate_const.comparison_function_objects.13">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="14" id="propagate_const.comparison_function_objects.14">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>less_equal&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires para_num="15" id="propagate_const.comparison_function_objects.15">
    
    <dt>Requires:</dt><dd>
          The specialization <code>less_equal&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="16" id="propagate_const.comparison_function_objects.16">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="17" id="propagate_const.comparison_function_objects.17">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>greater_equal&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-requires para_num="18" id="propagate_const.comparison_function_objects.18">
    
    <dt>Requires:</dt><dd>
          The specialization <code>greater_equal&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="func">
    

    <section>
      <header><span class="section-number">4</span> <h1 data-bookmark-label="4 Function objects">Function objects</h1> <span style="float:right"><a href="#func">[func]</a></span></header>
      
  

  <cxx-section id="header.functional.synop">
    

    <section>
      <header><span class="section-number">4.1</span> <h1 data-bookmark-label="4.1 Header &lt;experimental/functional&gt; synopsis">Header <code>&lt;experimental/functional&gt;</code> synopsis</h1> <span style="float:right"><a href="#header.functional.synop">[header.functional.synop]</a></span></header>
      
    

    

<pre><code>#include &lt;functional&gt;

namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    // See <cxx-ref in="cxx" to="bind">C++14 <span title="bind">§20.9.9</span></cxx-ref>, Function object binders
    template &lt;class T&gt; constexpr bool is_bind_expression_v
      = is_bind_expression&lt;T&gt;::value;
    template &lt;class T&gt; constexpr int is_placeholder_v
      = is_placeholder&lt;T&gt;::value;

    <cxx-ref insynopsis="" to="func.wrap.func">// <i><a title="func.wrap.func" href="#func.wrap.func">4.2</a>, Class template function</i></cxx-ref>
    template&lt;class&gt; class function; <i>// undefined</i>
    template&lt;class R, class... ArgTypes&gt; class function&lt;R(ArgTypes...)&gt;;

    template&lt;class R, class... ArgTypes&gt;
    void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);

    template&lt;class R, class... ArgTypes&gt;
    bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;
    template&lt;class R, class... ArgTypes&gt;
    bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;
    template&lt;class R, class... ArgTypes&gt;
    bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;
    template&lt;class R, class... ArgTypes&gt;
    bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

    <cxx-ref insynopsis="" to="func.searchers">// <i><a title="func.searchers" href="#func.searchers">4.3</a>, Searchers</i></cxx-ref>
    template&lt;class ForwardIterator, class BinaryPredicate = equal_to&lt;&gt;&gt;
      class default_searcher;

    template&lt;class RandomAccessIterator,
             class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
             class BinaryPredicate = equal_to&lt;&gt;&gt;
      class boyer_moore_searcher;

    template&lt;class RandomAccessIterator,
             class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
             class BinaryPredicate = equal_to&lt;&gt;&gt;
      class boyer_moore_horspool_searcher;


    template&lt;class ForwardIterator, class BinaryPredicate = equal_to&lt;&gt;&gt;
    default_searcher&lt;ForwardIterator, BinaryPredicate&gt;
    make_default_searcher(ForwardIterator pat_first, ForwardIterator pat_last,
                          BinaryPredicate pred = BinaryPredicate());

    template&lt;class RandomAccessIterator,
             class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
             class BinaryPredicate = equal_to&lt;&gt;&gt;
    boyer_moore_searcher&lt;RandomAccessIterator, Hash, BinaryPredicate&gt;
    make_boyer_moore_searcher(
        RandomAccessIterator pat_first, RandomAccessIterator pat_last,
        Hash hf = Hash(), BinaryPredicate pred = BinaryPredicate());

    template&lt;class RandomAccessIterator,
             class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
             class BinaryPredicate = equal_to&lt;&gt;&gt;
    boyer_moore_horspool_searcher&lt;RandomAccessIterator, Hash, BinaryPredicate&gt;
    make_boyer_moore_horspool_searcher(
        RandomAccessIterator pat_first, RandomAccessIterator pat_last,
        Hash hf = Hash(), BinaryPredicate pred = BinaryPredicate());

    <cxx-ref insynopsis="" to="func.not_fn">// <i><a title="func.not_fn" href="#func.not_fn">4.4</a>, Function template not_fn</i></cxx-ref>
    template &lt;class F&gt; unspecified not_fn(F&amp;&amp; f);

  } // namespace fundamentals_v2
  } // namespace experimental

  template&lt;class R, class... ArgTypes, class Alloc&gt;
  struct uses_allocator&lt;experimental::function&lt;R(ArgTypes...)&gt;, Alloc&gt;;

} // namespace std</code></pre>

  
    </section>
  </cxx-section>

  <cxx-section id="func.wrap.func">
    

    <section>
      <header><span class="section-number">4.2</span> <h1 data-bookmark-label="4.2 Class template function">Class template <code>function</code></h1> <span style="float:right"><a href="#func.wrap.func">[func.wrap.func]</a></span></header>
      
    

    

    <p para_num="1" id="func.wrap.func.1">
      The specification of all declarations within this sub-clause <cxx-ref to="func.wrap.func"><a title="func.wrap.func" href="#func.wrap.func">4.2</a></cxx-ref>
      and its sub-clauses are the same as the corresponding declarations, as specified in <cxx-ref in="cxx" to="func.wrap.func">C++14 <span title="func.wrap.func">§20.9.11.2</span></cxx-ref>,
      unless explicitly specified otherwise. <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    <code>std::experimental::function</code> uses
      <code>std::bad_function_call</code>, there is no additional type <code>std::experimental::bad_function_call</code>
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>.
    </p>

<pre><code>namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    template&lt;class&gt; class function; <i>// undefined</i>

    template&lt;class R, class... ArgTypes&gt;
    class function&lt;R(ArgTypes...)&gt; {
    public:
      typedef R result_type;
      typedef T1 argument_type;
      typedef T1 first_argument_type;
      typedef T2 second_argument_type;

      typedef erased_type allocator_type;

      function() noexcept;
      function(nullptr_t) noexcept;
      function(const function&amp;);
      function(function&amp;&amp;);
      template&lt;class F&gt; function(F);
      template&lt;class A&gt; function(allocator_arg_t, const A&amp;) noexcept;
      template&lt;class A&gt; function(allocator_arg_t, const A&amp;,
        nullptr_t) noexcept;
      template&lt;class A&gt; function(allocator_arg_t, const A&amp;,
        const function&amp;);
      template&lt;class A&gt; function(allocator_arg_t, const A&amp;,
        function&amp;&amp;);
      template&lt;class F, class A&gt; function(allocator_arg_t, const A&amp;, F);

      function&amp; operator=(const function&amp;);
      function&amp; operator=(function&amp;&amp;);
      function&amp; operator=(nullptr_t) noexcept;
      template&lt;class F&gt; function&amp; operator=(F&amp;&amp;);
      template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt;);

      ~function();

      void swap(function&amp;);
      template&lt;class F, class A&gt; void assign(F&amp;&amp;, const A&amp;);

      explicit operator bool() const noexcept;

      R operator()(ArgTypes...) const;

      const type_info&amp; target_type() const noexcept;
      template&lt;class T&gt; T* target() noexcept;
      template&lt;class T&gt; const T* target() const noexcept;

      pmr::memory_resource* get_memory_resource();
    };

    template &lt;class R, class... ArgTypes&gt;
    bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;
    template &lt;class R, class... ArgTypes&gt;
    bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

    template &lt;class R, class... ArgTypes&gt;
    bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;
    template &lt;class R, class... ArgTypes&gt;
    bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

    template &lt;class R, class... ArgTypes&gt;
    void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);

  } // namespace fundamentals_v2
  } // namespace experimental

  template &lt;class R, class... ArgTypes, class Alloc&gt;
  struct uses_allocator&lt;experimental::function&lt;R(ArgTypes...)&gt;, Alloc&gt;
    : true_type { };

} // namespace std</code></pre>

    <cxx-section id="func.wrap.func.con">
    

    <section>
      <header><span class="section-number">4.2.1</span> <h1 data-bookmark-label="4.2.1 function construct/copy/destroy"><code>function</code> construct/copy/destroy</h1> <span style="float:right"><a href="#func.wrap.func.con">[func.wrap.func.con]</a></span></header>
      
      

      

      <p para_num="1" id="func.wrap.func.con.1">
        When a <code>function</code> constructor that takes a first argument of type <code>allocator_arg_t</code> is invoked,
        the second argument is treated as a <cxx-term><i>type-erased allocator</i></cxx-term> (<cxx-ref to="memory.type.erased.allocator"><a title="memory.type.erased.allocator" href="#memory.type.erased.allocator">8.3</a></cxx-ref>).
        If the constructor moves or makes a copy
        of a function object (<cxx-ref in="cxx" to="function.objects">C++14 <span title="function.objects">§20.9</span></cxx-ref>),
        including an instance of the <code>experimental::function</code> class template,
        then that move or copy is performed by <cxx-term><i>using-allocator construction</i></cxx-term> with allocator <code>get_memory_resource()</code>.
      </p>

      <p para_num="2" id="func.wrap.func.con.2">
        In the following descriptions, let <code><em>ALLOCATOR_OF</em>(f)</code> be the allocator specified in the construction of <code>function</code> <code>f</code>,
        or <code>allocator&lt;char&gt;()</code> if no allocator was specified.
      </p>

      <cxx-function para_num="3" id="func.wrap.func.con.3">
    
    <pre><code><cxx-signature>function&amp; operator=(const function&amp; f);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="4" id="func.wrap.func.con.4">
    
    <dt>Effects:</dt><dd><code>function(allocator_arg, <em>ALLOCATOR_OF</em>(*this), f).swap(*this);</code></dd>
  </cxx-effects>
        <cxx-returns para_num="5" id="func.wrap.func.con.5">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="func.wrap.func.con.6">
    
    <pre><code><cxx-signature>function&amp; operator=(function&amp;&amp; f);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="7" id="func.wrap.func.con.7">
    
    <dt>Effects:</dt><dd><code>function(allocator_arg, <em>ALLOCATOR_OF</em>(*this), std::move(f)).swap(*this);</code></dd>
  </cxx-effects>
        <cxx-returns para_num="8" id="func.wrap.func.con.8">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      

      <cxx-function para_num="9" id="func.wrap.func.con.9">
    
    <pre><code><cxx-signature>function&amp; operator=(nullptr_t) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="10" id="func.wrap.func.con.10">
    
    <dt>Effects:</dt><dd>If <code>*this != nullptr</code>, destroys the target of <code>this</code>.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="11" id="func.wrap.func.con.11">
    
    <dt>Postconditions:</dt><dd><code>!(*this)</code>.
        The memory resource returned by <code>get_memory_resource()</code> after the assignment is equivalent to the memory resource before the assignment.
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    the address returned by <code>get_memory_resource()</code> might change
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></dd>
  </cxx-postconditions>
        <cxx-returns para_num="12" id="func.wrap.func.con.12">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="13" id="func.wrap.func.con.13">
    
    <pre><code><cxx-signature>template&lt;class F&gt; function&amp; operator=(F&amp;&amp; f);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="14" id="func.wrap.func.con.14">
    
    <dt>Effects:</dt><dd><code>function(allocator_arg, <em>ALLOCATOR_OF</em>(*this), std::forward&lt;F&gt;(f)).swap(*this);</code></dd>
  </cxx-effects>
        <cxx-returns para_num="15" id="func.wrap.func.con.15">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="16" id="func.wrap.func.con.16">
    
    <pre><code><cxx-signature>template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt; f);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="17" id="func.wrap.func.con.17">
    
    <dt>Effects:</dt><dd><code>function(allocator_arg, <em>ALLOCATOR_OF</em>(*this), f).swap(*this);</code></dd>
  </cxx-effects>
        <cxx-returns para_num="18" id="func.wrap.func.con.18">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="func.wrap.func.mod">
    

    <section>
      <header><span class="section-number">4.2.2</span> <h1 data-bookmark-label="4.2.2 function modifiers"><code>function</code> modifiers</h1> <span style="float:right"><a href="#func.wrap.func.mod">[func.wrap.func.mod]</a></span></header>
      
      

      <cxx-function para_num="1" id="func.wrap.func.mod.1">
    
    <pre><code><cxx-signature>void swap(function&amp; other);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="func.wrap.func.mod.2">
    
    <dt>Requires:</dt><dd><code>*this-&gt;get_memory_resource() == *other.get_memory_resource()</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="3" id="func.wrap.func.mod.3">
    
    <dt>Effects:</dt><dd>Interchanges the targets of <code>*this</code> and <code>other</code>.</dd>
  </cxx-effects>
        <cxx-remarks para_num="4" id="func.wrap.func.mod.4">
    
    <dt>Remarks:</dt><dd>The allocators of <code>*this</code> and <code>other</code> are not interchanged.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="func.searchers">
    

    <section>
      <header><span class="section-number">4.3</span> <h1 data-bookmark-label="4.3 Searchers">Searchers</h1> <span style="float:right"><a href="#func.searchers">[func.searchers]</a></span></header>
      
    

    <p para_num="1" id="func.searchers.1">
      This sub-clause provides function object types (<cxx-ref in="cxx" to="function.objects">C++14 <span title="function.objects">§20.9</span></cxx-ref>) for operations
      that search for a sequence <cxx-range begin="pat_first" end="pat_last">[<code>pat_first</code>, <code>pat_last</code>)</cxx-range> in another sequence <cxx-range begin="first" end="last">[<code>first</code>, <code>last</code>)</cxx-range>
      that is provided to the object's function call operator.
      The first sequence (the pattern to be searched for) is provided to the object's constructor,
      and the second (the sequence to be searched) is provided to the function call operator.
    </p>

    <p para_num="2" id="func.searchers.2">
      Each specialization of a class template specified in this sub-clause <cxx-ref to="func.searchers"><a title="func.searchers" href="#func.searchers">4.3</a></cxx-ref> shall meet the <code>CopyConstructible</code> and <code>CopyAssignable</code> requirements.
      Template parameters named <code>ForwardIterator</code>, <code>ForwardIterator1</code>, <code>ForwardIterator2</code>, <code>RandomAccessIterator</code>, <code>RandomAccessIterator1</code>, <code>RandomAccessIterator2</code>, and <code>BinaryPredicate</code> of templates specified in this sub-clause <cxx-ref to="func.searchers"><a title="func.searchers" href="#func.searchers">4.3</a></cxx-ref> shall meet the same requirements and semantics as specified in <cxx-ref in="cxx" to="algorithms.general">C++14 <span title="algorithms.general">§25.1</span></cxx-ref>.
      Template parameters named <code>Hash</code> shall meet the requirements as specified in <cxx-ref in="cxx" to="hash.requirements">C++14 <span title="hash.requirements">§17.6.3.4</span></cxx-ref>.
    </p>

    <p para_num="3" id="func.searchers.3">
      The Boyer-Moore searcher implements the Boyer-Moore search algorithm.
      The Boyer-Moore-Horspool searcher implements the Boyer-Moore-Horspool search algorithm.
      In general, the Boyer-Moore searcher will use more memory and give better run-time performance than Boyer-Moore-Horspool
    </p>

    <cxx-section id="func.searchers.default">
    

    <section>
      <header><span class="section-number">4.3.1</span> <h1 data-bookmark-label="4.3.1 Class template default_searcher">Class template <code>default_searcher</code></h1> <span style="float:right"><a href="#func.searchers.default">[func.searchers.default]</a></span></header>
      
      

      <pre><code>template&lt;class ForwardIterator1, class BinaryPredicate = equal_to&lt;&gt;&gt;
class default_searcher {
public:
  default_searcher(ForwardIterator1 pat_first, ForwardIterator1 pat_last,
                   BinaryPredicate pred = BinaryPredicate());

  template&lt;class ForwardIterator2&gt;
  ForwardIterator2
  operator()(ForwardIterator2 first, ForwardIterator2 last) const;

private:
  ForwardIterator1 pat_first_; <i>// exposition only</i>
  ForwardIterator1 pat_last_;  <i>// exposition only</i>
  BinaryPredicate  pred_;      <i>// exposition only</i>
};
</code></pre>

      <cxx-function para_num="1" id="func.searchers.default.1">
    
    <pre><code><cxx-signature>default_searcher(ForwardIterator pat_first, ForwardIterator pat_last,
BinaryPredicate pred = BinaryPredicate());</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="func.searchers.default.2">
    
    <dt>Effects:</dt><dd>Constructs a <code>default_searcher</code> object, initializing <code>pat_first_</code> with <code>pat_first</code>, <code>pat_last_</code> with <code>pat_last</code>, and <code>pred_</code> with <code>pred</code>.</dd>
  </cxx-effects>
        <cxx-throws para_num="3" id="func.searchers.default.3">
    
    <dt>Throws:</dt><dd>Any exception thrown by the copy constructor of <code>BinaryPredicate</code> or <code>ForwardIterator1</code>.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="func.searchers.default.4">
    
    <pre><code><cxx-signature>template&lt;class ForwardIterator2&gt;
ForwardIterator2 operator()(ForwardIterator2 first, ForwardIterator2 last) const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="5" id="func.searchers.default.5">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return std::search(<w-br><wbr></w-br>first, last, pat_first_, pat_last_, pred_);</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-section id="func.searchers.default.creation">
    

    <section>
      <header><span class="section-number">4.3.1.1</span> <h1 data-bookmark-label="4.3.1.1 default_searcher creation functions"><code>default_searcher</code> creation functions</h1> <span style="float:right"><a href="#func.searchers.default.creation">[func.searchers.default.creation]</a></span></header>
      
        

        <cxx-function para_num="1" id="func.searchers.default.creation.1">
    
    <pre><code><cxx-signature>template&lt;class ForwardIterator, class BinaryPredicate = equal_to&lt;&gt;&gt;
default_searcher&lt;ForwardIterator, BinaryPredicate&gt;
make_default_searcher(ForwardIterator pat_first, ForwardIterator pat_last,
                      BinaryPredicate pred = BinaryPredicate());</cxx-signature></code></pre>

    <dl>
      
          

          <cxx-effects para_num="2" id="func.searchers.default.creation.2">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return default_searcher&lt;ForwardIterator, BinaryPredicate&gt;(<w-br><wbr></w-br>pat_first, pat_last, pred);</code></dd>
  </cxx-effects>
        
    </dl>
  </cxx-function>
      
    </section>
  </cxx-section>
    
    </section>
  </cxx-section>

    <cxx-section id="func.searchers.boyer_moore">
    

    <section>
      <header><span class="section-number">4.3.2</span> <h1 data-bookmark-label="4.3.2 Class template boyer_moore_searcher">Class template <code>boyer_moore_searcher</code></h1> <span style="float:right"><a href="#func.searchers.boyer_moore">[func.searchers.boyer_moore]</a></span></header>
      
      

<pre><code>template&lt;class RandomAccessIterator1,
         class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator1&gt;::value_type&gt;,
         class BinaryPredicate = equal_to&lt;&gt;&gt;
class boyer_moore_searcher {
public:
  boyer_moore_searcher(RandomAccessIterator1 pat_first, RandomAccessIterator1 pat_last,
                       Hash hf = Hash(), BinaryPredicate pred = BinaryPredicate());

  template&lt;class RandomAccessIterator2&gt;
  RandomAccessIterator2
  operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;

private:
  RandomAccessIterator1 pat_first_; <i>// exposition only</i>
  RandomAccessIterator1 pat_last_;  <i>// exposition only</i>
  Hash                  hash_;      <i>// exposition only</i>
  BinaryPredicate       pred_;      <i>// exposition only</i>
};
</code></pre>

      <cxx-function para_num="1" id="func.searchers.boyer_moore.1">
    
    <pre><code><cxx-signature>boyer_moore_searcher(RandomAccessIterator1 pat_first, RandomAccessIterator1 pat_last,
Hash hf = Hash(),
BinaryPredicate pred = BinaryPredicate());</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="func.searchers.boyer_moore.2">
    
    <dt>Requires:</dt><dd>The value type of <code>RandomAccessIterator1</code> shall meet the <code>DefaultConstructible</code>, <code>CopyConstructible</code>, and <code>CopyAssignable</code> requirements.</dd>
  </cxx-requires>
        <cxx-requires para_num="3" id="func.searchers.boyer_moore.3">
    
    <dt>Requires:</dt><dd>For any two values <code>A</code> and <code>B</code> of the type <code>iterator_traits&lt;RandomAccessIterator1&gt;::value_type</code>, if <code>pred(A,B)==true</code>, then <code>hf(A)==hf(B)</code> shall be true.</dd>
  </cxx-requires>
        <cxx-effects para_num="4" id="func.searchers.boyer_moore.4">
    
    <dt>Effects:</dt><dd>Constructs a <code>boyer_moore_searcher</code> object, initializing <code>pat_first_</code> with <code>pat_first</code>, <code>pat_last_</code> with <code>pat_last</code>, <code>hash_</code> with <code>hf</code>, and <code>pred_</code> with <code>pred</code>.</dd>
  </cxx-effects>
        <cxx-throws para_num="5" id="func.searchers.boyer_moore.5">
    
    <dt>Throws:</dt><dd>Any exception thrown by the copy constructor of <code>RandomAccessIterator1</code>,
        or by the default constructor, copy constructor, or the copy assignment operator of the value type of <code>RandomAccessIterator1</code>,
        or the copy constructor or <code>operator()</code> of <code>BinaryPredicate</code> or <code>Hash</code>.
        May throw <code>bad_alloc</code> if additional memory needed for internal data structures cannot be allocated.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="func.searchers.boyer_moore.6">
    
    <pre><code><cxx-signature>template&lt;class RandomAccessIterator2&gt;
RandomAccessIterator2 operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="7" id="func.searchers.boyer_moore.7">
    
    <dt>Requires:</dt><dd><code>RandomAccessIterator1</code> and <code>RandomAccessIterator2</code> shall have the same value type.</dd>
  </cxx-requires>
        <cxx-effects para_num="8" id="func.searchers.boyer_moore.8">
    
    <dt>Effects:</dt><dd>Finds a subsequence of equal values in a sequence.</dd>
  </cxx-effects>
        <cxx-returns para_num="9" id="func.searchers.boyer_moore.9">
    
    <dt>Returns:</dt><dd>
          The first iterator <code>i</code> in the range <cxx-range begin="first" end="last - (pat_last_ - pat_first_)">[<code>first</code>, <code>last - (pat_last_ - pat_first_)</code>)</cxx-range>
          such that for every non-negative integer <code>n</code> less than <code>pat_last_ - pat_first_</code> the following condition holds:
          <code>pred(*(i + n), *(pat_first_ + n)) != false</code>.
          Returns <code>first</code> if <cxx-range begin="pat_first_" end="pat_last_">[<code>pat_first_</code>, <code>pat_last_</code>)</cxx-range> is empty,
          otherwise returns <code>last</code> if no such iterator is found.
        </dd>
  </cxx-returns>
        <cxx-complexity para_num="10" id="func.searchers.boyer_moore.10">
    
    <dt>Complexity:</dt><dd>At most <code>(last - first) * (pat_last_ - pat_first_)</code> applications of the predicate.</dd>
  </cxx-complexity>
      
    </dl>
  </cxx-function>

      <cxx-section id="func.searchers.boyer_moore.creation">
    

    <section>
      <header><span class="section-number">4.3.2.1</span> <h1 data-bookmark-label="4.3.2.1 boyer_moore_searcher creation functions"><code>boyer_moore_searcher</code> creation functions</h1> <span style="float:right"><a href="#func.searchers.boyer_moore.creation">[func.searchers.boyer_moore.creation]</a></span></header>
      
        

        <cxx-function para_num="1" id="func.searchers.boyer_moore.creation.1">
    
    <pre><code><cxx-signature>template&lt;class RandomAccessIterator,
class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
class BinaryPredicate = equal_to&lt;&gt;&gt;
  boyer_moore_searcher&lt;RandomAccessIterator, Hash, BinaryPredicate&gt;
  make_boyer_moore_searcher(RandomAccessIterator pat_first, RandomAccessIterator pat_last,
                            Hash hf = Hash(), BinaryPredicate pred = BinaryPredicate());</cxx-signature></code></pre>

    <dl>
      
          

          <cxx-effects para_num="2" id="func.searchers.boyer_moore.creation.2">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return boyer_moore_searcher&lt;RandomAccessIterator, Hash, BinaryPredicate&gt;(<w-br><wbr></w-br>pat_first, pat_last, hf, pred);</code></dd>
  </cxx-effects>
        
    </dl>
  </cxx-function>
      
    </section>
  </cxx-section>
    
    </section>
  </cxx-section>

    <cxx-section id="func.searchers.boyer_moore_horspool">
    

    <section>
      <header><span class="section-number">4.3.3</span> <h1 data-bookmark-label="4.3.3 Class template boyer_moore_horspool_searcher">Class template <code>boyer_moore_horspool_searcher</code></h1> <span style="float:right"><a href="#func.searchers.boyer_moore_horspool">[func.searchers.boyer_moore_horspool]</a></span></header>
      
      

<pre><code>
template&lt;class RandomAccessIterator1,
         class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator1&gt;::value_type&gt;,
         class BinaryPredicate = equal_to&lt;&gt;&gt;
class boyer_moore_horspool_searcher {
public:
  boyer_moore_horspool_searcher(RandomAccessIterator1 pat_first, RandomAccessIterator1 pat_last,
                                Hash hf = Hash(), BinaryPredicate pred = BinaryPredicate());

  template&lt;class RandomAccessIterator2&gt;
  RandomAccessIterator2
  operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;

private:
  RandomAccessIterator1 pat_first_; <i>// exposition only</i>
  RandomAccessIterator1 pat_last_;  <i>// exposition only</i>
  Hash                  hash_;      <i>// exposition only</i>
  BinaryPredicate       pred_;      <i>// exposition only</i>
};
</code></pre>

      <cxx-function para_num="1" id="func.searchers.boyer_moore_horspool.1">
    
    <pre><code><cxx-signature>boyer_moore_horspool_searcher(
RandomAccessIterator1 pat_first, RandomAccessIterator1 pat_last,
Hash hf = Hash(), BinaryPredicate pred = BinaryPredicate());</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="func.searchers.boyer_moore_horspool.2">
    
    <dt>Requires:</dt><dd>The value type of <code>RandomAccessIterator1</code> shall meet the <code>DefaultConstructible</code>, <code>CopyConstructible</code>, and <code>CopyAssignable</code> requirements.</dd>
  </cxx-requires>
        <cxx-requires para_num="3" id="func.searchers.boyer_moore_horspool.3">
    
    <dt>Requires:</dt><dd>For any two values <code>A</code> and <code>B</code> of the type <code>iterator_traits&lt;RandomAccessIterator1&gt;::value_type</code>,
        if <code>pred(A,B)==true</code>, then <code>hf(A)==hf(B)</code> shall be true.</dd>
  </cxx-requires>
        <cxx-effects para_num="4" id="func.searchers.boyer_moore_horspool.4">
    
    <dt>Effects:</dt><dd>Constructs a <code>boyer_moore_horspool_searcher</code> object, initializing <code>pat_first_</code> with <code>pat_first</code>,
        <code>pat_last_</code> with <code>pat_last</code>, <code>hash_</code> with <code>hf</code>, and <code>pred_</code> with <code>pred</code>.</dd>
  </cxx-effects>
        <cxx-throws para_num="5" id="func.searchers.boyer_moore_horspool.5">
    
    <dt>Throws:</dt><dd>
          Any exception thrown by the copy constructor of <code>RandomAccessIterator1</code>,
          or by the default constructor, copy constructor, or the copy assignment operator of the value type of <code>RandomAccessIterator1</code>
          or the copy constructor or <code>operator()</code> of <code>BinaryPredicate</code> or <code>Hash</code>.
          May throw <code>bad_alloc</code> if additional memory needed for internal data structures cannot be allocated..
        </dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="func.searchers.boyer_moore_horspool.6">
    
    <pre><code><cxx-signature>template&lt;class RandomAccessIterator2&gt;
RandomAccessIterator2 operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="7" id="func.searchers.boyer_moore_horspool.7">
    
    <dt>Requires:</dt><dd><code>RandomAccessIterator1</code> and <code>RandomAccessIterator2</code> shall have the same value type.</dd>
  </cxx-requires>
        <cxx-effects para_num="8" id="func.searchers.boyer_moore_horspool.8">
    
    <dt>Effects:</dt><dd>Finds a subsequence of equal values in a sequence.</dd>
  </cxx-effects>
        <cxx-returns para_num="9" id="func.searchers.boyer_moore_horspool.9">
    
    <dt>Returns:</dt><dd>
          The first iterator <code>i</code> in the range <cxx-range begin="first" end="last - (pat_last_ - pat_first_)">[<code>first</code>, <code>last - (pat_last_ - pat_first_)</code>)</cxx-range>
          such that for every non-negative integer <code>n</code> less than <code>pat_last_ - pat_first_</code> the following condition holds:
          <code>pred(*(i + n), *(pat_first_ + n)) != false</code>.
          Returns <code>first</code> if <cxx-range begin="pat_first_" end="pat_last_">[<code>pat_first_</code>, <code>pat_last_</code>)</cxx-range> is empty,
          otherwise returns <code>last</code> if no such iterator is found.
        </dd>
  </cxx-returns>
        <cxx-complexity para_num="10" id="func.searchers.boyer_moore_horspool.10">
    
    <dt>Complexity:</dt><dd>At most <code>(last - first) * (pat_last_ - pat_first_)</code> applications of the predicate.</dd>
  </cxx-complexity>
      
    </dl>
  </cxx-function>

      <cxx-section id="func.searchers.boyer_moore_horspool.creation">
    

    <section>
      <header><span class="section-number">4.3.3.1</span> <h1 data-bookmark-label="4.3.3.1 boyer_moore_horspool_searcher creation functions"><code>boyer_moore_horspool_searcher</code> creation functions</h1> <span style="float:right"><a href="#func.searchers.boyer_moore_horspool.creation">[func.searchers.boyer_moore_horspool.creation]</a></span></header>
      
        

        <cxx-function para_num="1" id="func.searchers.boyer_moore_horspool.creation.1">
    
    <pre><code><cxx-signature>template&lt;class RandomAccessIterator,
         class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
         class BinaryPredicate = equal_to&lt;&gt;&gt;
boyer_moore_searcher_horspool&lt;RandomAccessIterator, Hash, BinaryPredicate&gt;
make_boyer_moore_horspool_searcher(
    RandomAccessIterator pat_first, RandomAccessIterator pat_last,
    Hash hf = Hash(), BinaryPredicate pred = BinaryPredicate());</cxx-signature></code></pre>

    <dl>
      
          

          <cxx-effects para_num="2" id="func.searchers.boyer_moore_horspool.creation.2">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return boyer_moore_horspool_searcher&lt;RandomAccessIterator, Hash, BinaryPredicate&gt;(<w-br><wbr></w-br>pat_first, pat_last, hf, pred);</code></dd>
  </cxx-effects>
        
    </dl>
  </cxx-function>
      
    </section>
  </cxx-section>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="func.not_fn">
    

    <section>
      <header><span class="section-number">4.4</span> <h1 data-bookmark-label="4.4 Function template not_fn">Function template <code>not_fn</code></h1> <span style="float:right"><a href="#func.not_fn">[func.not_fn]</a></span></header>
      
    

    <cxx-function para_num="1" id="func.not_fn.1">
    
    <pre><code><cxx-signature>template &lt;class F&gt; <em>unspecified</em> not_fn(F&amp;&amp; f);</cxx-signature></code></pre>

    <dl>
      
      

      <p para_num="2" id="func.not_fn.2">In the text that follows:</p>
      <ul>
        <li><code>FD</code> is the type <code>decay_t&lt;F&gt;</code>,</li>
        <li><code>fd</code> is an lvalue of type <code>FD</code> constructed from <code>std::forward&lt;F&gt;(f),</code></li>
        <li><code>fn</code> is a forwarding call wrapper created as a result of <code>not_fn(f)</code>,</li>
      </ul>
      <cxx-requires para_num="3" id="func.not_fn.3">
    
    <dt>Requires:</dt><dd>
        <code>is_constructible&lt;FD, F&gt;::value</code> shall be <code>true</code>.
        <code>fd</code> shall be a callable object (<cxx-ref in="cxx" to="func.def">C++14 <span title="func.def">§20.9.1</span></cxx-ref>).
      </dd>
  </cxx-requires>
      <cxx-returns para_num="4" id="func.not_fn.4">
    
    <dt>Returns:</dt><dd>
        A forwarding call wrapper <code>fn</code> such that the expression <code>fn(a1, a2, ..., aN)</code>
        is equivalent to <code>!<em>INVOKE</em>(fd, a1, a2, ..., aN)</code> (<cxx-ref in="cxx" to="func.require">C++14 <span title="func.require">§20.9.2</span></cxx-ref>).
      </dd>
  </cxx-returns>
      <cxx-throws para_num="5" id="func.not_fn.5">
    
    <dt>Throws:</dt><dd>Nothing unless the construction of <code>fd</code> throws an exception.</dd>
  </cxx-throws>
      <cxx-remarks para_num="6" id="func.not_fn.6">
    
    <dt>Remarks:</dt><dd>
        The return type shall satisfy the requirements of <code>MoveConstructible</code>.
        If <code>FD</code> satisfies the requirements of <code>CopyConstructible</code>, then
        the return type shall satisfy the requirements of <code>CopyConstructible</code>.
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    This implies that <code>FD</code> is MoveConstructible.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </dd>
  </cxx-remarks>
      <p para_num="7" id="func.not_fn.7"><cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Function template <code>not_fn</code> can usually provide a better solution than using the negators <code>not1</code> and <code>not2</code>
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="optional">
    

    <section>
      <header><span class="section-number">5</span> <h1 data-bookmark-label="5 Optional objects">Optional objects</h1> <span style="float:right"><a href="#optional">[optional]</a></span></header>
      
  

  <cxx-section id="optional.general">
    

    <section>
      <header><span class="section-number">5.1</span> <h1 data-bookmark-label="5.1 In general">In general</h1> <span style="float:right"><a href="#optional.general">[optional.general]</a></span></header>
      
    

    <p para_num="1" id="optional.general.1">This subclause describes class template <code>optional</code> that represents <em>optional objects</em>. An <dfn>optional object for object types</dfn>
 is an object that contains the storage for another object and manages 
the lifetime of this contained object, if any. The contained object may 
be initialized after the optional object has been initialized, and may 
be destroyed before the optional object has been destroyed. The 
initialization state of the contained object is tracked by the optional 
object.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.synop">
    

    <section>
      <header><span class="section-number">5.2</span> <h1 data-bookmark-label="5.2 Header &lt;experimental/optional&gt; synopsis">Header <code>&lt;experimental/optional&gt;</code> synopsis</h1> <span style="float:right"><a href="#optional.synop">[optional.synop]</a></span></header>
      
    

<pre><code>namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    <cxx-ref insynopsis="" to="optional.object">// <i><a title="optional.object" href="#optional.object">5.3</a>, optional for object types</i></cxx-ref>
    template &lt;class T&gt; class optional;

    <cxx-ref insynopsis="" to="optional.inplace">// <i><a title="optional.inplace" href="#optional.inplace">5.4</a>, In-place construction</i></cxx-ref>
    struct in_place_t{};
    constexpr in_place_t in_place{};

    <cxx-ref insynopsis="" to="optional.nullopt">// <i><a title="optional.nullopt" href="#optional.nullopt">5.5</a>, No-value state indicator</i></cxx-ref>
    struct nullopt_t{<em>see below</em>};
    constexpr nullopt_t nullopt(<em>unspecified</em>);

    <cxx-ref insynopsis="" to="optional.bad_optional_access">// <i><a title="optional.bad_optional_access" href="#optional.bad_optional_access">5.6</a>, Class bad_optional_access</i></cxx-ref>
    class bad_optional_access;

    <cxx-ref insynopsis="" to="optional.relops">// <i><a title="optional.relops" href="#optional.relops">5.7</a>, Relational operators</i></cxx-ref>
    template &lt;class T&gt;
      constexpr bool operator==(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
    template &lt;class T&gt;
      constexpr bool operator!=(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
    template &lt;class T&gt;
      constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
    template &lt;class T&gt;
      constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
    template &lt;class T&gt;
      constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
    template &lt;class T&gt;
      constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);

    <cxx-ref insynopsis="" to="optional.nullops">// <i><a title="optional.nullops" href="#optional.nullops">5.8</a>, Comparison with nullopt</i></cxx-ref>
    template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
    template &lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
    template &lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
    template &lt;class T&gt; constexpr bool operator!=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
    template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
    template &lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
    template &lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
    template &lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
    template &lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
    template &lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
    template &lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
    template &lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;

    <cxx-ref insynopsis="" to="optional.comp_with_t">// <i><a title="optional.comp_with_t" href="#optional.comp_with_t">5.9</a>, Comparison with T</i></cxx-ref>
    template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, const T&amp;);
    template &lt;class T&gt; constexpr bool operator==(const T&amp;, const optional&lt;T&gt;&amp;);
    template &lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp;, const T&amp;);
    template &lt;class T&gt; constexpr bool operator!=(const T&amp;, const optional&lt;T&gt;&amp;);
    template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const T&amp;);
    template &lt;class T&gt; constexpr bool operator&lt;(const T&amp;, const optional&lt;T&gt;&amp;);
    template &lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const T&amp;);
    template &lt;class T&gt; constexpr bool operator&lt;=(const T&amp;, const optional&lt;T&gt;&amp;);
    template &lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const T&amp;);
    template &lt;class T&gt; constexpr bool operator&gt;(const T&amp;, const optional&lt;T&gt;&amp;);
    template &lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const T&amp;);
    template &lt;class T&gt; constexpr bool operator&gt;=(const T&amp;, const optional&lt;T&gt;&amp;);

    <cxx-ref insynopsis="" to="optional.specalg">// <i><a title="optional.specalg" href="#optional.specalg">5.10</a>, Specialized algorithms</i></cxx-ref>
    template &lt;class T&gt; void swap(optional&lt;T&gt;&amp;, optional&lt;T&gt;&amp;) noexcept(<em>see below</em>);
    template &lt;class T&gt; constexpr optional&lt;<em>see below</em>&gt; make_optional(T&amp;&amp;);

  } // <i>namespace fundamentals_v2</i>
  } // <i>namespace experimental</i>

  <cxx-ref insynopsis="" to="optional.hash">// <i><a title="optional.hash" href="#optional.hash">5.11</a>, Hash support</i></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt; struct hash&lt;experimental::optional&lt;T&gt;&gt;;

} // <i>namespace std</i></code></pre>

    <p para_num="1" id="optional.synop.1">A program that necessitates the instantiation of template <code>optional</code> for a reference type, or for possibly cv-qualified types <code>in_place_t</code> or <code>nullopt_t</code> is ill-formed.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.object">
    

    <section>
      <header><span class="section-number">5.3</span> <h1 data-bookmark-label="5.3 optional for object types"><code>optional</code> for object types</h1> <span style="float:right"><a href="#optional.object">[optional.object]</a></span></header>
      
    

<pre><code>template &lt;class T&gt;
class optional
{
public:
  typedef T value_type;

  <cxx-ref insynopsis="" to="optional.object.ctor">// <i><a title="optional.object.ctor" href="#optional.object.ctor">5.3.1</a>, Constructors</i></cxx-ref>
  constexpr optional() noexcept;
  constexpr optional(nullopt_t) noexcept;
  optional(const optional&amp;);
  optional(optional&amp;&amp;) noexcept(<em>see below</em>);
  constexpr optional(const T&amp;);
  constexpr optional(T&amp;&amp;);
  template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;...);
  template &lt;class U, class... Args&gt;
    constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args&amp;&amp;...);

  <cxx-ref insynopsis="" to="optional.object.dtor">// <i><a title="optional.object.dtor" href="#optional.object.dtor">5.3.2</a>, Destructor</i></cxx-ref>
  ~optional();

  <cxx-ref insynopsis="" to="optional.object.assign">// <i><a title="optional.object.assign" href="#optional.object.assign">5.3.3</a>, Assignment</i></cxx-ref>
  optional&amp; operator=(nullopt_t) noexcept;
  optional&amp; operator=(const optional&amp;);
  optional&amp; operator=(optional&amp;&amp;) noexcept(<em>see below</em>);
  template &lt;class U&gt; optional&amp; operator=(U&amp;&amp;);
  template &lt;class... Args&gt; void emplace(Args&amp;&amp;...);
  template &lt;class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);

  <cxx-ref insynopsis="" to="optional.object.swap">// <i><a title="optional.object.swap" href="#optional.object.swap">5.3.4</a>, Swap</i></cxx-ref>
  void swap(optional&amp;) noexcept(<em>see below</em>);

  <cxx-ref insynopsis="" to="optional.object.observe">// <i><a title="optional.object.observe" href="#optional.object.observe">5.3.5</a>, Observers</i></cxx-ref>
  constexpr T const* operator -&gt;() const;
  constexpr T* operator -&gt;();
  constexpr T const&amp; operator *() const &amp;;
  constexpr T&amp; operator *() &amp;;
  constexpr T&amp;&amp; operator *() &amp;&amp;;
  constexpr const T&amp;&amp; operator *() const &amp;&amp;;
  constexpr explicit operator bool() const noexcept;
  constexpr T const&amp; value() const &amp;;
  constexpr T&amp; value() &amp;;
  constexpr T&amp;&amp; value() &amp;&amp;;
  constexpr const T&amp;&amp; value() const &amp;&amp;;
  template &lt;class U&gt; constexpr T value_or(U&amp;&amp;) const &amp;;
  template &lt;class U&gt; constexpr T value_or(U&amp;&amp;) &amp;&amp;;

private:
  T*   val;  // <i>exposition only</i>
};</code></pre>

    <p para_num="1" id="optional.object.1">
      Any instance of <code>optional&lt;T&gt;</code> at any given time either contains a value or does not contain a value.
      When an instance of <code>optional&lt;T&gt;</code> <dfn>contains a value</dfn>,
      it means that an object of type <code>T</code>, referred to as the optional object's <dfn>contained value</dfn>,
      is allocated within the storage of the optional object.
      Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value.
      The contained value shall be allocated in a region of the <code>optional&lt;T&gt;</code> storage suitably aligned for the type <code>T</code>.
      When an object of type <code>optional&lt;T&gt;</code> is contextually converted to <code>bool</code>,
      the conversion returns <code>true</code> if the object contains a value;
      otherwise the conversion returns <code>false</code>.
    </p>

    <p para_num="2" id="optional.object.2">Member <code>val</code> is provided for exposition only. When an <code>optional&lt;T&gt;</code> object contains a value, <code>val</code> points to the contained value.</p>

    <p para_num="3" id="optional.object.3"><code>T</code> shall be an object type and shall satisfy the requirements of <code>Destructible</code> (Table 24).</p>

    <cxx-section id="optional.object.ctor">
    

    <section>
      <header><span class="section-number">5.3.1</span> <h1 data-bookmark-label="5.3.1 Constructors">Constructors</h1> <span style="float:right"><a href="#optional.object.ctor">[optional.object.ctor]</a></span></header>
      
      

      <cxx-function para_num="1" id="optional.object.ctor.1">
    
    <pre><code><cxx-signature>constexpr optional() noexcept;</cxx-signature><cxx-signature>constexpr optional(nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-postconditions para_num="2" id="optional.object.ctor.2">
    
    <dt>Postconditions:</dt><dd><code>*this</code> does not contain a value.</dd>
  </cxx-postconditions>
        <cxx-remarks para_num="3" id="optional.object.ctor.3">
    
    <dt>Remarks:</dt><dd>No contained value is initialized.
        For every object type <code>T</code> these constructors shall be <code>constexpr</code> constructors (<cxx-ref in="cxx" to="dcl.constexpr">C++14 <span title="dcl.constexpr">§7.1.5</span></cxx-ref>).</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="optional.object.ctor.4">
    
    <pre><code><cxx-signature>optional(const optional&lt;T&gt;&amp; <var>rhs</var>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="5" id="optional.object.ctor.5">
    
    <dt>Requires:</dt><dd><code>is_copy_constructible_v&lt;T&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="6" id="optional.object.ctor.6">
    
    <dt>Effects:</dt><dd>If <code><var>rhs</var></code> contains a value, initializes the contained value as if
        direct-non-list-initializing an object of type <code>T</code> with the expression <code>*<var>rhs</var></code>.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="7" id="optional.object.ctor.7">
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions>
        <cxx-throws para_num="8" id="optional.object.ctor.8">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="optional.object.ctor.9">
    
    <pre><code><cxx-signature>optional(optional&lt;T&gt;&amp;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="10" id="optional.object.ctor.10">
    
    <dt>Requires:</dt><dd><code>is_move_constructible_v&lt;T&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="11" id="optional.object.ctor.11">
    
    <dt>Effects:</dt><dd>If <code><var>rhs</var></code> contains a value, initializes the contained value as if
        direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(*<var>rhs</var>)</code>.
        <code>bool(<var>rhs</var>)</code> is unchanged.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="12" id="optional.object.ctor.12">
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions>
        <cxx-throws para_num="13" id="optional.object.ctor.13">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws>
        <cxx-remarks para_num="14" id="optional.object.ctor.14">
    
    <dt>Remarks:</dt><dd>The expression inside <code>noexcept</code> is equivalent to:<pre><code>is_nothrow_move_constructible_v&lt;T&gt;</code></pre></dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="15" id="optional.object.ctor.15">
    
    <pre><code><cxx-signature>constexpr optional(const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="16" id="optional.object.ctor.16">
    
    <dt>Requires:</dt><dd><code>is_copy_constructible_v&lt;T&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="17" id="optional.object.ctor.17">
    
    <dt>Effects:</dt><dd>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code><var>v</var></code>.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="18" id="optional.object.ctor.18">
    
    <dt>Postconditions:</dt><dd><code>*this</code> contains a value.</dd>
  </cxx-postconditions>
        <cxx-throws para_num="19" id="optional.object.ctor.19">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws>
        <cxx-remarks para_num="20" id="optional.object.ctor.20">
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="21" id="optional.object.ctor.21">
    
    <pre><code><cxx-signature>constexpr optional(T&amp;&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="22" id="optional.object.ctor.22">
    
    <dt>Requires:</dt><dd><code>is_move_constructible_v&lt;T&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="23" id="optional.object.ctor.23">
    
    <dt>Effects:</dt><dd>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(<var>v</var>)</code>.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="24" id="optional.object.ctor.24">
    
    <dt>Postconditions:</dt><dd><code>*this</code> contains a value.</dd>
  </cxx-postconditions>
        <cxx-throws para_num="25" id="optional.object.ctor.25">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws>
        <cxx-remarks para_num="26" id="optional.object.ctor.26">
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="27" id="optional.object.ctor.27">
    
    <pre><code><cxx-signature>template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="28" id="optional.object.ctor.28">
    
    <dt>Requires:</dt><dd><code>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="29" id="optional.object.ctor.29">
    
    <dt>Effects:</dt><dd>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the arguments <code>std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="30" id="optional.object.ctor.30">
    
    <dt>Postconditions:</dt><dd><code>*this</code> contains a value.</dd>
  </cxx-postconditions>
        <cxx-throws para_num="31" id="optional.object.ctor.31">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws>
        <cxx-remarks para_num="32" id="optional.object.ctor.32">
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s constructor selected for the initialization is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="33" id="optional.object.ctor.33">
    
    <pre><code><cxx-signature>template &lt;class U, class... Args&gt;
constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; <var>il</var>, Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="34" id="optional.object.ctor.34">
    
    <dt>Requires:</dt><dd><code>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="35" id="optional.object.ctor.35">
    
    <dt>Effects:</dt><dd>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the arguments <code><var>il</var>, std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="36" id="optional.object.ctor.36">
    
    <dt>Postconditions:</dt><dd><code>*this</code> contains a value.</dd>
  </cxx-postconditions>
        <cxx-throws para_num="37" id="optional.object.ctor.37">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws>
        <cxx-remarks para_num="38" id="optional.object.ctor.38">
    
    <dt>Remarks:</dt><dd>The function shall not participate in overload resolution unless <code>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</code> is <code>true</code>.
        If <code>T</code>'s constructor selected for the initialization is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.dtor">
    

    <section>
      <header><span class="section-number">5.3.2</span> <h1 data-bookmark-label="5.3.2 Destructor">Destructor</h1> <span style="float:right"><a href="#optional.object.dtor">[optional.object.dtor]</a></span></header>
      
      

      <cxx-function para_num="1" id="optional.object.dtor.1">
    
    <pre><code><cxx-signature>~optional();</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="optional.object.dtor.2">
    
    <dt>Effects:</dt><dd>If <code>is_trivially_destructible_v&lt;T&gt; != true</code> and <code>*this</code> contains a value, calls <code><var>val</var>-&gt;T::~T()</code>.</dd>
  </cxx-effects>
        <cxx-remarks para_num="3" id="optional.object.dtor.3">
    
    <dt>Remarks:</dt><dd>If <code>is_trivially_destructible_v&lt;T&gt; == true</code> then this destructor shall be a trivial destructor.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.assign">
    

    <section>
      <header><span class="section-number">5.3.3</span> <h1 data-bookmark-label="5.3.3 Assignment">Assignment</h1> <span style="float:right"><a href="#optional.object.assign">[optional.object.assign]</a></span></header>
      
      

      <cxx-function para_num="1" id="optional.object.assign.1">
    
    <pre><code><cxx-signature>optional&lt;T&gt;&amp; operator=(nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="optional.object.assign.2">
    
    <dt>Effects:</dt><dd>If <code>*this</code> contains a value, calls <code><var>val</var>-&gt;T::~T()</code> to destroy the contained value; otherwise no effect.</dd>
  </cxx-effects>
        <cxx-returns para_num="3" id="optional.object.assign.3">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
        <cxx-postconditions para_num="4" id="optional.object.assign.4">
    
    <dt>Postconditions:</dt><dd><code>*this</code> does not contain a value.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="optional.object.assign.5">
    
    <pre><code><cxx-signature>optional&lt;T&gt;&amp; operator=(const optional&lt;T&gt;&amp; <var>rhs</var>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="6" id="optional.object.assign.6">
    
    <dt>Requires:</dt><dd><code>is_copy_constructible_v&lt;T&gt;</code> is <code>true</code> and <code>is_copy_assignable_v&lt;T&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="7" id="optional.object.assign.7">
    
    <dt>Effects:</dt><dd>
          <table is="cxx-table" class="single-border column-rules">
    

    <caption>Table 5 — <wbr><span><code>optional::operator=(const optional&amp;)</code> effects</span></caption>
    
            
            <tbody><tr>
              <th></th>
              <th><code>*this</code> contains a value</th>
              <th><code>*this</code> does not contain a value</th>
            </tr>
            <tr>
              <th><code>rhs</code> contains a value</th>
              <td>assigns <code>*rhs</code> to the contained value</td>
              <td>initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with <code>*rhs</code></td>
            </tr>
            <tr>
              <th><code>rhs</code> does not contain a value</th>
              <td>destroys the contained value by calling <code>val-&gt;T::~T()</code></td>
              <td>no effect</td>
            </tr>
          </tbody>
  </table>
        </dd>
  </cxx-effects>
        <cxx-returns para_num="8" id="optional.object.assign.8">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
        <cxx-postconditions para_num="9" id="optional.object.assign.9">
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions>
        <cxx-remarks para_num="10" id="optional.object.assign.10">
    
    <dt>Remarks:</dt><dd>
          If any exception is thrown, the result of the expression <code>bool(*this)</code> remains unchanged.
          If an exception is thrown during the call to <code>T</code>'s copy constructor, no effect.
          If an exception is thrown during the call to <code>T</code>'s copy assignment,
          the state of its contained value is as defined by the exception safety guarantee of <code>T</code>'s copy assignment.
        </dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="11" id="optional.object.assign.11">
    
    <pre><code><cxx-signature>optional&lt;T&gt;&amp; operator=(optional&lt;T&gt;&amp;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="12" id="optional.object.assign.12">
    
    <dt>Requires:</dt><dd><code>is_move_constructible_v&lt;T&gt;</code> is <code>true</code> and <code>is_move_assignable_v&lt;T&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="13" id="optional.object.assign.13">
    
    <dt>Effects:</dt><dd>The result of the expression <code>bool(rhs)</code> remains unchanged.

          <table is="cxx-table" class="single-border column-rules">
    

    <caption>Table 6 — <wbr><span><code>optional::operator=(optional&amp;&amp;)</code> effects</span></caption>
    
            
            <tbody><tr>
              <th></th>
              <th><code>*this</code> contains a value</th>
              <th><code>*this</code> does not contain a value</th>
            </tr>
            <tr>
              <th><code>rhs</code> contains a value</th>
              <td>assigns <code>std::move(*rhs)</code> to the contained value</td>
              <td>initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with <code>std::move(*rhs)</code></td>
            </tr>
            <tr>
              <th><code>rhs</code> does not contain a value</th>
              <td>destroys the contained value by calling <code>val-&gt;T::~T()</code></td>
              <td>no effect</td>
            </tr>
          </tbody>
  </table>
        </dd>
  </cxx-effects>
        <cxx-returns para_num="14" id="optional.object.assign.14">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
        <cxx-postconditions para_num="15" id="optional.object.assign.15">
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions>
        <cxx-remarks para_num="16" id="optional.object.assign.16">
    
    <dt>Remarks:</dt><dd>
          <p>The expression inside <code>noexcept</code> is equivalent to: </p><pre><code>is_nothrow_move_assignable_v&lt;T&gt; &amp;&amp; <w-br><wbr></w-br>is_nothrow_move_constructible_v&lt;T&gt;</code></pre><p></p>

          <p>
            If any exception is thrown, the result of the expression <code>bool(*this)</code> remains unchanged.
            If an exception is thrown during the call to <code>T</code>'s move constructor,
            the state of <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s move constructor.
            If an exception is thrown during the call to <code>T</code>'s move assignment,
            the state of <code><var>*val</var></code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s move assignment.
          </p>
        </dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="17" id="optional.object.assign.17">
    
    <pre><code><cxx-signature>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="18" id="optional.object.assign.18">
    
    <dt>Requires:</dt><dd><code>is_constructible_v&lt;T, U&gt;</code> is <code>true</code> and <code>is_assignable_v&lt;T&amp;, U&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="19" id="optional.object.assign.19">
    
    <dt>Effects:</dt><dd>If <code>*this</code> contains a value, assigns <code>std::forward&lt;U&gt;(<var>v</var>)</code> to the contained value; otherwise initializes the contained value as if direct-non-list-initializing object of type <code>T</code> with <code>std::forward&lt;U&gt;(<var>v</var>)</code>.</dd>
  </cxx-effects>
        <cxx-returns para_num="20" id="optional.object.assign.20">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
        <cxx-postconditions para_num="21" id="optional.object.assign.21">
    
    <dt>Postconditions:</dt><dd><code>*this</code> contains a value.</dd>
  </cxx-postconditions>
        <cxx-remarks para_num="22" id="optional.object.assign.22">
    
    <dt>Remarks:</dt><dd>
          <p>If any exception is thrown, the result of the expression <code>bool(*this)</code> remains unchanged. If an exception is thrown during the call to <code>T</code>'s constructor, the state of <code><var>v</var></code> is determined by the exception safety guarantee of <code>T</code>'s constructor. If an exception is thrown during the call to <code>T</code>'s assignment, the state of <code><var>*val</var></code> and <code><var>v</var></code> is determined by the exception safety guarantee of <code>T</code>'s assignment.</p>
          <p>The function shall not participate in overload resolution unless
          <code>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</code> is <code>true</code>.</p>
        </dd>
  </cxx-remarks>
        <cxx-notes para_num="23" id="optional.object.assign.23">
    
    <dt>Notes:</dt><dd>The reason for providing such generic assignment and then constraining it so that effectively <code>T</code> == <code>U</code> is to guarantee that assignment of the form <code>o = {}</code> is unambiguous.</dd>
  </cxx-notes>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="24" id="optional.object.assign.24">
    
    <pre><code><cxx-signature>template &lt;class... Args&gt; void emplace(Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="25" id="optional.object.assign.25">
    
    <dt>Requires:</dt><dd><code>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="26" id="optional.object.assign.26">
    
    <dt>Effects:</dt><dd>Calls <code>*this = nullopt</code>. Then initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the arguments <code>std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="27" id="optional.object.assign.27">
    
    <dt>Postconditions:</dt><dd><code>*this</code> contains a value.</dd>
  </cxx-postconditions>
        <cxx-throws para_num="28" id="optional.object.assign.28">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws>
        <cxx-remarks para_num="29" id="optional.object.assign.29">
    
    <dt>Remarks:</dt><dd>If an exception is thrown during the call to <code>T</code>'s constructor, <code>*this</code> does not contain a value, and the previous <code><var>*val</var></code> (if any) has been destroyed.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="30" id="optional.object.assign.30">
    
    <pre><code><cxx-signature>template &lt;class U, class... Args&gt; <w-br><wbr></w-br>void emplace(initializer_list&lt;U&gt; <var>il</var>, Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="31" id="optional.object.assign.31">
    
    <dt>Effects:</dt><dd>Calls <code>*this = nullopt</code>. Then initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the arguments <code><var>il</var>, std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="32" id="optional.object.assign.32">
    
    <dt>Postconditions:</dt><dd><code>*this</code> contains a value.</dd>
  </cxx-postconditions>
        <cxx-throws para_num="33" id="optional.object.assign.33">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws>
        <cxx-remarks para_num="34" id="optional.object.assign.34">
    
    <dt>Remarks:</dt><dd>
          <p>If an exception is thrown during the call to <code>T</code>'s constructor, <code>*this</code> does not contain a value, and the previous <code><var>*val</var></code> (if any) has been destroyed.</p>
          <p>The function shall not participate in overload resolution unless <code>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</code> is <code>true</code>.</p>
        </dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.swap">
    

    <section>
      <header><span class="section-number">5.3.4</span> <h1 data-bookmark-label="5.3.4 Swap">Swap</h1> <span style="float:right"><a href="#optional.object.swap">[optional.object.swap]</a></span></header>
      
      

      <cxx-function para_num="1" id="optional.object.swap.1">
    
    <pre><code><cxx-signature>void swap(optional&lt;T&gt;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="optional.object.swap.2">
    
    <dt>Requires:</dt><dd>Lvalues of type <code>T</code> shall be swappable and <code>is_move_constructible_v&lt;T&gt;</code> is <code>true</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="3" id="optional.object.swap.3">
    
    <dt>Effects:</dt><dd>

          <table is="cxx-table" class="single-border column-rules">
    

    <caption>Table 7 — <wbr><span><code>optional::swap(optional&amp;)</code> effects</span></caption>
    
            
            <tbody><tr>
              <th></th>
              <th><code>*this</code> contains a value</th>
              <th><code>*this</code> does not contain a value</th>
            </tr>
            <tr>
              <th><code>rhs</code> contains a value</th>
              <td>calls <code>swap(*(*this), *<var>rhs</var>)</code></td>
              <td>initializes the contained value of <code>*this</code> as if
              direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(*<var>rhs</var>)</code>,
              followed by <code>rhs.val-&gt;T::~T()</code>;
              postcondition is that <code>*this</code> contains a value and <code><var>rhs</var></code> does not contain a value</td>
            </tr>
              <tr><th><code>rhs</code> does not contain a value</th>
              <td>initializes the contained value of <code><var>rhs</var></code> as if
              direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(*(*this))</code>,
              followed by <code>val-&gt;T::~T()</code>;
              postcondition is that <code>*this</code> does not contain a value and <code><var>rhs</var></code> contains a value</td>
              <td>no effect</td>
            </tr>
          </tbody>
  </table>
        </dd>
  </cxx-effects>
        <cxx-throws para_num="4" id="optional.object.swap.4">
    
    <dt>Throws:</dt><dd>Any exceptions that the expressions in the Effects element throw.</dd>
  </cxx-throws>
        <cxx-remarks para_num="5" id="optional.object.swap.5">
    
    <dt>Remarks:</dt><dd>
          <p>The expression inside <code>noexcept</code> is equivalent to: </p><pre><code>is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; <w-br><wbr></w-br>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</code></pre><p></p>
          <p>
            If any exception is thrown, the results of the expressions <code>bool(*this)</code> and <code>bool(<var>rhs</var>)</code> remain unchanged.
            If an exception is thrown during the call to function <code>swap</code>
            the state of <code><var>*val</var></code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>swap</code> for lvalues of <code>T</code>.
            If an exception is thrown during the call to <code>T</code>'s move constructor,
            the state of <code><var>*val</var></code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s move constructor.
          </p>
        </dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.observe">
    

    <section>
      <header><span class="section-number">5.3.5</span> <h1 data-bookmark-label="5.3.5 Observers">Observers</h1> <span style="float:right"><a href="#optional.object.observe">[optional.object.observe]</a></span></header>
      
      

      <cxx-function para_num="1" id="optional.object.observe.1">
    
    <pre><code><cxx-signature>constexpr T const* operator-&gt;() const;</cxx-signature><cxx-signature>constexpr T* operator-&gt;();</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-requires para_num="2" id="optional.object.observe.2">
    
    <dt>Requires:</dt><dd><code>*this</code> contains a value.</dd>
  </cxx-requires>
        <cxx-returns para_num="3" id="optional.object.observe.3">
    
    <dt>Returns:</dt><dd><code><var>val</var></code>.</dd>
  </cxx-returns>
        <cxx-throws para_num="4" id="optional.object.observe.4">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
        <cxx-remarks para_num="5" id="optional.object.observe.5">
    
    <dt>Remarks:</dt><dd>Unless <code>T</code> is a user-defined type with overloaded unary <code>operator&amp;</code>, these functions shall be <code>constexpr</code> functions.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="optional.object.observe.6">
    
    <pre><code><cxx-signature>constexpr T const&amp; operator*() const &amp;;</cxx-signature><cxx-signature>constexpr T&amp; operator*() &amp;;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-requires para_num="7" id="optional.object.observe.7">
    
    <dt>Requires:</dt><dd><code>*this</code> contains a value.</dd>
  </cxx-requires>
        <cxx-returns para_num="8" id="optional.object.observe.8">
    
    <dt>Returns:</dt><dd><code>*<var>val</var></code>.</dd>
  </cxx-returns>
        <cxx-throws para_num="9" id="optional.object.observe.9">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
        <cxx-remarks para_num="10" id="optional.object.observe.10">
    
    <dt>Remarks:</dt><dd>These functions shall be <code>constexpr</code> functions.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="11" id="optional.object.observe.11">
    
    <pre><code><cxx-signature>constexpr T&amp;&amp; operator*() &amp;&amp;;</cxx-signature><cxx-signature>constexpr const T&amp;&amp; operator*() const &amp;&amp;;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-requires para_num="12" id="optional.object.observe.12">
    
    <dt>Requires:</dt><dd><code>*this</code> contains a value.</dd>
  </cxx-requires>
        <cxx-effects para_num="13" id="optional.object.observe.13">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return std::move(*<var>val</var>);</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="14" id="optional.object.observe.14">
    
    <pre><code><cxx-signature>constexpr explicit operator bool() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="15" id="optional.object.observe.15">
    
    <dt>Returns:</dt><dd><code>true</code> if and only if <code>*this</code> contains a value.</dd>
  </cxx-returns>
        <cxx-remarks para_num="16" id="optional.object.observe.16">
    
    <dt>Remarks:</dt><dd>This function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="17" id="optional.object.observe.17">
    
    <pre><code><cxx-signature>constexpr T const&amp; value() const &amp;;</cxx-signature><cxx-signature>constexpr T&amp; value() &amp;;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-effects para_num="18" id="optional.object.observe.18">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return bool(*this) ? *val : throw bad_optional_access();</code>
      </dd>
  </cxx-effects>
    </dl>
  </cxx-function>

      <cxx-function para_num="19" id="optional.object.observe.19">
    
    <pre><code><cxx-signature>constexpr T&amp;&amp; value() &amp;&amp;;</cxx-signature><cxx-signature>constexpr const T&amp;&amp; value() const &amp;&amp;;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-effects para_num="20" id="optional.object.observe.20">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return bool(*this) ? std::move(*val) : throw bad_optional_access();</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="21" id="optional.object.observe.21">
    
    <pre><code><cxx-signature>template &lt;class U&gt; constexpr T value_or(U&amp;&amp; <var>v</var>) const &amp;;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="22" id="optional.object.observe.22">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return bool(*this) ? **this : static_cast&lt;T&gt;(std::forward&lt;U&gt;(<var>v</var>));</code></dd>
  </cxx-effects>
        <cxx-remarks para_num="23" id="optional.object.observe.23">
    
    <dt>Remarks:</dt><dd>If <code>is_copy_constructible_v&lt;T&gt; &amp;&amp; <w-br><wbr></w-br>is_convertible_v&lt;U&amp;&amp;, T&gt;</code> is <code>false</code>,
        the program is ill-formed.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="24" id="optional.object.observe.24">
    
    <pre><code><cxx-signature>template &lt;class U&gt; T value_or(U&amp;&amp; <var>v</var>) &amp;&amp;;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="25" id="optional.object.observe.25">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return bool(*this) ? <w-br><wbr></w-br>std::move(**this) : <w-br><wbr></w-br>static_cast&lt;T&gt;(std::forward&lt;U&gt;(<var>v</var>));</code></dd>
  </cxx-effects>
        <cxx-remarks para_num="26" id="optional.object.observe.26">
    
    <dt>Remarks:</dt><dd>If <code>is_move_constructible_v&lt;T&gt; &amp;&amp; <w-br><wbr></w-br>is_convertible_v&lt;U&amp;&amp;, T&gt;</code> is <code>false</code>,
        the program is ill-formed.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.inplace">
    

    <section>
      <header><span class="section-number">5.4</span> <h1 data-bookmark-label="5.4 In-place construction">In-place construction</h1> <span style="float:right"><a href="#optional.inplace">[optional.inplace]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.inplace.1">
    
    <pre><code><cxx-signature>struct in_place_t{};</cxx-signature><cxx-signature>constexpr in_place_t in_place{};</cxx-signature></code></pre>

    <dl>
      
      
      
    
    </dl>
  </cxx-function>

    <p para_num="2" id="optional.inplace.2">
      The struct <code>in_place_t</code> is an empty structure type used as a unique type to disambiguate constructor and function overloading.
      Specifically, <code>optional&lt;T&gt;</code> has a constructor with <code>in_place_t</code> as the first parameter followed by a parameter pack;
      this indicates that <code>T</code> should be constructed in-place 
(as if by a call to a placement new expression) with the forwarded pack 
expansion as arguments for the initialization of <code>T</code>.
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.nullopt">
    

    <section>
      <header><span class="section-number">5.5</span> <h1 data-bookmark-label="5.5 No-value state indicator">No-value state indicator</h1> <span style="float:right"><a href="#optional.nullopt">[optional.nullopt]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.nullopt.1">
    
    <pre><code><cxx-signature>struct nullopt_t{<em>see below</em>};</cxx-signature><cxx-signature>constexpr nullopt_t nullopt(<em>unspecified</em>);</cxx-signature></code></pre>

    <dl>
      
      
      
    
    </dl>
  </cxx-function>

    <p para_num="2" id="optional.nullopt.2">The struct <code>nullopt_t</code> is an empty structure type used as a unique type to indicate the state of not containing a value for <code>optional</code> objects.
    In particular, <code>optional&lt;T&gt;</code> has a constructor with <code>nullopt_t</code> as a single argument;
    this indicates that an optional object not containing a value shall be constructed.
    </p>

    <p para_num="3" id="optional.nullopt.3">Type <code>nullopt_t</code> shall not have a default constructor. It shall be a literal type. Constant <code>nullopt</code> shall be initialized with an argument of literal type.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.bad_optional_access">
    

    <section>
      <header><span class="section-number">5.6</span> <h1 data-bookmark-label="5.6 Class bad_optional_access">Class <code>bad_optional_access</code></h1> <span style="float:right"><a href="#optional.bad_optional_access">[optional.bad_optional_access]</a></span></header>
      
    

<pre><code>class bad_optional_access : public logic_error {
public:
  bad_optional_access();
};</code></pre>

    <p para_num="1" id="optional.bad_optional_access.1">The class <code>bad_optional_access</code>
 defines the type of objects thrown as exceptions to report the 
situation where an attempt is made to access the value of an optional 
object that does not contain a value.</p>

    <cxx-function para_num="2" id="optional.bad_optional_access.2">
    
    <pre><code><cxx-signature>bad_optional_access();</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="3" id="optional.bad_optional_access.3">
    
    <dt>Effects:</dt><dd>Constructs an object of class <code>bad_optional_access</code>.</dd>
  </cxx-effects>
      <cxx-postconditions para_num="4" id="optional.bad_optional_access.4">
    
    <dt>Postconditions:</dt><dd><code>what()</code> returns an implementation-defined NTBS.</dd>
  </cxx-postconditions>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.relops">
    

    <section>
      <header><span class="section-number">5.7</span> <h1 data-bookmark-label="5.7 Relational operators">Relational operators</h1> <span style="float:right"><a href="#optional.relops">[optional.relops]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.relops.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, const optional&lt;T&gt;&amp; <var>y</var>);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-requires para_num="2" id="optional.relops.2">
    
    <dt>Requires:</dt><dd><code>T</code> shall meet the requirements of <code>EqualityComparable</code>.</dd>
  </cxx-requires>
      <cxx-returns para_num="3" id="optional.relops.3">
    
    <dt>Returns:</dt><dd>If <code>bool(<var>x</var>) != bool(<var>y</var>)</code>, <code>false</code>; otherwise if <code>bool(<var>x</var>) == false</code>, <code>true</code>; otherwise <code>*<var>x</var> == *<var>y</var></code>.</dd>
  </cxx-returns>
      <cxx-remarks para_num="4" id="optional.relops.4">
    
    <dt>Remarks:</dt><dd>Specializations of this function template,
      for which <code>*<var>x</var> == *<var>y</var></code> is a core constant expression,
      shall be <code>constexpr</code> functions.</dd>
  </cxx-remarks>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="5" id="optional.relops.5">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="6" id="optional.relops.6">
    
    <dt>Returns:</dt><dd><code>!(x == y)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="7" id="optional.relops.7">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, const optional&lt;T&gt;&amp; <var>y</var>);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-requires para_num="8" id="optional.relops.8">
    
    <dt>Requires:</dt><dd><code>*<var>x</var> &lt; *<var>y</var></code> shall be well-formed
      and its result shall be convertible to <code>bool</code>.</dd>
  </cxx-requires>
      <cxx-returns para_num="9" id="optional.relops.9">
    
    <dt>Returns:</dt><dd>If <code>!<var>y</var></code>, <code>false</code>;
      otherwise, if <code>!<var>x</var></code>, <code>true</code>;
      otherwise <code>*<var>x</var> &lt; *<var>y</var></code>.</dd>
  </cxx-returns>
      <cxx-remarks para_num="10" id="optional.relops.10">
    
    <dt>Remarks:</dt><dd>Specializations of this function template,
      for which <code>*<var>x</var> &lt; *<var>y</var></code> is a core constant expression,
      shall be <code>constexpr</code> functions.</dd>
  </cxx-remarks>
    
    </dl>
  </cxx-function>


    <cxx-function para_num="11" id="optional.relops.11">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="12" id="optional.relops.12">
    
    <dt>Returns:</dt><dd><code>y &lt; x</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="13" id="optional.relops.13">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="14" id="optional.relops.14">
    
    <dt>Returns:</dt><dd><code>!(y &lt; x)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="15" id="optional.relops.15">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="16" id="optional.relops.16">
    
    <dt>Returns:</dt><dd><code>!(x &lt; y)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.nullops">
    

    <section>
      <header><span class="section-number">5.8</span> <h1 data-bookmark-label="5.8 Comparison with nullopt">Comparison with <code>nullopt</code></h1> <span style="float:right"><a href="#optional.nullops">[optional.nullops]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.nullops.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature><cxx-signature>template &lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      

      <cxx-returns para_num="2" id="optional.nullops.2">
    
    <dt>Returns:</dt><dd><code>!<var>x</var></code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="3" id="optional.nullops.3">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature><cxx-signature>template &lt;class T&gt; constexpr bool operator!=(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      

      <cxx-returns para_num="4" id="optional.nullops.4">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="5" id="optional.nullops.5">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="6" id="optional.nullops.6">
    
    <dt>Returns:</dt><dd><code>false</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="7" id="optional.nullops.7">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="8" id="optional.nullops.8">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="9" id="optional.nullops.9">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="10" id="optional.nullops.10">
    
    <dt>Returns:</dt><dd><code>!<var>x</var></code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="11" id="optional.nullops.11">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="12" id="optional.nullops.12">
    
    <dt>Returns:</dt><dd><code>true</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="13" id="optional.nullops.13">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="14" id="optional.nullops.14">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="15" id="optional.nullops.15">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="16" id="optional.nullops.16">
    
    <dt>Returns:</dt><dd><code>false</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="17" id="optional.nullops.17">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="18" id="optional.nullops.18">
    
    <dt>Returns:</dt><dd><code>true</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="19" id="optional.nullops.19">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="20" id="optional.nullops.20">
    
    <dt>Returns:</dt><dd><code>!<var>x</var></code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.comp_with_t">
    

    <section>
      <header><span class="section-number">5.9</span> <h1 data-bookmark-label="5.9 Comparison with T">Comparison with <code>T</code></h1> <span style="float:right"><a href="#optional.comp_with_t">[optional.comp_with_t]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.comp_with_t.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="2" id="optional.comp_with_t.2">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? *<var>x</var> == <var>v</var> : false</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="3" id="optional.comp_with_t.3">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="4" id="optional.comp_with_t.4">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? <var>v</var> == *<var>x</var> : false</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="5" id="optional.comp_with_t.5">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="6" id="optional.comp_with_t.6">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? !(*<var>x</var> == <var>v</var>) : true</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="7" id="optional.comp_with_t.7">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator!=(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="8" id="optional.comp_with_t.8">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? !(<var>v</var> == *<var>x</var>) : true</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="9" id="optional.comp_with_t.9">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="10" id="optional.comp_with_t.10">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? *<var>x</var> &lt; <var>v</var> : true</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="11" id="optional.comp_with_t.11">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; <var>x</var>);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="12" id="optional.comp_with_t.12">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? <var>v</var> &lt; *<var>x</var> : false</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="13" id="optional.comp_with_t.13">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="14" id="optional.comp_with_t.14">
    
    <dt>Returns:</dt><dd><code>!(<var>x</var> &gt; <var>v</var>)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="15" id="optional.comp_with_t.15">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;=(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="16" id="optional.comp_with_t.16">
    
    <dt>Returns:</dt><dd><code>!(<var>v</var> &gt; <var>x</var>)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="17" id="optional.comp_with_t.17">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="18" id="optional.comp_with_t.18">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? <var>v</var> &lt; *<var>x</var> : false</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="19" id="optional.comp_with_t.19">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="20" id="optional.comp_with_t.20">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? *<var>x</var> &lt; <var>v</var> : true</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="21" id="optional.comp_with_t.21">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="22" id="optional.comp_with_t.22">
    
    <dt>Returns:</dt><dd><code>!(<var>x</var> &lt; <var>v</var>)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="23" id="optional.comp_with_t.23">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;=(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="24" id="optional.comp_with_t.24">
    
    <dt>Returns:</dt><dd><code>!(<var>v</var> &lt; <var>x</var>)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.specalg">
    

    <section>
      <header><span class="section-number">5.10</span> <h1 data-bookmark-label="5.10 Specialized algorithms">Specialized algorithms</h1> <span style="float:right"><a href="#optional.specalg">[optional.specalg]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.specalg.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; <var>x</var>, optional&lt;T&gt;&amp; <var>y</var>) noexcept(noexcept(<var>x</var>.swap(<var>y</var>)));</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="2" id="optional.specalg.2">
    
    <dt>Effects:</dt><dd>Calls <code><var>x</var>.swap(<var>y</var>)</code>.</dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="3" id="optional.specalg.3">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr optional&lt;decay_t&lt;T&gt;&gt; make_optional(T&amp;&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="4" id="optional.specalg.4">
    
    <dt>Returns:</dt><dd><code>optional&lt;decay_t&lt;T&gt;&gt;(std::forward&lt;T&gt;(<var>v</var>))</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.hash">
    

    <section>
      <header><span class="section-number">5.11</span> <h1 data-bookmark-label="5.11 Hash support">Hash support</h1> <span style="float:right"><a href="#optional.hash">[optional.hash]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.hash.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; struct hash&lt;experimental::optional&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-requires para_num="2" id="optional.hash.2">
    
    <dt>Requires:</dt><dd>The template specialization <code>hash&lt;T&gt;</code> shall meet the requirements of class template <code>hash</code> (<cxx-ref in="cxx" to="unord.hash">C++14 <span title="unord.hash">§20.9.12</span></cxx-ref>).
      The template specialization <code>hash&lt;optional&lt;T&gt;&gt;</code> shall meet the requirements of class template <code>hash</code>.
      For an object <code><var>o</var></code> of type <code>optional&lt;T&gt;</code>, if <code>bool(<var>o</var>) == true</code>,
      <code>hash&lt;optional&lt;T&gt;&gt;()(<var>o</var>)</code> shall evaluate to the same value as <code>hash&lt;T&gt;()(*<var>o</var>)</code>;
      otherwise it evaluates to an unspecified value.</dd>
  </cxx-requires>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="any">
    

    <section>
      <header><span class="section-number">6</span> <h1 data-bookmark-label="6 Class any">Class <code>any</code></h1> <span style="float:right"><a href="#any">[any]</a></span></header>
      
  

  <p para_num="1" id="any.1">
    This section describes components that C++ programs may use to perform operations on objects of a discriminated type.
  </p>

  <p para_num="2" id="any.2">
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The discriminated type may contain values of different types but does not attempt conversion between them,
    i.e. <code>5</code> is held strictly as an <code>int</code> and is not implicitly convertible either to <code>"5"</code> or to <code>5.0</code>.
    This indifference to interpretation but awareness of type 
effectively allows safe, generic containers of single values, with no 
scope for surprises from ambiguous conversions.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
  </p>

  <cxx-section id="any.synop">
    

    <section>
      <header><span class="section-number">6.1</span> <h1 data-bookmark-label="6.1 Header &lt;experimental/any&gt; synopsis">Header &lt;experimental/any&gt; synopsis</h1> <span style="float:right"><a href="#any.synop">[any.synop]</a></span></header>
      
    

    <pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  class bad_any_cast : public bad_cast
  {
  public:
    virtual const char* what() const noexcept;
  };

  class any
  {
  public:
    <cxx-ref insynopsis="" to="any.cons">// <i><a title="any.cons" href="#any.cons">6.3.1</a>, any construct/destruct</i></cxx-ref>
    any() noexcept;

    any(const any&amp; other);
    any(any&amp;&amp; other) noexcept;

    template &lt;class ValueType&gt;
      any(ValueType&amp;&amp; value);

    ~any();

    <cxx-ref insynopsis="" to="any.assign">// <i><a title="any.assign" href="#any.assign">6.3.2</a>, any assignments</i></cxx-ref>
    any&amp; operator=(const any&amp; rhs);
    any&amp; operator=(any&amp;&amp; rhs) noexcept;

    template &lt;class ValueType&gt;
      any&amp; operator=(ValueType&amp;&amp; rhs);

    <cxx-ref insynopsis="" to="any.modifiers">// <i><a title="any.modifiers" href="#any.modifiers">6.3.3</a>, any modifiers</i></cxx-ref>
    void clear() noexcept;
    void swap(any&amp; rhs) noexcept;

    <cxx-ref insynopsis="" to="any.observers">// <i><a title="any.observers" href="#any.observers">6.3.4</a>, any observers</i></cxx-ref>
    bool empty() const noexcept;
    const type_info&amp; type() const noexcept;
  };

  <cxx-ref insynopsis="" to="any.nonmembers">// <i><a title="any.nonmembers" href="#any.nonmembers">6.4</a>, Non-member functions</i></cxx-ref>
  void swap(any&amp; x, any&amp; y) noexcept;

  template&lt;class ValueType&gt;
    ValueType any_cast(const any&amp; operand);
  template&lt;class ValueType&gt;
    ValueType any_cast(any&amp; operand);
  template&lt;class ValueType&gt;
    ValueType any_cast(any&amp;&amp; operand);

  template&lt;class ValueType&gt;
    const ValueType* any_cast(const any* operand) noexcept;
  template&lt;class ValueType&gt;
    ValueType* any_cast(any* operand) noexcept;

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
  
    </section>
  </cxx-section>

  <cxx-section id="any.bad_any_cast">
    

    <section>
      <header><span class="section-number">6.2</span> <h1 data-bookmark-label="6.2 Class bad_any_cast">Class <code>bad_any_cast</code></h1> <span style="float:right"><a href="#any.bad_any_cast">[any.bad_any_cast]</a></span></header>
      
    
    <p para_num="1" id="any.bad_any_cast.1">
      Objects of type <code>bad_any_cast</code> are thrown by a failed <code> any_cast</code>.
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="any.class">
    

    <section>
      <header><span class="section-number">6.3</span> <h1 data-bookmark-label="6.3 Class any">Class <code>any</code></h1> <span style="float:right"><a href="#any.class">[any.class]</a></span></header>
      
    

    <p para_num="1" id="any.class.1">
      An object of class <code>any</code> stores an instance of any type that satisfies the constructor requirements or is empty,
      and this is referred to as the <dfn>state</dfn> of the class <code>any</code> object.
      The stored instance is called the <dfn>contained object</dfn>.
      Two states are equivalent if they are either both empty or if both
 are not empty and if the contained objects are equivalent.
    </p>

    <p para_num="2" id="any.class.2">
      The non-member <code>any_cast</code> functions provide type-safe access to the contained object.
    </p>

    <p para_num="3" id="any.class.3">
      Implementations should avoid the use of dynamically allocated memory for a small contained object.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    where the object constructed is holding only an int.
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      Such small-object optimization shall only be applied to types <code>T</code> for which
      <code>is_nothrow_move_constructible_v&lt;T&gt;</code> is true.
    </p>

    <cxx-section id="any.cons">
    

    <section>
      <header><span class="section-number">6.3.1</span> <h1 data-bookmark-label="6.3.1 any construct/destruct"><code>any</code> construct/destruct</h1> <span style="float:right"><a href="#any.cons">[any.cons]</a></span></header>
      
      

      <cxx-function para_num="1" id="any.cons.1">
    
    <pre><code><cxx-signature>any() noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-postconditions para_num="2" id="any.cons.2">
    
    <dt>Postconditions:</dt><dd><code>this-&gt;empty()</code>.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="any.cons.3">
    
    <pre><code><cxx-signature>any(const any&amp; other);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="4" id="any.cons.4">
    
    <dt>Effects:</dt><dd>Constructs an object of type <code>any</code> with an equivalent state as <code>other</code>.</dd>
  </cxx-effects>
        <cxx-throws para_num="5" id="any.cons.5">
    
    <dt>Throws:</dt><dd>Any exceptions arising from calling the selected constructor of the contained object.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="any.cons.6">
    
    <pre><code><cxx-signature>any(any&amp;&amp; other) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="7" id="any.cons.7">
    
    <dt>Effects:</dt><dd>Constructs an object of type <code>any</code> with a state equivalent to the original state of <code>other</code>.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="8" id="any.cons.8">
    
    <dt>Postconditions:</dt><dd><code>other</code> is left in a valid but otherwise unspecified state.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="any.cons.9">
    
    <pre><code><cxx-signature>template&lt;class ValueType&gt;
any(ValueType&amp;&amp; value);</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="10" id="any.cons.10">Let <code>T</code> be equal to <code>decay_t&lt;ValueType&gt;</code>.</p>
        <cxx-requires para_num="11" id="any.cons.11">
    
    <dt>Requires:</dt><dd><code>T</code> shall satisfy the <code>CopyConstructible</code> requirements.
        If <code>is_copy_constructible_v&lt;T&gt;</code> is false, the program is ill-formed.</dd>
  </cxx-requires>
        <cxx-effects para_num="12" id="any.cons.12">
    
    <dt>Effects:</dt><dd>Constructs an object of type <code>any</code> that contains an object of type <code>T</code> direct-initialized with <code>std::forward&lt;ValueType&gt;(value)</code>.</dd>
  </cxx-effects>
        <cxx-remarks para_num="13" id="any.cons.13">
    
    <dt>Remarks:</dt><dd>This constructor shall not participate in overload resolution if <code>decay_t&lt;ValueType&gt;</code> is the same type as <code>any</code>.</dd>
  </cxx-remarks>
        <cxx-throws para_num="14" id="any.cons.14">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="15" id="any.cons.15">
    
    <pre><code><cxx-signature>~any();</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="16" id="any.cons.16">
    
    <dt>Effects:</dt><dd><code>clear()</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="any.assign">
    

    <section>
      <header><span class="section-number">6.3.2</span> <h1 data-bookmark-label="6.3.2 any assignments"><code>any</code> assignments</h1> <span style="float:right"><a href="#any.assign">[any.assign]</a></span></header>
      
      

      <cxx-function para_num="1" id="any.assign.1">
    
    <pre><code><cxx-signature>any&amp; operator=(const any&amp; rhs);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="any.assign.2">
    
    <dt>Effects:</dt><dd><code>any(rhs).swap(*this)</code>.
        No effects if an exception is thrown.</dd>
  </cxx-effects>
        <cxx-returns para_num="3" id="any.assign.3">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
        <cxx-throws para_num="4" id="any.assign.4">
    
    <dt>Throws:</dt><dd>Any exceptions arising from the copy constructor of the contained object.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="any.assign.5">
    
    <pre><code><cxx-signature>any&amp; operator=(any&amp;&amp; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="6" id="any.assign.6">
    
    <dt>Effects:</dt><dd><code>any(std::move(rhs)).swap(*this)</code>.</dd>
  </cxx-effects>
        <cxx-returns para_num="7" id="any.assign.7">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
        <cxx-postconditions para_num="8" id="any.assign.8">
    
    <dt>Postconditions:</dt><dd>The state of <code>*this</code> is equivalent to the original state of <code>rhs</code>
        and <code>rhs</code> is left in a valid but otherwise unspecified state.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="any.assign.9">
    
    <pre><code><cxx-signature>template&lt;class ValueType&gt;
any&amp; operator=(ValueType&amp;&amp; rhs);</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="10" id="any.assign.10">Let <code>T</code> be equal to <code>decay_t&lt;ValueType&gt;</code>.</p>
        <cxx-requires para_num="11" id="any.assign.11">
    
    <dt>Requires:</dt><dd><code>T</code> shall satisfy the <code>CopyConstructible</code> requirements.
        If <code>is_copy_constructible_v&lt;T&gt;</code> is false, the program is ill-formed.</dd>
  </cxx-requires>
        <cxx-effects para_num="12" id="any.assign.12">
    
    <dt>Effects:</dt><dd>Constructs an object <code>tmp</code> of type <code>any</code> that contains an object of type <code>T</code> direct-initialized with <code>std::forward&lt;ValueType&gt;(rhs)</code>, and <code>tmp.swap(*this)</code>.
        No effects if an exception is thrown.</dd>
  </cxx-effects>
        <cxx-returns para_num="13" id="any.assign.13">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="14" id="any.assign.14">
    
    <dt>Remarks:</dt><dd> This operator shall not participate in overload resolution if <code>decay_t&lt;ValueType&gt;</code> is the same type as <code>any</code>.</dd>
  </cxx-remarks>
        <cxx-throws para_num="15" id="any.assign.15">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="any.modifiers">
    

    <section>
      <header><span class="section-number">6.3.3</span> <h1 data-bookmark-label="6.3.3 any modifiers"><code>any</code> modifiers</h1> <span style="float:right"><a href="#any.modifiers">[any.modifiers]</a></span></header>
      
      

      <cxx-function para_num="1" id="any.modifiers.1">
    
    <pre><code><cxx-signature>void clear() noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="any.modifiers.2">
    
    <dt>Effects:</dt><dd>If not empty, destroys the contained object.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="3" id="any.modifiers.3">
    
    <dt>Postconditions:</dt><dd><code>empty() == true</code>.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="any.modifiers.4">
    
    <pre><code><cxx-signature>void swap(any&amp; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="5" id="any.modifiers.5">
    
    <dt>Effects:</dt><dd>Exchange the states of <code>*this</code> and <code> rhs</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="any.observers">
    

    <section>
      <header><span class="section-number">6.3.4</span> <h1 data-bookmark-label="6.3.4 any observers"><code>any</code> observers</h1> <span style="float:right"><a href="#any.observers">[any.observers]</a></span></header>
      
      

      <cxx-function para_num="1" id="any.observers.1">
    
    <pre><code><cxx-signature>bool empty() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="any.observers.2">
    
    <dt>Returns:</dt><dd><code>true</code> if <code>*this</code> has no contained object, otherwise <code> false</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="any.observers.3">
    
    <pre><code><cxx-signature>const type_info&amp; type() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="4" id="any.observers.4">
    
    <dt>Returns:</dt><dd>If <code>*this</code> has a contained object of type T, <code>typeid(T)</code>;
        otherwise <code>typeid(void)</code>.</dd>
  </cxx-returns>
        <p para_num="5" id="any.observers.5"><cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Useful for querying against types known either at compile time or only at runtime.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="any.nonmembers">
    

    <section>
      <header><span class="section-number">6.4</span> <h1 data-bookmark-label="6.4 Non-member functions"><a name="Non-member">Non-member</a> functions</h1> <span style="float:right"><a href="#any.nonmembers">[any.nonmembers]</a></span></header>
      
    

    <cxx-function para_num="1" id="any.nonmembers.1">
    
    <pre><code><cxx-signature>void swap(any&amp; x, any&amp; y) noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="2" id="any.nonmembers.2">
    
    <dt>Effects:</dt><dd><code>x.swap(y)</code>.</dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="3" id="any.nonmembers.3">
    
    <pre><code><cxx-signature>template&lt;class ValueType&gt;
ValueType any_cast(const any&amp; operand);</cxx-signature><cxx-signature>template&lt;class ValueType&gt;
ValueType any_cast(any&amp; operand);</cxx-signature><cxx-signature>template&lt;class ValueType&gt;
ValueType any_cast(any&amp;&amp; operand);</cxx-signature></code></pre>

    <dl>
      
      
      
      

      <cxx-requires para_num="4" id="any.nonmembers.4">
    
    <dt>Requires:</dt><dd><code>is_reference_v&lt;ValueType&gt;</code> is true or <code>is_copy_constructible_v&lt;ValueType&gt;</code> is true.
      Otherwise the program is ill-formed.</dd>
  </cxx-requires>
      <cxx-returns para_num="5" id="any.nonmembers.5">
    
    <dt>Returns:</dt><dd>For the first form, <code>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</code>.
      For the second and third forms, <code>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</code>.</dd>
  </cxx-returns>
      <cxx-throws para_num="6" id="any.nonmembers.6">
    
    <dt>Throws:</dt><dd><code>bad_any_cast</code> if <code>operand.type() != typeid(remove_reference_t&lt;ValueType&gt;)</code>.</dd>
  </cxx-throws>
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <pre><code>any x(5);                                   // x holds int
assert(any_cast&lt;int&gt;(x) == 5);              // cast to value
any_cast&lt;int&amp;&gt;(x) = 10;                     // cast to reference
assert(any_cast&lt;int&gt;(x) == 10);

x = "Meow";                                 // x holds const char*
assert(strcmp(any_cast&lt;const char*&gt;(x), "Meow") == 0);
any_cast&lt;const char*&amp;&gt;(x) = "Harry";
assert(strcmp(any_cast&lt;const char*&gt;(x), "Harry") == 0);

x = string("Meow");                         // x holds string
string s, s2("Jane");
s = move(any_cast&lt;string&amp;&gt;(x));             // move from any
assert(s == "Meow");
any_cast&lt;string&amp;&gt;(x) = move(s2);            // move to any
assert(any_cast&lt;const string&amp;&gt;(x) == "Jane");

string cat("Meow");
const any y(cat);                           // const y holds string
assert(any_cast&lt;const string&amp;&gt;(y) == cat);

any_cast&lt;string&amp;&gt;(y);                       // error; cannot
                                            //  any_cast away const</code></pre>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="7" id="any.nonmembers.7">
    
    <pre><code><cxx-signature>template&lt;class ValueType&gt;
const ValueType* any_cast(const any* operand) noexcept;</cxx-signature><cxx-signature>template&lt;class ValueType&gt;
ValueType* any_cast(any* operand) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      

      <cxx-returns para_num="8" id="any.nonmembers.8">
    
    <dt>Returns:</dt><dd>If <code>operand != nullptr &amp;&amp; <w-br><wbr></w-br>operand-&gt;type() == typeid(ValueType)</code>,
      a pointer to the object contained by <code>operand</code>,
      otherwise <code>nullptr</code>.</dd>
  </cxx-returns>
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <pre><code>bool is_string(const any&amp; operand) {
  return any_cast&lt;string&gt;(&amp;operand) != nullptr;
}</code></pre>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="string.view">
    

    <section>
      <header><span class="section-number">7</span> <h1 data-bookmark-label="7 string_view"><code>string_view</code></h1> <span style="float:right"><a href="#string.view">[string.view]</a></span></header>
      
  

  <p para_num="1" id="string.view.1">
    The class template <code>basic_string_view</code> describes an object that can refer to a constant contiguous sequence of char-like (<cxx-ref in="cxx" to="strings.general">C++14 <span title="strings.general">§21.1</span></cxx-ref>) objects with the first element of the sequence at position zero.
    In the rest of this section, the type of the char-like objects held in a <code>basic_string_view</code> object is designated by <code>charT</code>.
  </p>

  <p para_num="2" id="string.view.2">
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The library provides implicit conversions from <code>const charT*</code> and <code>std::basic_string&lt;charT, ...&gt;</code> to <code>std::basic_string_view&lt;charT, ...&gt;</code> so that user code can accept just <code>std::basic_string_view&lt;charT&gt;</code> as a non-templated parameter wherever a sequence of characters is expected.
    User-defined types should define their own implicit conversions to <code>std::basic_string_view</code> in order to interoperate with these functions.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
  </p>

  <p para_num="3" id="string.view.3">
    The complexity of <code>basic_string_view</code> member functions is O(1) unless otherwise specified.
  </p>

  <cxx-section id="string.view.synop">
    

    <section>
      <header><span class="section-number">7.1</span> <h1 data-bookmark-label="7.1 Header &lt;experimental/string_view&gt; synopsis">Header <code>&lt;experimental/string_view&gt;</code> synopsis</h1> <span style="float:right"><a href="#string.view.synop">[string.view.synop]</a></span></header>
      
    

    <pre><code>namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    <cxx-ref insynopsis="" to="string.view.template">// <i><a title="string.view.template" href="#string.view.template">7.2</a>, Class template basic_string_view</i></cxx-ref>
    template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
        class basic_string_view;

    <cxx-ref insynopsis="" to="string.view.comparison">// <i><a title="string.view.comparison" href="#string.view.comparison">7.9</a>, basic_string_view non-member comparison functions</i></cxx-ref>
    template&lt;class charT, class traits&gt;
    constexpr bool operator==(basic_string_view&lt;charT, traits&gt; x,
                              basic_string_view&lt;charT, traits&gt; y) noexcept;
    template&lt;class charT, class traits&gt;
    constexpr bool operator!=(basic_string_view&lt;charT, traits&gt; x,
                              basic_string_view&lt;charT, traits&gt; y) noexcept;
    template&lt;class charT, class traits&gt;
    constexpr bool operator&lt; (basic_string_view&lt;charT, traits&gt; x,
                                 basic_string_view&lt;charT, traits&gt; y) noexcept;
    template&lt;class charT, class traits&gt;
    constexpr bool operator&gt; (basic_string_view&lt;charT, traits&gt; x,
                              basic_string_view&lt;charT, traits&gt; y) noexcept;
    template&lt;class charT, class traits&gt;
    constexpr bool operator&lt;=(basic_string_view&lt;charT, traits&gt; x,
                                 basic_string_view&lt;charT, traits&gt; y) noexcept;
    template&lt;class charT, class traits&gt;
    constexpr bool operator&gt;=(basic_string_view&lt;charT, traits&gt; x,
                              basic_string_view&lt;charT, traits&gt; y) noexcept;
    // <i>see below</i>, sufficient additional overloads of comparison functions

    <cxx-ref insynopsis="" to="string.view.io">// <i><a title="string.view.io" href="#string.view.io">7.10</a>, Inserters and extractors</i></cxx-ref>
    template&lt;class charT, class traits&gt;
      basic_ostream&lt;charT, traits&gt;&amp;
        operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
                   basic_string_view&lt;charT, traits&gt; str);

    // basic_string_view typedef names
    typedef basic_string_view&lt;char&gt; string_view;
    typedef basic_string_view&lt;char16_t&gt; u16string_view;
    typedef basic_string_view&lt;char32_t&gt; u32string_view;
    typedef basic_string_view&lt;wchar_t&gt; wstring_view;

  }  // namespace fundamentals_v2
  }  // namespace experimental

  <cxx-ref insynopsis="" to="string.view.hash">// <i><a title="string.view.hash" href="#string.view.hash">7.11</a>, Hash support</i></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;&gt; struct hash&lt;experimental::string_view&gt;;
  template &lt;&gt; struct hash&lt;experimental::u16string_view&gt;;
  template &lt;&gt; struct hash&lt;experimental::u32string_view&gt;;
  template &lt;&gt; struct hash&lt;experimental::wstring_view&gt;;

}  // namespace std</code></pre>

    <p para_num="1" id="string.view.synop.1">
      The function templates defined in <cxx-ref in="cxx" to="utility.swap">C++14 <span title="utility.swap">§20.2.2</span></cxx-ref> and <cxx-ref in="cxx" to="iterator.range">C++14 <span title="iterator.range">§24.7</span></cxx-ref> are available when <code>&lt;experimental/string_view&gt;</code> is included.
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.template">
    

    <section>
      <header><span class="section-number">7.2</span> <h1 data-bookmark-label="7.2 Class template basic_string_view">Class template <code>basic_string_view</code></h1> <span style="float:right"><a href="#string.view.template">[string.view.template]</a></span></header>
      
    

    <pre><code>template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
class basic_string_view {
  public:
  // types
  typedef traits traits_type;
  typedef charT value_type;
  typedef charT* pointer;
  typedef const charT* const_pointer;
  typedef charT&amp; reference;
  typedef const charT&amp; const_reference;
  typedef <var>implementation-defined</var> const_iterator; // See <cxx-ref to="string.view.iterators"><a title="string.view.iterators" href="#string.view.iterators">7.4</a></cxx-ref>
  typedef const_iterator iterator;<cxx-footnote><!--
    Be sure not to introduce whitespace here, as it appears around the footnote.
  --><sup id="footnote-call-1"><a href="#footnote-body-1">1</a></sup><aside class="footnote" id="footnote-body-1"><span class="marker"><a href="#footnote-call-1">1</a>) </span>Because <code>basic_string_view</code> refers to a constant sequence, <code>iterator</code> and <code>const_iterator</code> are the same type.</aside></cxx-footnote>
  typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
  typedef const_reverse_iterator reverse_iterator;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  static constexpr size_type npos = size_type(-1);

  <cxx-ref insynopsis="" to="string.view.cons">// <i><a title="string.view.cons" href="#string.view.cons">7.3</a>, basic_string_view constructors and assignment operators</i></cxx-ref>
  constexpr basic_string_view() noexcept;
  constexpr basic_string_view(const basic_string_view&amp;) noexcept = default;
  basic_string_view&amp; operator=(const basic_string_view&amp;) noexcept = default;
  template&lt;class Allocator&gt;
  basic_string_view(const basic_string&lt;charT, traits, Allocator&gt;&amp; str) noexcept;
  constexpr basic_string_view(const charT* str);
  constexpr basic_string_view(const charT* str, size_type len);

  <cxx-ref insynopsis="" to="string.view.iterators">// <i><a title="string.view.iterators" href="#string.view.iterators">7.4</a>, basic_string_view iterator support</i></cxx-ref>
  constexpr const_iterator begin() const noexcept;
  constexpr const_iterator end() const noexcept;
  constexpr const_iterator cbegin() const noexcept;
  constexpr const_iterator cend() const noexcept;
  const_reverse_iterator rbegin() const noexcept;
  const_reverse_iterator rend() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  const_reverse_iterator crend() const noexcept;

  <cxx-ref insynopsis="" to="string.view.capacity">// <i><a title="string.view.capacity" href="#string.view.capacity">7.5</a>, basic_string_view capacity</i></cxx-ref>
  constexpr size_type size() const noexcept;
  constexpr size_type length() const noexcept;
  constexpr size_type max_size() const noexcept;
  constexpr bool empty() const noexcept;

  <cxx-ref insynopsis="" to="string.view.access">// <i><a title="string.view.access" href="#string.view.access">7.6</a>, basic_string_view element access</i></cxx-ref>
  constexpr const_reference operator[](size_type pos) const;
  constexpr const_reference at(size_type pos) const;
  constexpr const_reference front() const;
  constexpr const_reference back() const;
  constexpr const_pointer data() const noexcept;

  <cxx-ref insynopsis="" to="string.view.modifiers">// <i><a title="string.view.modifiers" href="#string.view.modifiers">7.7</a>, basic_string_view modifiers</i></cxx-ref>
  constexpr void remove_prefix(size_type n);
  constexpr void remove_suffix(size_type n);
  constexpr void swap(basic_string_view&amp; s) noexcept;

  <cxx-ref insynopsis="" to="string.view.ops">// <i><a title="string.view.ops" href="#string.view.ops">7.8</a>, basic_string_view string operations</i></cxx-ref>
  template&lt;class Allocator&gt;
  explicit operator basic_string&lt;charT, traits, Allocator&gt;() const;
  template&lt;class Allocator = allocator&lt;charT&gt; &gt;
  basic_string&lt;charT, traits, Allocator&gt; to_string(
    const Allocator&amp; a = Allocator()) const;

  size_type copy(charT* s, size_type n, size_type pos = 0) const;

  constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;
  constexpr int compare(basic_string_view s) const noexcept;
  constexpr int compare(size_type pos1, size_type n1, basic_string_view s) const;
  constexpr int compare(size_type pos1, size_type n1,
                        basic_string_view s, size_type pos2, size_type n2) const;
  constexpr int compare(const charT* s) const;
  constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
  constexpr int compare(size_type pos1, size_type n1,
                        const charT* s, size_type n2) const;
  constexpr size_type find(basic_string_view s, size_type pos = 0) const noexcept;
  constexpr size_type find(charT c, size_type pos = 0) const noexcept;
  constexpr size_type find(const charT* s, size_type pos, size_type n) const;
  constexpr size_type find(const charT* s, size_type pos = 0) const;
  constexpr size_type rfind(basic_string_view s, size_type pos = npos) const noexcept;
  constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;
  constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;
  constexpr size_type rfind(const charT* s, size_type pos = npos) const;
  constexpr size_type find_first_of(basic_string_view s, size_type pos = 0) const noexcept;
  constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
  constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;
  constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;
  constexpr size_type find_last_of(basic_string_view s, size_type pos = npos) const noexcept;
  constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;
  constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;
  constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;
  constexpr size_type find_first_not_of(basic_string_view s, size_type pos = 0) const noexcept;
  constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
  constexpr size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
  constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;
  constexpr size_type find_last_not_of(basic_string_view s, size_type pos = npos) const noexcept;
  constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
  constexpr size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;
  constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;

 private:
  const_pointer data_;  // <em>exposition only</em>
  size_type     size_;  // <em>exposition only</em>
};</code></pre>

    <p para_num="1" id="string.view.template.1">
      In every specialization <code>basic_string_view&lt;charT, traits&gt;</code>, the type <code>traits</code> shall satisfy the character traits requirements (<cxx-ref in="cxx" to="char.traits">C++14 <span title="char.traits">§21.2</span></cxx-ref>),
      and the type <code>traits::char_type</code> shall name the same type as <code>charT</code>.
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.cons">
    

    <section>
      <header><span class="section-number">7.3</span> <h1 data-bookmark-label="7.3 basic_string_view constructors and assignment operators"><code>basic_string_view</code> constructors and assignment operators</h1> <span style="float:right"><a href="#string.view.cons">[string.view.cons]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.cons.1">
    
    <pre><code><cxx-signature>constexpr basic_string_view() noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="2" id="string.view.cons.2">
    
    <dt>Effects:</dt><dd>Constructs an empty <code>basic_string_view</code>.</dd>
  </cxx-effects>
      <cxx-postconditions para_num="3" id="string.view.cons.3">
    
    <dt>Postconditions:</dt><dd><code>size_ == 0</code> and <code>data_ == nullptr</code>.</dd>
  </cxx-postconditions>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="4" id="string.view.cons.4">
    
    <pre><code><cxx-signature>template&lt;class Allocator&gt;
basic_string_view(const basic_string&lt;charT, traits, Allocator&gt;&amp; str) noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="5" id="string.view.cons.5">
    
    <dt>Effects:</dt><dd>Constructs a <code>basic_string_view</code>, with the postconditions in <cxx-ref to="tab:string.view.ctr.1"><a title="tab:string.view.ctr.1" href="#tab:string.view.ctr.1">Table 8</a></cxx-ref>.</dd>
  </cxx-effects>
      <table is="cxx-table" id="tab:string.view.ctr.1">
    

    <caption>Table 8 — <wbr><span><code>basic_string_view(const basic_string&amp;)</code> effects</span></caption>
    
        
        <tbody><tr><th>Element</th><th>Value</th></tr>
        <tr><td><code>data_</code></td><td><code>str.data()</code></td></tr>
        <tr><td><code>size_</code></td><td><code>str.size()</code></td></tr>
      </tbody>
  </table>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="6" id="string.view.cons.6">
    
    <pre><code><cxx-signature>constexpr basic_string_view(const charT* str);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-requires para_num="7" id="string.view.cons.7">
    
    <dt>Requires:</dt><dd><cxx-range begin="str" end="str + traits::length(str)">[<code>str</code>, <code>str + traits::length(str)</code>)</cxx-range> is a valid range.</dd>
  </cxx-requires>
      <cxx-effects para_num="8" id="string.view.cons.8">
    
    <dt>Effects:</dt><dd>Constructs a <code>basic_string_view</code>, with the postconditions
      in <cxx-ref to="tab:string.view.ctr.2"><a title="tab:string.view.ctr.2" href="#tab:string.view.ctr.2">Table 9</a></cxx-ref>.</dd>
  </cxx-effects>

      <table is="cxx-table" id="tab:string.view.ctr.2">
    

    <caption>Table 9 — <wbr><span><code>basic_string_view(const charT*)</code> effects</span></caption>
    
      <tbody><tr><th>Element</th><th>Value</th></tr>
      <tr><td><code>data_</code></td><td><code>str</code></td></tr>
      <tr><td><code>size_</code></td><td><code>traits::length(str)</code></td></tr>
      </tbody>
  </table>

      <cxx-complexity para_num="9" id="string.view.cons.9">
    
    <dt>Complexity:</dt><dd>O(<code>traits::length(str)</code>)</dd>
  </cxx-complexity>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="10" id="string.view.cons.10">
    
    <pre><code><cxx-signature>constexpr basic_string_view(const charT* str, size_type len);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-requires para_num="11" id="string.view.cons.11">
    
    <dt>Requires:</dt><dd><cxx-range begin="str" end="str + len">[<code>str</code>, <code>str + len</code>)</cxx-range> is a valid range.</dd>
  </cxx-requires>
      <cxx-effects para_num="12" id="string.view.cons.12">
    
    <dt>Effects:</dt><dd>Constructs a <code>basic_string_view</code>, with the postconditions in <cxx-ref to="tab:string.view.ctr.3"><a title="tab:string.view.ctr.3" href="#tab:string.view.ctr.3">Table 10</a></cxx-ref>.</dd>
  </cxx-effects>
      <table is="cxx-table" id="tab:string.view.ctr.3">
    

    <caption>Table 10 — <wbr><span><code>basic_string_view(const charT*, size_type)</code> effects</span></caption>
    
        <tbody><tr><th>Element</th><th>Value</th></tr>
        <tr><td><code>data_</code></td><td><code>str</code></td></tr>
        <tr><td><code>size_</code></td><td><code>len</code></td></tr>
      </tbody>
  </table>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.iterators">
    

    <section>
      <header><span class="section-number">7.4</span> <h1 data-bookmark-label="7.4 basic_string_view iterator support"><code>basic_string_view</code> iterator support</h1> <span style="float:right"><a href="#string.view.iterators">[string.view.iterators]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.iterators.1">
    
    <pre><code><cxx-signature>typedef <var>implementation-defined</var> const_iterator;</cxx-signature></code></pre>

    <dl>
      
      

      <p para_num="2" id="string.view.iterators.2">
        A constant random-access iterator type such that, for a <code>const_iterator it</code>, if <code>&amp;*(it+N)</code> is valid, then it is equal to <code>(&amp;*it)+N</code>.
      </p>
      <p para_num="3" id="string.view.iterators.3">
        For a <code>basic_string_view str</code>, any operation that invalidates a pointer in the range <cxx-range begin="str.data()" end="str.data()+str.size()">[<code>str.data()</code>, <code>str.data()+str.size()</code>)</cxx-range> invalidates pointers, iterators, and references returned from <code>str</code>'s methods.
      </p>
      <p para_num="4" id="string.view.iterators.4">
        All requirements on container iterators (<cxx-ref in="cxx" to="container.requirements">C++14 <span title="container.requirements">§23.2</span></cxx-ref>) apply to <code>basic_string_view::const_iterator</code> as well.
      </p>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="5" id="string.view.iterators.5">
    
    <pre><code><cxx-signature>constexpr const_iterator begin() const noexcept;</cxx-signature><cxx-signature>constexpr const_iterator cbegin() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      
      <cxx-returns para_num="6" id="string.view.iterators.6">
    
    <dt>Returns:</dt><dd>An iterator such that <code>&amp;*begin() == data_</code> if <code>!empty()</code>,
      or else an unspecified value such that <cxx-range begin="begin()" end="end()">[<code>begin()</code>, <code>end()</code>)</cxx-range> is a valid range.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="7" id="string.view.iterators.7">
    
    <pre><code><cxx-signature>constexpr const_iterator end() const noexcept;</cxx-signature><cxx-signature>constexpr const_iterator cend() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      

      <cxx-returns para_num="8" id="string.view.iterators.8">
    
    <dt>Returns:</dt><dd> <code>begin() + size()</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="9" id="string.view.iterators.9">
    
    <pre><code><cxx-signature>const_reverse_iterator rbegin() const noexcept;</cxx-signature><cxx-signature>const_reverse_iterator crbegin() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      

      <cxx-returns para_num="10" id="string.view.iterators.10">
    
    <dt>Returns:</dt><dd> <code>const_reverse_iterator(end())</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="11" id="string.view.iterators.11">
    
    <pre><code><cxx-signature>const_reverse_iterator rend() const noexcept;</cxx-signature><cxx-signature>const_reverse_iterator crend() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      

      <cxx-returns para_num="12" id="string.view.iterators.12">
    
    <dt>Returns:</dt><dd><code>const_reverse_iterator(begin())</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.capacity">
    

    <section>
      <header><span class="section-number">7.5</span> <h1 data-bookmark-label="7.5 basic_string_view capacity"><code>basic_string_view</code> capacity</h1> <span style="float:right"><a href="#string.view.capacity">[string.view.capacity]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.capacity.1">
    
    <pre><code><cxx-signature>constexpr size_type size() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="2" id="string.view.capacity.2">
    
    <dt>Returns:</dt><dd><code>size_</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="3" id="string.view.capacity.3">
    
    <pre><code><cxx-signature>constexpr size_type length() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="4" id="string.view.capacity.4">
    
    <dt>Returns:</dt><dd><code>size_</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="5" id="string.view.capacity.5">
    
    <pre><code><cxx-signature>constexpr size_type max_size() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="6" id="string.view.capacity.6">
    
    <dt>Returns:</dt><dd>The largest possible number of char-like objects that can be referred to by a <code>basic_string_view</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="7" id="string.view.capacity.7">
    
    <pre><code><cxx-signature>constexpr bool empty() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="8" id="string.view.capacity.8">
    
    <dt>Returns:</dt><dd><code>size_ == 0</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.access">
    

    <section>
      <header><span class="section-number">7.6</span> <h1 data-bookmark-label="7.6 basic_string_view element access"><code>basic_string_view</code> element access</h1> <span style="float:right"><a href="#string.view.access">[string.view.access]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.access.1">
    
    <pre><code><cxx-signature>constexpr const_reference operator[](size_type pos) const;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-requires para_num="2" id="string.view.access.2">
    
    <dt>Requires:</dt><dd><code>pos &lt; size()</code>.</dd>
  </cxx-requires>
      <cxx-returns para_num="3" id="string.view.access.3">
    
    <dt>Returns:</dt><dd><code>data_[pos]</code>.</dd>
  </cxx-returns>
      <cxx-throws para_num="4" id="string.view.access.4">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
      <p para_num="5" id="string.view.access.5"><cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Unlike <code>basic_string::operator[]</code>,
        <code>basic_string_view::operator[](size())</code> has undefined behavior instead of returning <code>charT()</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="6" id="string.view.access.6">
    
    <pre><code><cxx-signature>constexpr const_reference at(size_type pos) const;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-throws para_num="7" id="string.view.access.7">
    
    <dt>Throws:</dt><dd><code>out_of_range</code> if <code>pos &gt;= size()</code>.</dd>
  </cxx-throws>
      <cxx-returns para_num="8" id="string.view.access.8">
    
    <dt>Returns:</dt><dd><code>data_[pos]</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="9" id="string.view.access.9">
    
    <pre><code><cxx-signature>constexpr const_reference front() const;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-requires para_num="10" id="string.view.access.10">
    
    <dt>Requires:</dt><dd><code>!empty()</code></dd>
  </cxx-requires>
      <cxx-returns para_num="11" id="string.view.access.11">
    
    <dt>Returns:</dt><dd><code>data_[0]</code>.</dd>
  </cxx-returns>
      <cxx-throws para_num="12" id="string.view.access.12">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="13" id="string.view.access.13">
    
    <pre><code><cxx-signature>constexpr const_reference back() const;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-requires para_num="14" id="string.view.access.14">
    
    <dt>Requires:</dt><dd><code>!empty()</code></dd>
  </cxx-requires>
      <cxx-returns para_num="15" id="string.view.access.15">
    
    <dt>Returns:</dt><dd><code>data_[size() - 1]</code>.</dd>
  </cxx-returns>
      <cxx-throws para_num="16" id="string.view.access.16">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="17" id="string.view.access.17">
    
    <pre><code><cxx-signature>constexpr const_pointer data() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="18" id="string.view.access.18">
    
    <dt>Returns:</dt><dd><code>data_</code>.</dd>
  </cxx-returns>
      <p para_num="19" id="string.view.access.19"><cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Unlike <code>basic_string::data()</code> and string literals,
      <code>data()</code> may return a pointer to a buffer that is not null-terminated.
      Therefore it is typically a mistake to pass <code>data()</code> to a routine that takes just a <code>const charT*</code> and expects a null-terminated string.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.modifiers">
    

    <section>
      <header><span class="section-number">7.7</span> <h1 data-bookmark-label="7.7 basic_string_view modifiers"><code>basic_string_view</code> modifiers</h1> <span style="float:right"><a href="#string.view.modifiers">[string.view.modifiers]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.modifiers.1">
    
    <pre><code><cxx-signature>constexpr void remove_prefix(size_type n);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-requires para_num="2" id="string.view.modifiers.2">
    
    <dt>Requires:</dt><dd><code>n &lt;= size()</code>.</dd>
  </cxx-requires>
      <cxx-effects para_num="3" id="string.view.modifiers.3">
    
    <dt>Effects:</dt><dd>Equivalent to <code>data_ += n; size_ -= n;</code></dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="4" id="string.view.modifiers.4">
    
    <pre><code><cxx-signature>constexpr void remove_suffix(size_type n);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-requires para_num="5" id="string.view.modifiers.5">
    
    <dt>Requires:</dt><dd><code>n &lt;= size()</code>.</dd>
  </cxx-requires>
      <cxx-effects para_num="6" id="string.view.modifiers.6">
    
    <dt>Effects:</dt><dd>Equivalent to <code>size_ -= n;</code></dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="7" id="string.view.modifiers.7">
    
    <pre><code><cxx-signature>constexpr void swap(basic_string_view&amp; s) noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="8" id="string.view.modifiers.8">
    
    <dt>Effects:</dt><dd>Exchanges the values of <code>*this</code> and <code>s</code>.</dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.ops">
    

    <section>
      <header><span class="section-number">7.8</span> <h1 data-bookmark-label="7.8 basic_string_view string operations"><code>basic_string_view</code> string operations</h1> <span style="float:right"><a href="#string.view.ops">[string.view.ops]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.ops.1">
    
    <pre><code><cxx-signature>template&lt;class Allocator&gt;
explicit<cxx-footnote><!--
    Be sure not to introduce whitespace here, as it appears around the footnote.
  --><sup id="footnote-call-2"><a href="#footnote-body-2">2</a></sup><aside class="footnote" id="footnote-body-2"><span class="marker"><a href="#footnote-call-2">2</a>) </span>This conversion is explicit to avoid accidental O(N) operations on type mismatches.</aside></cxx-footnote> operator basic_string&lt;
    charT, traits, Allocator&gt;() const;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="2" id="string.view.ops.2">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return basic_string&lt;charT, traits, Allocator&gt;(begin(), end());</code></dd>
  </cxx-effects>
      <cxx-complexity para_num="3" id="string.view.ops.3">
    
    <dt>Complexity:</dt><dd>O(<code>size()</code>)</dd>
  </cxx-complexity>
      <p para_num="4" id="string.view.ops.4"><cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Users who want to control the allocator instance should call <code>to_string(allocator)</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="5" id="string.view.ops.5">
    
    <pre><code><cxx-signature>template&lt;class Allocator = allocator&lt;charT&gt;&gt;
basic_string&lt;charT, traits, Allocator&gt; to_string(
    const Allocator&amp; a = Allocator()) const;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="6" id="string.view.ops.6">
    
    <dt>Returns:</dt><dd><code>basic_string&lt;charT, traits, Allocator&gt;(begin(), end(), a)</code>.</dd>
  </cxx-returns>
      <cxx-complexity para_num="7" id="string.view.ops.7">
    
    <dt>Complexity:</dt><dd>O(<code>size()</code>)</dd>
  </cxx-complexity>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="8" id="string.view.ops.8">
    
    <pre><code><cxx-signature>size_type copy(charT* s, size_type n, size_type pos = 0) const;</cxx-signature></code></pre>

    <dl>
      
      

      <p para_num="9" id="string.view.ops.9">Let <code>rlen</code> be the smaller of <code>n</code> and <code>size() - pos</code>.</p>
      <cxx-throws para_num="10" id="string.view.ops.10">
    
    <dt>Throws:</dt><dd><code>out_of_range</code> if <code>pos &gt; size()</code>.</dd>
  </cxx-throws>
      <cxx-requires para_num="11" id="string.view.ops.11">
    
    <dt>Requires:</dt><dd><cxx-range begin="s" end="s + rlen">[<code>s</code>, <code>s + rlen</code>)</cxx-range> is a valid range.</dd>
  </cxx-requires>
      <cxx-effects para_num="12" id="string.view.ops.12">
    
    <dt>Effects:</dt><dd>Equivalent to <code>std::copy_n(begin() + pos, rlen, s).</code></dd>
  </cxx-effects>
      <cxx-returns para_num="13" id="string.view.ops.13">
    
    <dt>Returns:</dt><dd><code>rlen</code>.</dd>
  </cxx-returns>
      <cxx-complexity para_num="14" id="string.view.ops.14">
    
    <dt>Complexity:</dt><dd>O(<code>rlen</code>)</dd>
  </cxx-complexity>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="15" id="string.view.ops.15">
    
    <pre><code><cxx-signature>constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-throws para_num="16" id="string.view.ops.16">
    
    <dt>Throws:</dt><dd><code>out_of_range</code> if <code>pos &gt; size()</code>.</dd>
  </cxx-throws>
      <cxx-effects para_num="17" id="string.view.ops.17">
    
    <dt>Effects:</dt><dd>Determines the effective length <code><var>rlen</var></code> of the string to reference as the smaller of <code>n</code> and <code>size() - pos</code>.</dd>
  </cxx-effects>
      <cxx-returns para_num="18" id="string.view.ops.18">
    
    <dt>Returns:</dt><dd><code>basic_string_view(data()+pos, <var>rlen</var>)</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="19" id="string.view.ops.19">
    
    <pre><code><cxx-signature>constexpr int compare(basic_string_view str) const noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="20" id="string.view.ops.20">
    
    <dt>Effects:</dt><dd>Determines the effective length <code><var>rlen</var></code> of the strings to compare as the smaller of <code>size()</code> and <code>str.size()</code>.
        The function then compares the two strings by calling <code>traits::compare(data(), str.data(), <var>rlen</var>)</code>.</dd>
  </cxx-effects>
      <cxx-complexity para_num="21" id="string.view.ops.21">
    
    <dt>Complexity:</dt><dd>O(<code><var>rlen</var></code>)</dd>
  </cxx-complexity>
      <cxx-returns para_num="22" id="string.view.ops.22">
    
    <dt>Returns:</dt><dd>The nonzero result if the result of the comparison is nonzero.
        Otherwise, returns a value as indicated in <cxx-ref to="tab:string.view.compare"><a title="tab:string.view.compare" href="#tab:string.view.compare">Table 11</a></cxx-ref>.</dd>
  </cxx-returns>
      <table is="cxx-table" id="tab:string.view.compare" class="center">
    

    <caption>Table 11 — <wbr><span><code>compare()</code> results</span></caption>
    
        
        <tbody><tr><th>Condition</th><th>Return Value</th></tr>
        <tr><td><code>size() &lt; str.size()</code></td><td><code>&lt; 0</code></td></tr>
        <tr><td><code>size() == str.size()</code></td><td><code>&nbsp; 0</code></td></tr>
        <tr><td><code>size() &gt;  str.size()</code></td><td><code>&gt; 0</code></td></tr>
      </tbody>
  </table>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="23" id="string.view.ops.23">
    
    <pre><code><cxx-signature>constexpr int compare(size_type pos1, size_type n1, basic_string_view str) const;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-effects para_num="24" id="string.view.ops.24">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return substr(pos1, n1).compare(str);</code></dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="25" id="string.view.ops.25">
    
    <pre><code><cxx-signature>constexpr int compare(size_type pos1, size_type n1, basic_string_view str,
                      size_type pos2, size_type n2) const;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-effects para_num="26" id="string.view.ops.26">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return substr(pos1, n1).compare(str.substr(pos2, n2));</code></dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="27" id="string.view.ops.27">
    
    <pre><code><cxx-signature>constexpr int compare(const charT* s) const;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-effects para_num="28" id="string.view.ops.28">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return compare(basic_string_view(s));</code></dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="29" id="string.view.ops.29">
    
    <pre><code><cxx-signature>constexpr int compare(size_type pos1, size_type n1, const charT* s) const;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-effects para_num="30" id="string.view.ops.30">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return substr(pos1, n1).compare(basic_string_view(s));</code></dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="31" id="string.view.ops.31">
    
    <pre><code><cxx-signature>constexpr int compare(size_type pos1, size_type n1,
                      const charT* s, size_type n2) const;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-effects para_num="32" id="string.view.ops.32">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return substr(pos1, n1).compare(basic_string_view(s, n2));</code></dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>

    <cxx-section id="string.view.find">
    

    <section>
      <header><span class="section-number">7.8.1</span> <h1 data-bookmark-label="7.8.1 Searching basic_string_view">Searching <code>basic_string_view</code></h1> <span style="float:right"><a href="#string.view.find">[string.view.find]</a></span></header>
      
      

      <p para_num="1" id="string.view.find.1">This section specifies the <code>basic_string_view</code> member functions named
        <code>find</code>, <code>rfind</code>, <code>find_first_of</code>, <code>find_last_of</code>, <code>find_first_not_of</code>, and <code>find_last_not_of</code>.</p>

      <p para_num="2" id="string.view.find.2">Member functions in this section have complexity O(<code>size() * str.size()</code>) at worst,
        although implementations are encouraged to do better.</p>

      <p para_num="3" id="string.view.find.3">Each member function of the form</p>
      <pre><code>constexpr <var>return-type fx1</var>(const charT* s, size_type pos);</code></pre>
      <p class="cont">is equivalent to <code>return <var>fx1</var>(basic_string_view(s), pos);</code></p>

      <p para_num="4" id="string.view.find.4">Each member function of the form</p>
      <pre><code>constexpr <var>return-type fx1</var>(const charT* s, size_type pos, size_type n);</code></pre>
      <p class="cont">is equivalent to <code>return <var>fx1</var>(basic_string_view(s, n), pos);</code></p>

      <p para_num="5" id="string.view.find.5">Each member function of the form</p>
      <pre><code>constexpr <var>return-type fx2</var>(charT c, size_type pos);</code></pre>
      <p class="cont">is equivalent to <code>return <var>fx2</var>(basic_string_view(&amp;c, 1), pos);</code></p>

      <cxx-function para_num="6" id="string.view.find.6">
    
    <pre><code><cxx-signature>constexpr size_type find(basic_string_view str, size_type pos = 0) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="7" id="string.view.find.7">
    
    <dt>Effects:</dt><dd>
          Determines the lowest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>pos &lt;= xpos</code></li>
            <li><code>xpos + str.size() &lt;= size()</code></li>
            <li><code>traits::eq(at(xpos+I), str.at(I))</code> for all elements <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects>
        <cxx-returns para_num="8" id="string.view.find.8">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="9" id="string.view.find.9">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="10" id="string.view.find.10">
    
    <pre><code><cxx-signature>constexpr size_type rfind(basic_string_view str, size_type pos = npos) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="11" id="string.view.find.11">
    
    <dt>Effects:</dt><dd>
          Determines the highest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>xpos &lt;= pos</code></li>
            <li><code>xpos + str.size() &lt;= size()</code></li>
            <li><code>traits::eq(at(xpos+I), str.at(I))</code> for all elements <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects>
        <cxx-returns para_num="12" id="string.view.find.12">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="13" id="string.view.find.13">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="14" id="string.view.find.14">
    
    <pre><code><cxx-signature>constexpr size_type find_first_of(basic_string_view str, size_type pos = 0) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="15" id="string.view.find.15">
    
    <dt>Effects:</dt><dd>Determines the lowest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>pos &lt;= xpos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for some element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects>
        <cxx-returns para_num="16" id="string.view.find.16">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="17" id="string.view.find.17">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="18" id="string.view.find.18">
    
    <pre><code><cxx-signature>constexpr size_type find_last_of(basic_string_view str, size_type pos = npos) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="19" id="string.view.find.19">
    
    <dt>Effects:</dt><dd>Determines the highest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>xpos &lt;= pos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for some element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects>
        <cxx-returns para_num="20" id="string.view.find.20">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="21" id="string.view.find.21">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="22" id="string.view.find.22">
    
    <pre><code><cxx-signature>constexpr size_type find_first_not_of(basic_string_view str, size_type pos = 0) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="23" id="string.view.find.23">
    
    <dt>Effects:</dt><dd>Determines the lowest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>pos &lt;= xpos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for no element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects>
        <cxx-returns para_num="24" id="string.view.find.24">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>. Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="25" id="string.view.find.25">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="26" id="string.view.find.26">
    
    <pre><code><cxx-signature>constexpr size_type find_last_not_of(basic_string_view str, size_type pos = npos) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="27" id="string.view.find.27">
    
    <dt>Effects:</dt><dd>Determines the highest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>xpos &lt;= pos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for no element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects>
        <cxx-returns para_num="28" id="string.view.find.28">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="29" id="string.view.find.29">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.comparison">
    

    <section>
      <header><span class="section-number">7.9</span> <h1 data-bookmark-label="7.9 basic_string_view non-member comparison functions"><code>basic_string_view</code> non-member comparison functions</h1> <span style="float:right"><a href="#string.view.comparison">[string.view.comparison]</a></span></header>
      
    

    <p para_num="1" id="string.view.comparison.1">
      Let <code>S</code> be <code>basic_string_view&lt;charT, traits&gt;</code>, and <code>sv</code> be an instance of <code>S</code>.
      Implementations shall provide sufficient additional overloads marked <code>constexpr</code> and <code>noexcept</code>
      so that an object <code><var>t</var></code> with an implicit conversion to <code>S</code> can be compared according to <cxx-ref to="tab:string.view.comparison.overloads"><a title="tab:string.view.comparison.overloads" href="#tab:string.view.comparison.overloads">Table 12</a></cxx-ref>.
    </p>

    <table is="cxx-table" id="tab:string.view.comparison.overloads" class="center">
    

    <caption>Table 12 — <wbr><span>Additional <code>basic_string_view</code> comparison overloads</span></caption>
    
      <tbody><tr><th>Expression</th><th>Equivalent to</th></tr>
      <tr><td><code>t == sv</code></td><td><code>S(t) == sv</code></td></tr>
      <tr><td><code>sv == t</code></td><td><code>sv == S(t)</code></td></tr>
      <tr><td><code>t != sv</code></td><td><code>S(t) != sv</code></td></tr>
      <tr><td><code>sv != t</code></td><td><code>sv != S(t)</code></td></tr>
      <tr><td><code>t &lt; sv</code></td><td><code>S(t) &lt; sv</code></td></tr>
      <tr><td><code>sv &lt; t</code></td><td><code>sv &lt; S(t)</code></td></tr>
      <tr><td><code>t &gt; sv</code></td><td><code>S(t) &gt; sv</code></td></tr>
      <tr><td><code>sv &gt; t</code></td><td><code>sv &gt; S(t)</code></td></tr>
      <tr><td><code>t &lt;= sv</code></td><td><code>S(t) &lt;= sv</code></td></tr>
      <tr><td><code>sv &lt;= t</code></td><td><code>sv &lt;= S(t)</code></td></tr>
      <tr><td><code>t &gt;= sv</code></td><td><code>S(t) &gt;= sv</code></td></tr>
      <tr><td><code>sv &gt;= t</code></td><td><code>sv &gt;= S(t)</code></td></tr>
    </tbody>
  </table>

    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    A sample conforming implementation for operator== would be:
<pre><code>template&lt;class T&gt; using __identity = decay_t&lt;T&gt;;
template&lt;class charT, class traits&gt;
constexpr bool operator==(
    basic_string_view&lt;charT, traits&gt; lhs,
    basic_string_view&lt;charT, traits&gt; rhs) noexcept {
  return lhs.compare(rhs) == 0;
}
template&lt;class charT, class traits&gt;
constexpr bool operator==(
    basic_string_view&lt;charT, traits&gt; lhs,
    __identity&lt;basic_string_view&lt;charT, traits&gt;&gt; rhs) noexcept {
  return lhs.compare(rhs) == 0;
}
template&lt;class charT, class traits&gt;
constexpr bool operator==(
    __identity&lt;basic_string_view&lt;charT, traits&gt;&gt; lhs,
    basic_string_view&lt;charT, traits&gt; rhs) noexcept {
  return lhs.compare(rhs) == 0;
}</code></pre>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

    <cxx-function para_num="2" id="string.view.comparison.2">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="3" id="string.view.comparison.3">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) == 0</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="4" id="string.view.comparison.4">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator!=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="5" id="string.view.comparison.5">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) != 0</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="6" id="string.view.comparison.6">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator&lt; (basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="7" id="string.view.comparison.7">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) &lt; 0</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="8" id="string.view.comparison.8">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator&gt; (basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="9" id="string.view.comparison.9">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) &gt; 0</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="10" id="string.view.comparison.10">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator&lt;=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="11" id="string.view.comparison.11">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) &lt;= 0</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="12" id="string.view.comparison.12">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator&gt;=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="13" id="string.view.comparison.13">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) &gt;= 0</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.io">
    

    <section>
      <header><span class="section-number">7.10</span> <h1 data-bookmark-label="7.10 Inserters and extractors">Inserters and extractors</h1> <span style="float:right"><a href="#string.view.io">[string.view.io]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.io.1">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               basic_string_view&lt;charT, traits&gt; str);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="2" id="string.view.io.2">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return os &lt;&lt; str.to_string();</code></dd>
  </cxx-effects>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.hash">
    

    <section>
      <header><span class="section-number">7.11</span> <h1 data-bookmark-label="7.11 Hash support">Hash support</h1> <span style="float:right"><a href="#string.view.hash">[string.view.hash]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.hash.1">
    
    <pre><code><cxx-signature>template &lt;&gt; struct hash&lt;experimental::string_view&gt;;</cxx-signature><cxx-signature>template &lt;&gt; struct hash&lt;experimental::u16string_view&gt;;</cxx-signature><cxx-signature>template &lt;&gt; struct hash&lt;experimental::u32string_view&gt;;</cxx-signature><cxx-signature>template &lt;&gt; struct hash&lt;experimental::wstring_view&gt;;</cxx-signature></code></pre>

    <dl>
      
      
      
      
      
      <p para_num="2" id="string.view.hash.2">The template specializations shall meet the requirements of class template hash (<cxx-ref in="cxx" to="unord.hash">C++14 <span title="unord.hash">§20.9.12</span></cxx-ref>).</p>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="memory">
    

    <section>
      <header><span class="section-number">8</span> <h1 data-bookmark-label="8 Memory">Memory</h1> <span style="float:right"><a href="#memory">[memory]</a></span></header>
      
  

  <cxx-section id="header.memory.synop">
    

    <section>
      <header><span class="section-number">8.1</span> <h1 data-bookmark-label="8.1 Header &lt;experimental/memory&gt; synopsis">Header &lt;experimental/memory&gt; synopsis</h1> <span style="float:right"><a href="#header.memory.synop">[header.memory.synop]</a></span></header>
      
    

<pre><code>#include &lt;memory&gt;

namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    // See <cxx-ref in="cxx" to="allocator.uses">C++14 <span title="allocator.uses">§20.7.7</span></cxx-ref>, uses_allocator
    template &lt;class T, class Alloc&gt; constexpr bool uses_allocator_v
      = uses_allocator&lt;T, Alloc&gt;::value;

    <cxx-ref insynopsis="" to="memory.smartptr.shared">// <i><a title="memory.smartptr.shared" href="#memory.smartptr.shared">8.2.1</a>, Class template shared_ptr</i></cxx-ref>
    template&lt;class T&gt; class shared_ptr;

    // <cxx-ref in="cxx" to="util.smartptr.shared.create">C++14 <span title="util.smartptr.shared.create">§20.8.2.2.6</span></cxx-ref>
    template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
    template&lt;class T, class A, class... Args&gt;
      shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);

    // <cxx-ref in="cxx" to="util.smartptr.shared.cmp">C++14 <span title="util.smartptr.shared.cmp">§20.8.2.2.7</span></cxx-ref>
    template&lt;class T, class U&gt;
      bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
    template&lt;class T, class U&gt;
      bool operator!=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
    template&lt;class T, class U&gt;
      bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
    template&lt;class T, class U&gt;
      bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
    template&lt;class T, class U&gt;
      bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
    template&lt;class T, class U&gt;
      bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
    template &lt;class T&gt;
      bool operator==(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
    template &lt;class T&gt;
      bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
    template &lt;class T&gt;
      bool operator!=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
    template &lt;class T&gt;
      bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
    template &lt;class T&gt;
      bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
    template &lt;class T&gt;
      bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
    template &lt;class T&gt;
      bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
    template &lt;class T&gt;
      bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
    template &lt;class T&gt;
      bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
    template &lt;class T&gt;
      bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
    template &lt;class T&gt;
      bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
    template &lt;class T&gt;
      bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;

    // <cxx-ref in="cxx" to="util.smartptr.shared.spec">C++14 <span title="util.smartptr.shared.spec">§20.8.2.2.8</span></cxx-ref>
    template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;

    <cxx-ref insynopsis="" to="memory.smartptr.shared.cast">// <i><a title="memory.smartptr.shared.cast" href="#memory.smartptr.shared.cast">8.2.1.3</a>, shared_ptr casts</i></cxx-ref>
    template&lt;class T, class U&gt;
      shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
    template&lt;class T, class U&gt;
      shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
    template&lt;class T, class U&gt;
      shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
    template&lt;class T, class U&gt;
      shared_ptr&lt;T&gt; reinterpret_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;

    // <cxx-ref in="cxx" to="util.smartptr.getdeleter">C++14 <span title="util.smartptr.getdeleter">§20.8.2.2.10</span></cxx-ref>
    template&lt;class D, class T&gt; D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;

    // <cxx-ref in="cxx" to="util.smartptr.shared.io">C++14 <span title="util.smartptr.shared.io">§20.8.2.2.11</span></cxx-ref>
    template&lt;class E, class T, class Y&gt;
      basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, const shared_ptr&lt;Y&gt;&amp; p);

    // <cxx-ref in="cxx" to="util.smartptr.weak">C++14 <span title="util.smartptr.weak">§20.8.2.3</span></cxx-ref>
    template&lt;class T&gt; class weak_ptr;

    // <cxx-ref in="cxx" to="util.smartptr.weak.spec">C++14 <span title="util.smartptr.weak.spec">§20.8.2.3.6</span></cxx-ref>
    template&lt;class T&gt; void swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b) noexcept;

    // <cxx-ref in="cxx" to="util.smartptr.ownerless">C++14 <span title="util.smartptr.ownerless">§20.8.2.4</span></cxx-ref>
    template&lt;class T&gt; class owner_less;

    // <cxx-ref in="cxx" to="util.smartptr.enab">C++14 <span title="util.smartptr.enab">§20.8.2.5</span></cxx-ref>
    template&lt;class T&gt; class enable_shared_from_this;

    // <cxx-ref in="cxx" to="util.smartptr.shared.atomic">C++14 <span title="util.smartptr.shared.atomic">§20.8.2.6</span></cxx-ref>
    template&lt;class T&gt;
      bool atomic_is_lock_free(const shared_ptr&lt;T&gt;* p);
    template&lt;class T&gt;
      shared_ptr&lt;T&gt; atomic_load(const shared_ptr&lt;T&gt;* p);
    template&lt;class T&gt;
      shared_ptr&lt;T&gt; atomic_load_explicit(const shared_ptr&lt;T&gt;* p, memory_order mo);
    template&lt;class T&gt;
      void atomic_store(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
    template&lt;class T&gt;
      void atomic_store_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);
    template&lt;class T&gt;
      shared_ptr&lt;T&gt; atomic_exchange(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
    template&lt;class T&gt;
      shared_ptr&lt;T&gt; atomic_exchange_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r,
                                             memory_order mo);
    template&lt;class T&gt;
      bool atomic_compare_exchange_weak(
        shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
    template&lt;class T&gt;
      bool atomic_compare_exchange_strong(
        shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
    template&lt;class T&gt;
      bool atomic_compare_exchange_weak_explicit(
        shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
        memory_order success, memory_order failure);
    template&lt;class T&gt;
      bool atomic_compare_exchange_strong_explicit(
        shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
        memory_order success, memory_order failure);

    <cxx-ref insynopsis="" to="memory.observer.ptr">// <i><a title="memory.observer.ptr" href="#memory.observer.ptr">8.12</a>, Non-owning pointers</i></cxx-ref>
    template &lt;class W&gt; class observer_ptr;

    <cxx-ref insynopsis="" to="memory.observer.ptr.special">// <i><a title="memory.observer.ptr.special" href="#memory.observer.ptr.special">8.12.6</a>, observer_ptr specialized algorithms</i></cxx-ref>
    template &lt;class W&gt;
    void swap(observer_ptr&lt;W&gt;&amp;, observer_ptr&lt;W&gt;&amp;) noexcept;
    template &lt;class W&gt;
    observer_ptr&lt;W&gt; make_observer(W*) noexcept;
    // (in)equality operators
    template &lt;class W1, class W2&gt;
    bool operator==(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);

    template &lt;class W1, class W2&gt;
    bool operator!=(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W&gt;
    bool operator==(observer_ptr&lt;W&gt;, nullptr_t) noexcept;
    template &lt;class W&gt;
    bool operator!=(observer_ptr&lt;W&gt;, nullptr_t) noexcept;
    template &lt;class W&gt;
    bool operator==(nullptr_t, observer_ptr&lt;W&gt;) noexcept;
    template &lt;class W&gt;
    bool operator!=(nullptr_t, observer_ptr&lt;W&gt;) noexcept;
    // ordering operators
    template &lt;class W1, class W2&gt;
    bool operator&lt;(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W1, class W2&gt;
    bool operator&gt;(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W1, class W2&gt;
    bool operator&lt;=(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W1, class W2&gt;
    bool operator&gt;=(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);

  } // inline namespace fundamentals_v2
  } // namespace experimental

  // <cxx-ref in="cxx" to="util.smartptr.hash">C++14 <span title="util.smartptr.hash">§20.8.2.7</span></cxx-ref>
  template&lt;class T&gt; struct hash&lt;experimental::shared_ptr&lt;T&gt;&gt;;

  <cxx-ref insynopsis="" to="memory.observer.ptr.hash">// <i><a title="memory.observer.ptr.hash" href="#memory.observer.ptr.hash">8.12.7</a>, observer_ptr hash support</i></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt; struct hash&lt;experimental::observer_ptr&lt;T&gt;&gt;;

} // namespace std</code></pre>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.smartptr">
    

    <section>
      <header><span class="section-number">8.2</span> <h1 data-bookmark-label="8.2 Shared-ownership pointers">Shared-ownership pointers</h1> <span style="float:right"><a href="#memory.smartptr">[memory.smartptr]</a></span></header>
      
    

      <p para_num="1" id="memory.smartptr.1">
        The specification of all declarations within this sub-clause <cxx-ref to="memory.smartptr"><a title="memory.smartptr" href="#memory.smartptr">8.2</a></cxx-ref> and its sub-clauses are the same as the corresponding declarations, as specified in <cxx-ref in="cxx" to="util.smartptr">C++14 <span title="util.smartptr">§20.8.2</span></cxx-ref>, unless explicitly specified otherwise.
      </p>

  <cxx-section id="memory.smartptr.shared">
    

    <section>
      <header><span class="section-number">8.2.1</span> <h1 data-bookmark-label="8.2.1 Class template shared_ptr">Class template shared_ptr</h1> <span style="float:right"><a href="#memory.smartptr.shared">[memory.smartptr.shared]</a></span></header>
      
    

<pre><code>
namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  template&lt;class T&gt; class shared_ptr {
  public:
    typedef typename remove_extent_t&lt;T&gt; element_type;
    <cxx-ref insynopsis="" to="memory.smartptr.shared.const">// <i><a title="memory.smartptr.shared.const" href="#memory.smartptr.shared.const">8.2.1.1</a>, shared_ptr constructors</i></cxx-ref>
    constexpr shared_ptr() noexcept;
    template&lt;class Y&gt; explicit shared_ptr(Y* p);
    template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
    template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
    template &lt;class D&gt; shared_ptr(nullptr_t p, D d)
    template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
    template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, element_type* p) noexcept;
    shared_ptr(const shared_ptr&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    shared_ptr(shared_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
    template&lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
    template&lt;class Y&gt; shared_ptr(auto_ptr&lt;Y&gt;&amp;&amp; r);
    template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
    constexpr shared_ptr(nullptr_t) : shared_ptr() { }

    // <cxx-ref in="cxx" to="util.smartptr.shared.dest">C++14 <span title="util.smartptr.shared.dest">§20.8.2.2.2</span></cxx-ref>
    ~shared_ptr();

    // <cxx-ref in="cxx" to="util.smartptr.shared.assign">C++14 <span title="util.smartptr.shared.assign">§20.8.2.2.3</span></cxx-ref>
    shared_ptr&amp; operator=(const shared_ptr&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    shared_ptr&amp; operator=(shared_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr&amp; operator=(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
    template&lt;class Y&gt; shared_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp;&amp; r);
    template &lt;class Y, class D&gt; shared_ptr&amp; operator=(unique_ptr&lt;Y, D&gt;&amp;&amp; r);

    // <cxx-ref in="cxx" to="util.smartptr.shared.mod">C++14 <span title="util.smartptr.shared.mod">§20.8.2.2.4</span></cxx-ref>
    void swap(shared_ptr&amp; r) noexcept;
    void reset() noexcept;
    template&lt;class Y&gt; void reset(Y* p);
    template&lt;class Y, class D&gt; void reset(Y* p, D d);
    template&lt;class Y, class D, class A&gt; void reset(Y* p, D d, A a);

    <cxx-ref insynopsis="" to="memory.smartptr.shared.obs">// <i><a title="memory.smartptr.shared.obs" href="#memory.smartptr.shared.obs">8.2.1.2</a>, shared_ptr observers</i></cxx-ref>
    element_type* get() const noexcept;
    T&amp; operator*() const noexcept;
    T* operator-&gt;() const noexcept;
    element_type&amp; operator[](ptrdiff_t i) const noexcept;
    long use_count() const noexcept;
    bool unique() const noexcept;
    explicit operator bool() const noexcept;
    template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) const;
    template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) const;
  };

  // <cxx-ref in="cxx" to="util.smartptr.shared.create">C++14 <span title="util.smartptr.shared.create">§20.8.2.2.6</span></cxx-ref>
  template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
  template&lt;class T, class A, class... Args&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);

  // <cxx-ref in="cxx" to="util.smartptr.shared.cmp">C++14 <span title="util.smartptr.shared.cmp">§20.8.2.2.7</span></cxx-ref>
  template&lt;class T, class U&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;
  template &lt;class T&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; b) noexcept;

  // <cxx-ref in="cxx" to="util.smartptr.shared.spec">C++14 <span title="util.smartptr.shared.spec">§20.8.2.2.8</span></cxx-ref>
  template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;

  <cxx-ref insynopsis="" to="memory.smartptr.shared.cast">// <i><a title="memory.smartptr.shared.cast" href="#memory.smartptr.shared.cast">8.2.1.3</a>, shared_ptr casts</i></cxx-ref>
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; reinterpret_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;

  // <cxx-ref in="cxx" to="util.smartptr.getdeleter">C++14 <span title="util.smartptr.getdeleter">§20.8.2.2.10</span></cxx-ref>
  template&lt;class D, class T&gt; D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;

  // <cxx-ref in="cxx" to="util.smartptr.shared.io">C++14 <span title="util.smartptr.shared.io">§20.8.2.2.11</span></cxx-ref>
  template&lt;class E, class T, class Y&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, const shared_ptr&lt;Y&gt;&amp; p);

  // <cxx-ref in="cxx" to="util.smartptr.ownerless">C++14 <span title="util.smartptr.ownerless">§20.8.2.4</span></cxx-ref>
  template&lt;class T&gt; class owner_less;

  // <cxx-ref in="cxx" to="util.smartptr.enab">C++14 <span title="util.smartptr.enab">§20.8.2.5</span></cxx-ref>
  template&lt;class T&gt; class enable_shared_from_this;

  // <cxx-ref in="cxx" to="util.smartptr.shared.atomic">C++14 <span title="util.smartptr.shared.atomic">§20.8.2.6</span></cxx-ref>
  template&lt;class T&gt;
    bool atomic_is_lock_free(const shared_ptr&lt;T&gt;* p);
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_load(const shared_ptr&lt;T&gt;* p);
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_load_explicit(const shared_ptr&lt;T&gt;* p, memory_order mo);
  template&lt;class T&gt;
    void atomic_store(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
  template&lt;class T&gt;
    void atomic_store_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_exchange(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_exchange_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r,
                                           memory_order mo);
  template&lt;class T&gt;
    bool atomic_compare_exchange_weak(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
  template&lt;class T&gt;
    bool atomic_compare_exchange_weak_explicit(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
      memory_order success, memory_order failure);
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong_explicit(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
      memory_order success, memory_order failure);


} // namespace fundamentals_v2
} // namespace experimental

  // <cxx-ref in="cxx" to="util.smartptr.hash">C++14 <span title="util.smartptr.hash">§20.8.2.7</span></cxx-ref>
  template&lt;class T&gt; struct hash&lt;experimental::shared_ptr&lt;T&gt;&gt;;

} // namespace std</code></pre>

      <p para_num="1" id="memory.smartptr.shared.1">
        For the purposes of subclause <cxx-ref to="memory.smartptr"><a title="memory.smartptr" href="#memory.smartptr">8.2</a></cxx-ref>, a pointer type <code>Y*</code> is said to be <dfn>compatible with</dfn> a pointer type <code>T*</code> when either <code>Y*</code> is convertible to <code>T*</code> or <code>Y</code> is <code>U[N]</code> and <code>T</code> is <code>U <var>cv</var> []</code>.
      </p>

  <cxx-section id="memory.smartptr.shared.const">
    

    <section>
      <header><span class="section-number">8.2.1.1</span> <h1 data-bookmark-label="8.2.1.1 shared_ptr constructors"><code>shared_ptr</code> constructors</h1> <span style="float:right"><a href="#memory.smartptr.shared.const">[memory.smartptr.shared.const]</a></span></header>
      
    

      <cxx-function para_num="1" id="memory.smartptr.shared.const.1">
    
    <pre><code><cxx-signature>template&lt;class Y&gt; explicit shared_ptr(Y* p);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="memory.smartptr.shared.const.2">
    
    <dt>Requires:</dt><dd><code>Y</code> shall be a complete type.
        The expression <code>delete[] p</code>, when <code>T</code> is an array type,
        or <code>delete p</code>, when <code>T</code> is not an array type,
        shall be well-formed, shall have well defined behavior, and shall not throw exceptions.
        When <code>T</code> is <code>U[N]</code>, <code>Y(*)[N]</code> shall be convertible to <code>T*</code>;
        when <code>T</code> is <code>U[]</code>, <code>Y(*)[]</code> shall be convertible to <code>T*</code>;
        otherwise, <code>Y*</code> shall be convertible to <code>T*</code>.</dd>
  </cxx-requires>

        <cxx-effects para_num="3" id="memory.smartptr.shared.const.3">
    
    <dt>Effects:</dt><dd>When <code>T</code> is not an array type, constructs a <code>shared_ptr</code> object that <i>owns</i> the pointer <code>p</code>.
        Otherwise, constructs a <code>shared_ptr</code> that <em>owns</em> <code>p</code> and a deleter of an unspecified type that calls <code>delete[] p</code>.</dd>
  </cxx-effects>

        <cxx-postconditions para_num="4" id="memory.smartptr.shared.const.4">
    
    <dt>Postconditions:</dt><dd><code>use_count() == 1 &amp;&amp; get() == p</code>.</dd>
  </cxx-postconditions>

        <cxx-throws para_num="5" id="memory.smartptr.shared.const.5">
    
    <dt>Throws:</dt><dd><code>bad_alloc</code>, or an implementation-defined exception when a resource other than memory could not be obtained.</dd>
  </cxx-throws>

        <cxx-exception-safety para_num="6" id="memory.smartptr.shared.const.6">
    
    <dt>Exception safety:</dt><dd>If an exception is thrown, <code>delete p</code> is called when <code>T</code> is not an array type, <code>delete[] p</code> otherwise.</dd>
  </cxx-exception-safety>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="memory.smartptr.shared.const.7">
    
    <pre><code><cxx-signature>template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);</cxx-signature><cxx-signature>template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);</cxx-signature><cxx-signature>template &lt;class D&gt; shared_ptr(nullptr_t p, D d);</cxx-signature><cxx-signature>template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);</cxx-signature></code></pre>

    <dl>
      
        
        
        
        

        <cxx-requires para_num="8" id="memory.smartptr.shared.const.8">
    
    <dt>Requires:</dt><dd><code>D</code> shall be <code>CopyConstructible</code>. The copy constructor and destructor of <code> D</code> shall not throw exceptions. The expression <code>d(p)</code> shall be well formed, shall have well defined behavior, and shall not throw exceptions. <code>A</code> shall be an allocator (<cxx-ref in="cxx" to="allocator.requirements">C++14 <span title="allocator.requirements">§17.6.3.5</span></cxx-ref>). The copy constructor and destructor of <code>A</code> shall not throw exceptions.
        When <code>T</code> is <code>U[N]</code>, <code>Y(*)[N]</code> shall be convertible to <code>T*</code>;
        when <code>T</code> is <code>U[]</code>, <code>Y(*)[]</code> shall be convertible to <code>T*</code>;
        otherwise, <code>Y*</code> shall be convertible to <code>T*</code>.</dd>
  </cxx-requires>

        <cxx-effects para_num="9" id="memory.smartptr.shared.const.9">
    
    <dt>Effects:</dt><dd>Constructs a <code>shared_ptr</code> object that <i>owns</i> the object <code>p</code> and the deleter <code>d</code>. The second and fourth constructors shall use a copy of <code>a</code> to allocate memory for internal use.</dd>
  </cxx-effects>

        <cxx-postconditions para_num="10" id="memory.smartptr.shared.const.10">
    
    <dt>Postconditions:</dt><dd><code>use_count() == 1 &amp;&amp; get() == p</code>.</dd>
  </cxx-postconditions>

        <cxx-throws para_num="11" id="memory.smartptr.shared.const.11">
    
    <dt>Throws:</dt><dd><code>bad_alloc</code>, or an implementation-defined exception when a resource other than memory could not be obtained.</dd>
  </cxx-throws>

        <cxx-exception-safety para_num="12" id="memory.smartptr.shared.const.12">
    
    <dt>Exception safety:</dt><dd>If an exception is thrown, <code>d(p)</code> is called.</dd>
  </cxx-exception-safety>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="13" id="memory.smartptr.shared.const.13">
    
    <pre><code><cxx-signature>template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, element_type* p) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="14" id="memory.smartptr.shared.const.14">
    
    <dt>Effects:</dt><dd>Constructs a <code>shared_ptr</code> instance that stores <code>p</code> and <i>shares ownership</i> with <code>r</code>.</dd>
  </cxx-effects>

        <cxx-postconditions para_num="15" id="memory.smartptr.shared.const.15">
    
    <dt>Postconditions:</dt><dd><code>get() == p &amp;&amp; use_count() == r.use_count()</code>.</dd>
  </cxx-postconditions>

        <p para_num="16" id="memory.smartptr.shared.const.16">
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    To avoid the possibility of a dangling pointer, the user of this constructor must ensure that <code>p</code> remains valid at least until the ownership group of <code>r</code> is destroyed.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </p>

        <p para_num="17" id="memory.smartptr.shared.const.17">
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    This constructor allows creation of an <i>empty</i> <code>shared_ptr</code> instance with a non-null stored pointer.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </p>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="18" id="memory.smartptr.shared.const.18">
    
    <pre><code><cxx-signature>shared_ptr(const shared_ptr&amp; r) noexcept;</cxx-signature><cxx-signature>template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-requires para_num="19" id="memory.smartptr.shared.const.19">
    
    <dt>Requires:</dt><dd> The second constructor shall not participate in the overload resolution unless <code>Y*</code> is <i>compatible with</i> <code>T*</code>.</dd>
  </cxx-requires>

        <cxx-effects para_num="20" id="memory.smartptr.shared.const.20">
    
    <dt>Effects:</dt><dd>If <code>r</code> is <i>empty</i>, constructs an <i>empty</i> <code>shared_ptr</code> object; otherwise, constructs a <code>shared_ptr</code> object that <i>shares ownership</i> with <code>r</code>.</dd>
  </cxx-effects>

        <cxx-postconditions para_num="21" id="memory.smartptr.shared.const.21">
    
    <dt>Postconditions:</dt><dd><code>get() == r.get() &amp;&amp; use_count() == r.use_count()</code>.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="22" id="memory.smartptr.shared.const.22">
    
    <pre><code><cxx-signature>shared_ptr(shared_ptr&amp;&amp; r) noexcept;</cxx-signature><cxx-signature>template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        

        
        <cxx-remarks para_num="23" id="memory.smartptr.shared.const.23">
    
    <dt>Remarks:</dt><dd>The second constructor shall not participate in overload resolution unless <code>Y*</code> is <i>compatible with</i> <code>T*</code>.</dd>
  </cxx-remarks>

        <cxx-effects para_num="24" id="memory.smartptr.shared.const.24">
    
    <dt>Effects:</dt><dd>Move-constructs a <code>shared_ptr</code> instance from <code>r</code>.</dd>
  </cxx-effects>

        <cxx-postconditions para_num="25" id="memory.smartptr.shared.const.25">
    
    <dt>Postconditions:</dt><dd><code>*this</code> shall contain the old value of <code>r</code>. <code>r</code> shall be <i>empty</i>. <code>r.get() == 0.</code></dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="26" id="memory.smartptr.shared.const.26">
    
    <pre><code><cxx-signature>template&lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="27" id="memory.smartptr.shared.const.27">
    
    <dt>Requires:</dt><dd><code>Y*</code> shall be <i>compatible with</i> <code>T*</code>.</dd>
  </cxx-requires>

        <cxx-effects para_num="28" id="memory.smartptr.shared.const.28">
    
    <dt>Effects:</dt><dd>Constructs a <code>shared_ptr</code> object that <i>shares ownership</i> with <code>r</code> and stores a copy of the pointer stored in <code>r</code>.</dd>
  </cxx-effects>

        <cxx-postconditions para_num="29" id="memory.smartptr.shared.const.29">
    
    <dt>Postconditions:</dt><dd><code>use_count() == r.use_count()</code>.</dd>
  </cxx-postconditions>

        <cxx-throws para_num="30" id="memory.smartptr.shared.const.30">
    
    <dt>Throws:</dt><dd><code>bad_weak_ptr</code> when <code>r.expired()</code>.</dd>
  </cxx-throws>

        <cxx-exception-safety para_num="31" id="memory.smartptr.shared.const.31">
    
    <dt>Exception safety:</dt><dd>If an exception is thrown, the constructor has no effect.</dd>
  </cxx-exception-safety>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="32" id="memory.smartptr.shared.const.32">
    
    <pre><code><cxx-signature>template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-remarks para_num="33" id="memory.smartptr.shared.const.33">
    
    <dt>Remarks:</dt><dd>This constructor shall not participate in overload resolution unless <code>Y*</code> is <em>compatible with</em> <code>T*</code>.</dd>
  </cxx-remarks>

        <cxx-effects para_num="34" id="memory.smartptr.shared.const.34">
    
    <dt>Effects:</dt><dd>Equivalent to <code>shared_ptr(r.release(), r.get_deleter())</code> when <code>D</code> is not a reference type, otherwise <code>shared_ptr(r.release(), ref(r.get_deleter()))</code>.</dd>
  </cxx-effects>

        <cxx-exception-safety para_num="35" id="memory.smartptr.shared.const.35">
    
    <dt>Exception safety:</dt><dd>If an exception is thrown, the constructor has no effect.</dd>
  </cxx-exception-safety>
      
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.smartptr.shared.obs">
    

    <section>
      <header><span class="section-number">8.2.1.2</span> <h1 data-bookmark-label="8.2.1.2 shared_ptr observers"><code>shared_ptr</code> observers</h1> <span style="float:right"><a href="#memory.smartptr.shared.obs">[memory.smartptr.shared.obs]</a></span></header>
      
    

      <cxx-function para_num="1" id="memory.smartptr.shared.obs.1">
    
    <pre><code><cxx-signature>element_type* get() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="memory.smartptr.shared.obs.2">
    
    <dt>Returns:</dt><dd>The stored pointer.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.smartptr.shared.obs.3">
    
    <pre><code><cxx-signature>T&amp; operator*() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="4" id="memory.smartptr.shared.obs.4">
    
    <dt>Requires:</dt><dd><code>get() != 0</code>.</dd>
  </cxx-requires>

        <cxx-returns para_num="5" id="memory.smartptr.shared.obs.5">
    
    <dt>Returns:</dt><dd><code>*get()</code>.</dd>
  </cxx-returns>

        <cxx-remarks para_num="6" id="memory.smartptr.shared.obs.6">
    
    <dt>Remarks:</dt><dd>When <code>T</code> is an array type or (possibly cv-qualified) <code>void</code>,
 it is unspecified whether this member function is declared. If it is 
declared, it is unspecified what its return type is, except that the 
declaration (although not necessarily the definition) of the function 
shall be well formed.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="memory.smartptr.shared.obs.7">
    
    <pre><code><cxx-signature>T* operator-&gt;() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="8" id="memory.smartptr.shared.obs.8">
    
    <dt>Requires:</dt><dd><code>get() != 0</code>.</dd>
  </cxx-requires>

        <cxx-returns para_num="9" id="memory.smartptr.shared.obs.9">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="10" id="memory.smartptr.shared.obs.10">
    
    <dt>Remarks:</dt><dd>When <code>T</code> is an array type, it is 
unspecified whether this member function is declared.
        If it is declared, it is unspecified what its return type is, 
except that the declaration (although not necessarily the definition) of
 the function shall be well formed.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

        <cxx-function para_num="11" id="memory.smartptr.shared.obs.11">
    
    <pre><code><cxx-signature>element_type&amp; operator[](ptrdiff_t i) const noexcept;</cxx-signature></code></pre>

    <dl>
      
          

          <cxx-requires para_num="12" id="memory.smartptr.shared.obs.12">
    
    <dt>Requires:</dt><dd><code>get() != 0 &amp;&amp; i &gt;= 0</code>. If <code>T</code> is <code>U[N]</code>, <code>i &lt; N</code>.</dd>
  </cxx-requires>
          <cxx-returns para_num="13" id="memory.smartptr.shared.obs.13">
    
    <dt>Returns:</dt><dd><code>get()[i]</code>.</dd>
  </cxx-returns>
          <cxx-remarks para_num="14" id="memory.smartptr.shared.obs.14">
    
    <dt>Remarks:</dt><dd>When <code>T</code> is not an array type, it is
 unspecified whether this member function is declared.
          If it is declared, it is unspecified what its return type is, 
except that the declaration (although not necessarily the definition) of
 the function shall be well formed.</dd>
  </cxx-remarks>
        
    </dl>
  </cxx-function>

  
    </section>
  </cxx-section>

  <cxx-section id="memory.smartptr.shared.cast">
    

    <section>
      <header><span class="section-number">8.2.1.3</span> <h1 data-bookmark-label="8.2.1.3 shared_ptr casts"><code>shared_ptr</code> casts</h1> <span style="float:right"><a href="#memory.smartptr.shared.cast">[memory.smartptr.shared.cast]</a></span></header>
      
    

      <cxx-function para_num="1" id="memory.smartptr.shared.cast.1">
    
    <pre><code><cxx-signature>template&lt;class T, class U&gt; shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="memory.smartptr.shared.cast.2">
    
    <dt>Requires:</dt><dd>The expression <code>static_cast&lt;T*&gt;((U*)0)</code> shall be well formed.</dd>
  </cxx-requires>

        <cxx-returns para_num="3" id="memory.smartptr.shared.cast.3">
    
    <dt>Returns:</dt><dd><code>shared_ptr&lt;T&gt;(r, static_cast&lt;typename shared_ptr&lt;T&gt;::element_type*&gt;(r.get()))</code>.</dd>
  </cxx-returns>

        <p para_num="4" id="memory.smartptr.shared.cast.4">
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The seemingly equivalent expression <code>shared_ptr&lt;T&gt;(static_cast&lt;T*&gt;(r.get()))</code> will eventually result in undefined behavior, attempting to delete the same object twice.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </p>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="memory.smartptr.shared.cast.5">
    
    <pre><code><cxx-signature>template&lt;class T, class U&gt; shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="6" id="memory.smartptr.shared.cast.6">
    
    <dt>Requires:</dt><dd>The expression <code>dynamic_cast&lt;T*&gt;((U*)0)</code> shall be well formed.</dd>
  </cxx-requires>

        <cxx-returns para_num="7" id="memory.smartptr.shared.cast.7">
    
    <dt>Returns:</dt><dd>
          <ul>
            <li>When <code>dynamic_cast&lt;typename shared_ptr&lt;T&gt;::element_type*&gt;(r.get())</code> returns a nonzero value <code>p</code>, <code>shared_ptr&lt;T&gt;(r, p)</code>;</li>

            <li>Otherwise, <code>shared_ptr&lt;T&gt;()</code>.</li>
          </ul>
        </dd>
  </cxx-returns>

        <p para_num="8" id="memory.smartptr.shared.cast.8">
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The seemingly equivalent expression <code>shared_ptr&lt;T&gt;(dynamic_cast&lt;T*&gt;(r.get()))</code> will eventually result in undefined behavior, attempting to delete the same object twice.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </p>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="memory.smartptr.shared.cast.9">
    
    <pre><code><cxx-signature>template&lt;class T, class U&gt; shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="10" id="memory.smartptr.shared.cast.10">
    
    <dt>Requires:</dt><dd>The expression <code>const_cast&lt;T*&gt;((U*)0)</code> shall be well formed.</dd>
  </cxx-requires>

        <cxx-returns para_num="11" id="memory.smartptr.shared.cast.11">
    
    <dt>Returns:</dt><dd><code>shared_ptr&lt;T&gt;(r, const_cast&lt;typename shared_ptr&lt;T&gt;::element_type*&gt;(r.get()))</code>.</dd>
  </cxx-returns>

        <p para_num="12" id="memory.smartptr.shared.cast.12">
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The seemingly equivalent expression <code>shared_ptr&lt;T&gt;(const_cast&lt;T*&gt;(r.get()))</code> will eventually result in undefined behavior, attempting to delete the same object twice.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </p>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="13" id="memory.smartptr.shared.cast.13">
    
    <pre><code><cxx-signature>template&lt;class T, class U&gt; shared_ptr&lt;T&gt; reinterpret_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="14" id="memory.smartptr.shared.cast.14">
    
    <dt>Requires:</dt><dd>The expression <code>reinterpret_cast&lt;T*&gt;((U*)0)</code> shall be well formed.</dd>
  </cxx-requires>
        <cxx-returns para_num="15" id="memory.smartptr.shared.cast.15">
    
    <dt>Returns:</dt><dd><code>shared_ptr&lt;T&gt;(r, reinterpret_cast&lt;typename shared_ptr&lt;T&gt;::element_type*&gt;(r.get()))</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.smartptr.weak">
    

    <section>
      <header><span class="section-number">8.2.2</span> <h1 data-bookmark-label="8.2.2 Class template weak_ptr">Class template weak_ptr</h1> <span style="float:right"><a href="#memory.smartptr.weak">[memory.smartptr.weak]</a></span></header>
      
    

<pre><code>
namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  template&lt;class T&gt; class weak_ptr {
  public:
    typedef typename remove_extent_t&lt;T&gt; element_type;

    <cxx-ref insynopsis="" to="memory.smartptr.weak.const">// <i><a title="memory.smartptr.weak.const" href="#memory.smartptr.weak.const">8.2.2.1</a>, weak_ptr constructors</i></cxx-ref>
    constexpr weak_ptr() noexcept;
    template&lt;class Y&gt; weak_ptr(shared_ptr&lt;Y&gt; const&amp; r) noexcept;
    weak_ptr(weak_ptr const&amp; r) noexcept;
    template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt; const&amp; r) noexcept;
    weak_ptr(weak_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;

    // <cxx-ref in="cxx" to="util.smartptr.weak.dest">C++14 <span title="util.smartptr.weak.dest">§20.8.2.3.2</span></cxx-ref>
    ~weak_ptr();

    // <cxx-ref in="cxx" to="util.smartptr.weak.assign">C++14 <span title="util.smartptr.weak.assign">§20.8.2.3.3</span></cxx-ref>
    weak_ptr&amp; operator=(weak_ptr const&amp; r) noexcept;
    template&lt;class Y&gt; weak_ptr&amp; operator=(weak_ptr&lt;Y&gt; const&amp; r) noexcept;
    template&lt;class Y&gt; weak_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; r) noexcept;
    weak_ptr&amp; operator=(weak_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt; weak_ptr&amp; operator=(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;

    // <cxx-ref in="cxx" to="util.smartptr.weak.mod">C++14 <span title="util.smartptr.weak.mod">§20.8.2.3.4</span></cxx-ref>
    void swap(weak_ptr&amp; r) noexcept;
    void reset() noexcept;

    // <cxx-ref in="cxx" to="util.smartptr.weak.obs">C++14 <span title="util.smartptr.weak.obs">§20.8.2.3.5</span></cxx-ref>
    long use_count() const noexcept;
    bool expired() const noexcept;
    shared_ptr&lt;T&gt; lock() const noexcept;
    template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) const;
    template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) const;
  };

  // <cxx-ref in="cxx" to="util.smartptr.weak.spec">C++14 <span title="util.smartptr.weak.spec">§20.8.2.3.6</span></cxx-ref>
  template&lt;class T&gt; void swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b) noexcept;

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>

  <cxx-section id="memory.smartptr.weak.const">
    

    <section>
      <header><span class="section-number">8.2.2.1</span> <h1 data-bookmark-label="8.2.2.1 weak_ptr constructors"><code>weak_ptr</code> constructors</h1> <span style="float:right"><a href="#memory.smartptr.weak.const">[memory.smartptr.weak.const]</a></span></header>
      
    

      <cxx-function para_num="1" id="memory.smartptr.weak.const.1">
    
    <pre><code><cxx-signature>weak_ptr(const weak_ptr&amp; r) noexcept;</cxx-signature><cxx-signature>template&lt;class Y&gt; weak_ptr(const weak_ptr&lt;Y&gt;&amp; r) noexcept;</cxx-signature><cxx-signature>template&lt;class Y&gt; weak_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        
        

        <cxx-requires para_num="2" id="memory.smartptr.weak.const.2">
    
    <dt>Requires:</dt><dd>The second and third constructors shall not participate in the overload resolution unless <code>Y*</code> is <i>compatible with</i> <code>T*</code>.</dd>
  </cxx-requires>

        <cxx-effects para_num="3" id="memory.smartptr.weak.const.3">
    
    <dt>Effects:</dt><dd>If <code>r</code> is <i>empty</i>, constructs an <i>empty</i> <code>weak_ptr</code> object; otherwise, constructs a <code>weak_ptr</code> object that <i>shares ownership</i> with <code>r</code> and stores a copy of the pointer stored in <code>r</code>.</dd>
  </cxx-effects>

        <cxx-postconditions para_num="4" id="memory.smartptr.weak.const.4">
    
    <dt>Postconditions:</dt><dd><code>use_count() == r.use_count()</code>.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

    
    </section>
  </cxx-section>

    
    </section>
  </cxx-section>

  
    </section>
  </cxx-section>

  <cxx-section id="memory.type.erased.allocator">
    

    <section>
      <header><span class="section-number">8.3</span> <h1 data-bookmark-label="8.3 Type-erased allocator">Type-erased allocator</h1> <span style="float:right"><a href="#memory.type.erased.allocator">[memory.type.erased.allocator]</a></span></header>
      
    

    <p para_num="1" id="memory.type.erased.allocator.1">
      A <dfn>type-erased allocator</dfn> is an allocator or memory resource, <code>alloc</code>,
      used to allocate internal data structures for an object <code>X</code> of type <code>C</code>,
      but where <code>C</code> is not dependent on the type of <code>alloc</code>.
      Once <code>alloc</code> has been supplied to <code>X</code> (typically as a constructor argument),
      <code>alloc</code> can be retrieved from <code>X</code> only as a pointer <code>rptr</code> of static type <code>std::experimental::pmr::memory_resource*</code> (<cxx-ref to="memory.resource"><a title="memory.resource" href="#memory.resource">8.5</a></cxx-ref>).
      The process by which <code>rptr</code> is computed from <code>alloc</code> depends on the type of <code>alloc</code> as described in <cxx-ref to="tab:memory.resource.type.erased.allocator"><a title="tab:memory.resource.type.erased.allocator" href="#tab:memory.resource.type.erased.allocator">Table 13</a></cxx-ref>:
    </p>

    <table is="cxx-table" id="tab:memory.resource.type.erased.allocator">
    

    <caption>Table 13 — <wbr><span>Computed <code>memory_resource</code> for type-erased allocator</span></caption>
    
      
      <thead>
        <tr>
          <th>If the type of <code>alloc</code> is</th>
          <th>then the value of <code>rptr</code> is</th>
        </tr>
      </thead>
      <tbody><tr>
        <td>non-existent — no <code>alloc</code> specified</td>
        <td>The value of <code>experimental::pmr::get_default_resource()</code> at the time of construction.</td>
      </tr>
      <tr>
        <td><code>nullptr_t</code></td>
        <td>The value of <code>experimental::pmr::get_default_resource()</code> at the time of construction.</td>
      </tr>
      <tr>
        <td>a pointer type convertible to <code>pmr::memory_resource*</code></td>
        <td><code>static_cast&lt;experimental::pmr::memory_resource*&gt;(alloc)</code></td>
      </tr>
      <tr>
        <td><code>pmr::polymorphic_allocator&lt;U&gt;</code></td>
        <td><code>alloc.resource()</code></td>
      </tr>
      <tr>
        <td>any other type meeting the Allocator requirements (<cxx-ref in="cxx" to="allocator.requirements">C++14 <span title="allocator.requirements">§17.6.3.5</span></cxx-ref>)</td>
        <td>a pointer to a value of type <code>experimental::pmr::resource_adaptor&lt;A&gt;</code> where <code>A</code> is the type of <code>alloc</code>.
        <code>rptr</code> remains valid only for the lifetime of <code>X</code>.</td>
      </tr>
      <tr>
        <td>None of the above</td>
        <td>The program is ill-formed.</td>
      </tr>
    </tbody>
  </table>

    <p para_num="2" id="memory.type.erased.allocator.2">Additionally, class <code>C</code> shall meet the following requirements:</p>
    <ul>
      <li><code>C::allocator_type</code> shall be identical to <code>std::experimental::erased_type</code>.</li>
      <li><code>X.get_memory_resource()</code> returns <code>rptr</code>.</li>
    </ul>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.resource.synop">
    

    <section>
      <header><span class="section-number">8.4</span> <h1 data-bookmark-label="8.4 Header &lt;experimental/memory_resource&gt; synopsis">Header <code>&lt;experimental/memory_resource&gt;</code> synopsis</h1> <span style="float:right"><a href="#memory.resource.synop">[memory.resource.synop]</a></span></header>
      
    

    <pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  class memory_resource;

  bool operator==(const memory_resource&amp; a,
                  const memory_resource&amp; b) noexcept;
  bool operator!=(const memory_resource&amp; a,
                  const memory_resource&amp; b) noexcept;

  template &lt;class Tp&gt; class polymorphic_allocator;

  template &lt;class T1, class T2&gt;
  bool operator==(const polymorphic_allocator&lt;T1&gt;&amp; a,
                  const polymorphic_allocator&lt;T2&gt;&amp; b) noexcept;
  template &lt;class T1, class T2&gt;
  bool operator!=(const polymorphic_allocator&lt;T1&gt;&amp; a,
                  const polymorphic_allocator&lt;T2&gt;&amp; b) noexcept;

  // The name <var>resource_adaptor_imp</var> is for exposition only.
  template &lt;class Allocator&gt; class <var>resource_adaptor_imp</var>;

  template &lt;class Allocator&gt;
    using resource_adaptor = <var>resource_adaptor_imp</var>&lt;
      allocator_traits&lt;Allocator&gt;::rebind_alloc&lt;char&gt;&gt;;

  // Global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;

  // The default memory resource
  memory_resource* set_default_resource(memory_resource* r) noexcept;
  memory_resource* get_default_resource() noexcept;

  // Standard memory resources
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.resource">
    

    <section>
      <header><span class="section-number">8.5</span> <h1 data-bookmark-label="8.5 Class memory_resource">Class <code>memory_resource</code></h1> <span style="float:right"><a href="#memory.resource">[memory.resource]</a></span></header>
      
    

    <cxx-section id="memory.resource.overview">
    

    <section>
      <header><span class="section-number">8.5.1</span> <h1 data-bookmark-label="8.5.1 Class memory_resource overview">Class <code>memory_resource</code> overview</h1> <span style="float:right"><a href="#memory.resource.overview">[memory.resource.overview]</a></span></header>
      
      
      <p para_num="1" id="memory.resource.overview.1">
        The <code>memory_resource</code> class is an abstract interface to an unbounded set of classes encapsulating memory resources.
      </p>

      <pre><code>class memory_resource {
  // For exposition only
  static constexpr size_t max_align = alignof(max_align_t);

public:
  virtual ~memory_resource();

  void* allocate(size_t bytes, size_t alignment = max_align);
  void deallocate(void* p, size_t bytes,
                  size_t alignment = max_align);

  bool is_equal(const memory_resource&amp; other) const noexcept;

protected:
  virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
  virtual void do_deallocate(void* p, size_t bytes,
                             size_t alignment) = 0;

  virtual bool do_is_equal(const memory_resource&amp; other) const noexcept = 0;
};</code></pre>

    
    </section>
  </cxx-section>

    <cxx-section id="memory.resource.public">
    

    <section>
      <header><span class="section-number">8.5.2</span> <h1 data-bookmark-label="8.5.2 memory_resource public member functions"><code>memory_resource</code> public member functions</h1> <span style="float:right"><a href="#memory.resource.public">[memory.resource.public]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.resource.public.1">
    
    <pre><code><cxx-signature>~memory_resource();</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="memory.resource.public.2">
    
    <dt>Effects:</dt><dd>Destroys this memory_resource.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.resource.public.3">
    
    <pre><code><cxx-signature>void* allocate(size_t bytes, size_t alignment = max_align);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="4" id="memory.resource.public.4">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return do_allocate(bytes, alignment);</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="memory.resource.public.5">
    
    <pre><code><cxx-signature>void deallocate(void* p, size_t bytes, size_t alignment = max_align);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="6" id="memory.resource.public.6">
    
    <dt>Effects:</dt><dd>Equivalent to <code>do_deallocate(p, bytes, alignment);</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="memory.resource.public.7">
    
    <pre><code><cxx-signature>bool is_equal(const memory_resource&amp; other) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="8" id="memory.resource.public.8">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return do_is_equal(other);</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.resource.priv">
    

    <section>
      <header><span class="section-number">8.5.3</span> <h1 data-bookmark-label="8.5.3 memory_resource protected virtual member functions"><code>memory_resource</code> protected virtual member functions</h1> <span style="float:right"><a href="#memory.resource.priv">[memory.resource.priv]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.resource.priv.1">
    
    <pre><code><cxx-signature>virtual void* do_allocate(size_t bytes, size_t alignment) = 0;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="memory.resource.priv.2">
    
    <dt>Requires:</dt><dd>Alignment shall be a power of two.</dd>
  </cxx-requires>
        <cxx-returns para_num="3" id="memory.resource.priv.3">
    
    <dt>Returns:</dt><dd>A derived class shall implement this function to return a pointer to allocated storage (<cxx-ref in="cxx" to="basic.stc.dynamic.deallocation">C++14 <span title="basic.stc.dynamic.deallocation">§3.7.4.2</span></cxx-ref>) with a size of at least <code>bytes</code>.
        The returned storage is aligned to the specified alignment, if such alignment is supported;
        otherwise it is aligned to <code>max_align</code>.</dd>
  </cxx-returns>
        <cxx-throws para_num="4" id="memory.resource.priv.4">
    
    <dt>Throws:</dt><dd>A derived class implementation shall throw an 
appropriate exception if it is unable to allocate memory with the 
requested size and alignment.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="memory.resource.priv.5">
    
    <pre><code><cxx-signature>virtual void do_deallocate(void* p, size_t bytes, size_t alignment) = 0;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-requires para_num="6" id="memory.resource.priv.6">
    
    <dt>Requires:</dt><dd><code>p</code> shall have been returned from a prior call to <code>allocate(bytes, alignment)</code> on a memory resource equal to <code>*this</code>,
        and the storage at <code>p</code> shall not yet have been deallocated.</dd>
  </cxx-requires>
        <cxx-effects para_num="7" id="memory.resource.priv.7">
    
    <dt>Effects:</dt><dd>A derived class shall implement this function to dispose of allocated storage.</dd>
  </cxx-effects>
        <cxx-throws para_num="8" id="memory.resource.priv.8">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="memory.resource.priv.9">
    
    <pre><code><cxx-signature>virtual bool do_is_equal(const memory_resource&amp; other) const noexcept = 0;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="10" id="memory.resource.priv.10">
    
    <dt>Returns:</dt><dd>A derived class shall implement this function to return <code>true</code> if memory allocated from this can be deallocated from other and vice-versa;
        otherwise it shall return false.
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The most-derived type of other might not match the type of this.
        For a derived class, D, a typical implementation of this function will compute <code>dynamic_cast&lt;const D*&gt;(&amp;other)</code> and go no further (i.e., return <code>false</code>) if it returns <code>nullptr</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.resource.eq">
    

    <section>
      <header><span class="section-number">8.5.4</span> <h1 data-bookmark-label="8.5.4 memory_resource equality"><code>memory_resource</code> equality</h1> <span style="float:right"><a href="#memory.resource.eq">[memory.resource.eq]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.resource.eq.1">
    
    <pre><code><cxx-signature>bool operator==(const memory_resource&amp; a, const memory_resource&amp; b) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="memory.resource.eq.2">
    
    <dt>Returns:</dt><dd><code>&amp;a == &amp;b || a.is_equal(b)</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.resource.eq.3">
    
    <pre><code><cxx-signature>bool operator!=(const memory_resource&amp; a, const memory_resource&amp; b) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="4" id="memory.resource.eq.4">
    
    <dt>Returns:</dt><dd><code>!(a == b)</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.polymorphic.allocator.class">
    

    <section>
      <header><span class="section-number">8.6</span> <h1 data-bookmark-label="8.6 Class template polymorphic_allocator">Class template <code>polymorphic_allocator</code></h1> <span style="float:right"><a href="#memory.polymorphic.allocator.class">[memory.polymorphic.allocator.class]</a></span></header>
      
    

    <cxx-section id="memory.polymorphic.allocator.overview">
    

    <section>
      <header><span class="section-number">8.6.1</span> <h1 data-bookmark-label="8.6.1 Class template polymorphic_allocator overview">Class template <code>polymorphic_allocator</code> overview</h1> <span style="float:right"><a href="#memory.polymorphic.allocator.overview">[memory.polymorphic.allocator.overview]</a></span></header>
      
      

      <p para_num="1" id="memory.polymorphic.allocator.overview.1">
        A specialization of class template <code>pmr::polymorphic_allocator</code> conforms to the <code>Allocator</code> requirements (<cxx-ref in="cxx" to="allocator.requirements">C++14 <span title="allocator.requirements">§17.6.3.5</span></cxx-ref>).
        Constructed with different memory resources, different instances of the same specialization of <code>pmr::polymorphic_allocator</code> can exhibit entirely different allocation behavior.
        This runtime polymorphism allows objects that use <code>polymorphic_allocator</code> to behave as if they used different allocator types at run time even though they use the same static allocator type.
      </p>

      <pre><code>template &lt;class Tp&gt;
class polymorphic_allocator {
  memory_resource* m_resource; // For exposition only

public:
  typedef Tp value_type;

  polymorphic_allocator() noexcept;
  polymorphic_allocator(memory_resource* r);

  polymorphic_allocator(const polymorphic_allocator&amp; other) = default;

  template &lt;class U&gt;
    polymorphic_allocator(const polymorphic_allocator&lt;U&gt;&amp; other) noexcept;

  polymorphic_allocator&amp;
    operator=(const polymorphic_allocator&amp; rhs) = default;

  Tp* allocate(size_t n);
  void deallocate(Tp* p, size_t n);

  template &lt;class T, class... Args&gt;
    void construct(T* p, Args&amp;&amp;... args);

  // Specializations for pair using piecewise construction
  template &lt;class T1, class T2, class... Args1, class... Args2&gt;
    void construct(pair&lt;T1,T2&gt;* p, piecewise_construct_t,
                   tuple&lt;Args1...&gt; x, tuple&lt;Args2...&gt; y);
  template &lt;class T1, class T2&gt;
    void construct(pair&lt;T1,T2&gt;* p);
  template &lt;class T1, class T2, class U, class V&gt;
    void construct(pair&lt;T1,T2&gt;* p, U&amp;&amp; x, V&amp;&amp; y);
  template &lt;class T1, class T2, class U, class V&gt;
    void construct(pair&lt;T1,T2&gt;* p, const std::pair&lt;U, V&gt;&amp; pr);
  template &lt;class T1, class T2, class U, class V&gt;
    void construct(pair&lt;T1,T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; pr);

  template &lt;class T&gt;
    void destroy(T* p);

  // Return a default-constructed allocator (no allocator propagation)
  polymorphic_allocator select_on_container_copy_construction() const;

  memory_resource* resource() const;
};</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.polymorphic.allocator.ctor">
    

    <section>
      <header><span class="section-number">8.6.2</span> <h1 data-bookmark-label="8.6.2 polymorphic_allocator constructors"><code>polymorphic_allocator</code> constructors</h1> <span style="float:right"><a href="#memory.polymorphic.allocator.ctor">[memory.polymorphic.allocator.ctor]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.polymorphic.allocator.ctor.1">
    
    <pre><code><cxx-signature>polymorphic_allocator() noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="memory.polymorphic.allocator.ctor.2">
    
    <dt>Effects:</dt><dd>Sets <code>m_resource</code> to <code>get_default_resource()</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.polymorphic.allocator.ctor.3">
    
    <pre><code><cxx-signature>polymorphic_allocator(memory_resource* r);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="4" id="memory.polymorphic.allocator.ctor.4">
    
    <dt>Requires:</dt><dd><code>r</code> is non-null.</dd>
  </cxx-requires>
        <cxx-effects para_num="5" id="memory.polymorphic.allocator.ctor.5">
    
    <dt>Effects:</dt><dd>Sets <code>m_resource</code> to <code>r</code>.</dd>
  </cxx-effects>
        <cxx-throws para_num="6" id="memory.polymorphic.allocator.ctor.6">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
        <cxx-notes para_num="7" id="memory.polymorphic.allocator.ctor.7">
    
    <dt>Notes:</dt><dd>This constructor provides an implicit conversion from <code>memory_resource*</code>.</dd>
  </cxx-notes>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="8" id="memory.polymorphic.allocator.ctor.8">
    
    <pre><code><cxx-signature>template &lt;class U&gt;
polymorphic_allocator(const polymorphic_allocator&lt;U&gt;&amp; other) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="9" id="memory.polymorphic.allocator.ctor.9">
    
    <dt>Effects:</dt><dd>Sets <code>m_resource</code> to <code>other.resource()</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.polymorphic.allocator.mem">
    

    <section>
      <header><span class="section-number">8.6.3</span> <h1 data-bookmark-label="8.6.3 polymorphic_allocator member functions"><code>polymorphic_allocator</code> member functions</h1> <span style="float:right"><a href="#memory.polymorphic.allocator.mem">[memory.polymorphic.allocator.mem]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.polymorphic.allocator.mem.1">
    
    <pre><code><cxx-signature>Tp* allocate(size_t n);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="2" id="memory.polymorphic.allocator.mem.2">
    
    <dt>Returns:</dt><dd>Equivalent to <code>return static_cast&lt;Tp*&gt;(m_resource-&gt;allocate(n * sizeof(Tp), alignof(Tp)));</code></dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.polymorphic.allocator.mem.3">
    
    <pre><code><cxx-signature>void deallocate(Tp* p, size_t n);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-requires para_num="4" id="memory.polymorphic.allocator.mem.4">
    
    <dt>Requires:</dt><dd><code>p</code> was allocated from a memory resource, <code>x</code>, equal to <code>*m_resource</code>, using <code>x.allocate(n * sizeof(Tp), alignof(Tp))</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="5" id="memory.polymorphic.allocator.mem.5">
    
    <dt>Effects:</dt><dd>Equivalent to <code>m_resource-&gt;deallocate(p, n * sizeof(Tp), alignof(Tp))</code>.</dd>
  </cxx-effects>
        <cxx-throws para_num="6" id="memory.polymorphic.allocator.mem.6">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="memory.polymorphic.allocator.mem.7">
    
    <pre><code><cxx-signature>template &lt;class T, class... Args&gt;
void construct(T* p, Args&amp;&amp;... args);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-requires para_num="8" id="memory.polymorphic.allocator.mem.8">
    
    <dt>Requires:</dt><dd><cxx-term><i>Uses-allocator construction</i></cxx-term> of <code>T</code>
        with allocator <code>this-&gt;resource()</code> (see <cxx-ref to="mods.allocator.uses"><a title="mods.allocator.uses" href="#mods.allocator.uses">2.1</a></cxx-ref>)
        and constructor arguments <code>std::forward&lt;Args&gt;(args)...</code> is well-formed.
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    <cxx-term><i>uses-allocator construction</i></cxx-term> is always well formed for types that do not use allocators.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></dd>
  </cxx-requires>
        <cxx-effects para_num="9" id="memory.polymorphic.allocator.mem.9">
    
    <dt>Effects:</dt><dd>Construct a <code>T</code> object at <code>p</code> by <cxx-term><i>uses-allocator construction</i></cxx-term>
        with allocator <code>this-&gt;resource()</code> (<cxx-ref to="mods.allocator.uses"><a title="mods.allocator.uses" href="#mods.allocator.uses">2.1</a></cxx-ref>)
        and constructor arguments <code>std::forward&lt;Args&gt;(args)...</code>.</dd>
  </cxx-effects>
        <cxx-throws para_num="10" id="memory.polymorphic.allocator.mem.10">
    
    <dt>Throws:</dt><dd>Nothing unless the constructor for <code>T</code> throws.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="11" id="memory.polymorphic.allocator.mem.11">
    
    <pre><code><cxx-signature>template &lt;class T1, class T2, class... Args1, class... Args2&gt;
void construct(pair&lt;T1,T2&gt;* p, piecewise_construct_t,
               tuple&lt;Args1...&gt; x, tuple&lt;Args2...&gt; y);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="12" id="memory.polymorphic.allocator.mem.12">
    
    <dt>Effects:</dt><dd>
          Let <code>xprime</code> be a <code>tuple</code> constructed from <code>x</code> according to the appropriate rule from the following list.
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The following description can be summarized as constructing a <code>std::pair&lt;T1,T2&gt;</code> object at <code>p</code>
          as if by separate <i>uses-allocator construction</i> with allocator <code>this-&gt;resource()</code> (<cxx-ref to="mods.allocator.uses"><a title="mods.allocator.uses" href="#mods.allocator.uses">2.1</a></cxx-ref>)
          of <code>p-&gt;first</code> using the elements of <code>x</code>
          and <code>p-&gt;second</code> using the elements of <code>y</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
          <ul>
            <li>If <code>uses_allocator_v&lt;T1,memory_resource*&gt;</code> is <code>false</code> and
            <code>is_constructible_v&lt;T,Args1...&gt;</code> is <code>true</code>, then <code>xprime</code> is <code>x</code>.</li>
            <li>Otherwise, if <code>uses_allocator_v&lt;T1,memory_resource*&gt;</code> is <code>true</code> and
            <code>is_constructible_v&lt;T1,allocator_arg_t,memory_resource*,Args1...&gt;</code> is <code>true</code>,
            then <code>xprime</code> is <code>tuple_cat(make_tuple(allocator_arg, this-&gt;resource()), std::move(x))</code>.</li>
            <li>Otherwise, if <code>uses_allocator_v&lt;T1,memory_resource*&gt;</code> is <code>true</code> and
            <code>is_constructible_v&lt;T1,Args1...,memory_resource*&gt;</code> is <code>true</code>,
            then <code>xprime</code> is <code>tuple_cat(std::move(x), make_tuple(this-&gt;resource()))</code>.</li>
            <li>Otherwise the program is ill formed.</li>
          </ul>
          and let <code>yprime</code> be a tuple constructed from <code>y</code>
          according to the appropriate rule from the following list:
          <ul>
            <li>If <code>uses_allocator_v&lt;T2,memory_resource*&gt;</code> is <code>false</code> and
            <code>is_constructible_v&lt;T,Args2...&gt;</code> is <code>true</code>, then <code>yprime</code> is <code>y</code>.</li>
            <li>Otherwise, if <code>uses_allocator_v&lt;T2,memory_resource*&gt;</code> is <code>true</code> and
            <code>is_constructible_v&lt;T2,allocator_arg_t,memory_resource*,Args2...&gt;</code> is <code>true</code>, then <code>yprime</code> is <code>tuple_cat(make_tuple(allocator_arg, this-&gt;resource()), std::move(y))</code>.</li>
            <li>Otherwise, if <code>uses_allocator_v&lt;T2,memory_resource*&gt;</code> is <code>true</code> and
            <code>is_constructible_v&lt;T2,Args2...,memory_resource*&gt;</code> is <code>true</code>, then
            <code>yprime</code> is <code>tuple_cat(std::move(y), make_tuple(this-&gt;resource()))</code>.</li>
            <li>Otherwise the program is ill formed.</li>
          </ul>
          then this function constructs a <code>std::pair&lt;T1,T2&gt;</code> object at <code>p</code> using constructor arguments <code>piecewise_construct, xprime, yprime</code>.
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="13" id="memory.polymorphic.allocator.mem.13">
    
    <pre><code><cxx-signature>template &lt;class T1, class T2&gt;
void construct(std::pair&lt;T1,T2&gt;* p);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="14" id="memory.polymorphic.allocator.mem.14">
    
    <dt>Effects:</dt><dd>Equivalent to <code>this-&gt;construct(p, piecewise_construct, tuple&lt;&gt;(), tuple&lt;&gt;());</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="15" id="memory.polymorphic.allocator.mem.15">
    
    <pre><code><cxx-signature>template &lt;class T1, class T2, class U, class V&gt;
void construct(std::pair&lt;T1,T2&gt;* p, U&amp;&amp; x, V&amp;&amp; y);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="16" id="memory.polymorphic.allocator.mem.16">
    
    <dt>Effects:</dt><dd>Equivalent to <code>this-&gt;construct(p, piecewise_construct, <w-br><wbr></w-br>forward_as_tuple(std::forward&lt;U&gt;(x)), <w-br><wbr></w-br>forward_as_tuple(std::forward&lt;V&gt;(y)));</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="17" id="memory.polymorphic.allocator.mem.17">
    
    <pre><code><cxx-signature>template &lt;class T1, class T2, class U, class V&gt;
void construct(std::pair&lt;T1,T2&gt;* p, const std::pair&lt;U, V&gt;&amp; pr);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="18" id="memory.polymorphic.allocator.mem.18">
    
    <dt>Effects:</dt><dd>Equivalent to <code>this-&gt;construct(p, piecewise_construct, <w-br><wbr></w-br>forward_as_tuple(pr.first), <w-br><wbr></w-br>forward_as_tuple(pr.second));</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="19" id="memory.polymorphic.allocator.mem.19">
    
    <pre><code><cxx-signature>template &lt;class T1, class T2, class U, class V&gt;
void construct(std::pair&lt;T1,T2&gt;* p, std::pair&lt;U, V&gt;&amp;&amp; pr);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="20" id="memory.polymorphic.allocator.mem.20">
    
    <dt>Effects:</dt><dd>Equivalent to <code>this-&gt;construct(p, piecewise_construct,
        <w-br><wbr></w-br>forward_as_tuple(std::forward&lt;U&gt;(pr.first)),
        <w-br><wbr></w-br>forward_as_tuple(std::forward&lt;V&gt;(pr.second)));</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="21" id="memory.polymorphic.allocator.mem.21">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
void destroy(T* p);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="22" id="memory.polymorphic.allocator.mem.22">
    
    <dt>Effects:</dt><dd><code>p-&gt;~T()</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="23" id="memory.polymorphic.allocator.mem.23">
    
    <pre><code><cxx-signature>polymorphic_allocator select_on_container_copy_construction() const;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="24" id="memory.polymorphic.allocator.mem.24">
    
    <dt>Returns:</dt><dd><code>polymorphic_allocator()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="25" id="memory.polymorphic.allocator.mem.25">
    
    <pre><code><cxx-signature>memory_resource* resource() const;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="26" id="memory.polymorphic.allocator.mem.26">
    
    <dt>Returns:</dt><dd><code>m_resource</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.polymorphic.allocator.eq">
    

    <section>
      <header><span class="section-number">8.6.4</span> <h1 data-bookmark-label="8.6.4 polymorphic_allocator equality">polymorphic_allocator equality</h1> <span style="float:right"><a href="#memory.polymorphic.allocator.eq">[memory.polymorphic.allocator.eq]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.polymorphic.allocator.eq.1">
    
    <pre><code><cxx-signature>template &lt;class T1, class T2&gt;
bool operator==(const polymorphic_allocator&lt;T1&gt;&amp; a,
                const polymorphic_allocator&lt;T2&gt;&amp; b) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="2" id="memory.polymorphic.allocator.eq.2">
    
    <dt>Returns:</dt><dd><code>*a.resource() == *b.resource()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.polymorphic.allocator.eq.3">
    
    <pre><code><cxx-signature>template &lt;class T1, class T2&gt;
bool operator!=(const polymorphic_allocator&lt;T1&gt;&amp; a,
                const polymorphic_allocator&lt;T2&gt;&amp; b) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="4" id="memory.polymorphic.allocator.eq.4">
    
    <dt>Returns:</dt><dd><code>! (a == b)</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.resource.adaptor">
    

    <section>
      <header><span class="section-number">8.7</span> <h1 data-bookmark-label="8.7 template alias resource_adaptor">template alias <code>resource_adaptor</code></h1> <span style="float:right"><a href="#memory.resource.adaptor">[memory.resource.adaptor]</a></span></header>
      
    

    <cxx-section id="memory.resource.adaptor.overview">
    

    <section>
      <header><span class="section-number">8.7.1</span> <h1 data-bookmark-label="8.7.1 resource_adaptor"><code>resource_adaptor</code></h1> <span style="float:right"><a href="#memory.resource.adaptor.overview">[memory.resource.adaptor.overview]</a></span></header>
      
      

      <p para_num="1" id="memory.resource.adaptor.overview.1">
        An instance of <code>resource_adaptor&lt;Allocator&gt;</code> is an adaptor that wraps a <code>memory_resource</code> interface around <code>Allocator</code>.
        In order that <code>resource_adaptor&lt;X&lt;T&gt;&gt;</code> and <code>resource_adaptor&lt;X&lt;U&gt;&gt;</code> are the same type for any allocator template <code>X</code> and types <code>T</code> and <code>U</code>,
        <code>resource_adaptor&lt;Allocator&gt;</code> is rendered as an alias to a class template such that <code>Allocator</code> is rebound to a <code>char</code> value type in every specialization of the class template.
        The requirements on this class template are defined below.
        The name <code><var>resource_adaptor_imp</var></code> is for exposition only and is not normative,
        but the definitions of the members of that class, whatever its name, are normative.
        In addition to the <code>Allocator</code> requirements (<cxx-ref in="cxx" to="allocator.requirements">C++14 <span title="allocator.requirements">§17.6.3.5</span></cxx-ref>), the parameter to <code>resource_adaptor</code> shall meet the following additional requirements:
      </p>
      <ul>
        <li><code>typename allocator_traits&lt;Allocator&gt;::pointer</code> shall be identical to <code>typename allocator_traits&lt;Allocator&gt;::value_type*</code>.</li>
        <li><code>typename allocator_traits&lt;Allocator&gt;::const_pointer</code> shall be identical to <code>typename allocator_traits&lt;Allocator&gt;::value_type const*</code>.</li>
        <li><code>typename allocator_traits&lt;Allocator&gt;::void_pointer</code> shall be identical to <code>void*</code>.</li>
        <li><code>typename allocator_traits&lt;Allocator&gt;::const_void_pointer</code> shall be identical to <code>void const*</code>.</li>
      </ul>

      <pre><code>
// The name <var>resource_adaptor_imp</var> is for exposition only.
template &lt;class Allocator&gt;
class <var>resource_adaptor_imp</var> : public memory_resource {
  // for exposition only
  Allocator m_alloc;

public:
  typedef Allocator allocator_type;

  <var>resource_adaptor_imp</var>() = default;
  <var>resource_adaptor_imp</var>(const <var>resource_adaptor_imp</var>&amp;) = default;
  <var>resource_adaptor_imp</var>(<var>resource_adaptor_imp</var>&amp;&amp;) = default;

  explicit <var>resource_adaptor_imp</var>(const Allocator&amp; a2);
  explicit <var>resource_adaptor_imp</var>(Allocator&amp;&amp; a2);

  <var>resource_adaptor_imp</var>&amp; operator=(const <var>resource_adaptor_imp</var>&amp;) = default;

  allocator_type get_allocator() const { return m_alloc; }

protected:
  virtual void* do_allocate(size_t bytes, size_t alignment);
  virtual void do_deallocate(void* p, size_t bytes, size_t alignment);

  virtual bool do_is_equal(const memory_resource&amp; other) const noexcept;
};

template &lt;class Allocator&gt;
  using resource_adaptor = typename <var>resource_adaptor_imp</var>&lt;
    allocator_traits&lt;Allocator&gt;::template rebind_alloc&lt;char&gt;&gt;;</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.resource.adaptor.ctor">
    

    <section>
      <header><span class="section-number">8.7.2</span> <h1 data-bookmark-label="8.7.2 resource_adaptor_imp constructors"><code><var>resource_adaptor_imp</var></code> constructors</h1> <span style="float:right"><a href="#memory.resource.adaptor.ctor">[memory.resource.adaptor.ctor]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.resource.adaptor.ctor.1">
    
    <pre><code><cxx-signature>explicit <var>resource_adaptor_imp</var>(const Allocator&amp; a2);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="2" id="memory.resource.adaptor.ctor.2">
    
    <dt>Effects:</dt><dd>Initializes <code>m_alloc</code> with <code>a2</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.resource.adaptor.ctor.3">
    
    <pre><code><cxx-signature>explicit <var>resource_adaptor_imp</var>(Allocator&amp;&amp; a2);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="4" id="memory.resource.adaptor.ctor.4">
    
    <dt>Effects:</dt><dd>Initializes <code>m_alloc</code> with <code>std::move(a2)</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.resource.adaptor.mem">
    

    <section>
      <header><span class="section-number">8.7.3</span> <h1 data-bookmark-label="8.7.3 resource_adaptor_imp member functions"><code><var>resource_adaptor_imp</var></code> member functions</h1> <span style="float:right"><a href="#memory.resource.adaptor.mem">[memory.resource.adaptor.mem]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.resource.adaptor.mem.1">
    
    <pre><code><cxx-signature>void* do_allocate(size_t bytes, size_t alignment);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="2" id="memory.resource.adaptor.mem.2">
    
    <dt>Returns:</dt><dd>Allocated memory obtained by calling <code>m_alloc.allocate</code>. The size and alignment of the allocated memory shall meet the requirements for a class derived from <code>memory_resource</code> (<cxx-ref to="memory.resource"><a title="memory.resource" href="#memory.resource">8.5</a></cxx-ref>).</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.resource.adaptor.mem.3">
    
    <pre><code><cxx-signature>void do_deallocate(void* p, size_t bytes, size_t alignment);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-requires para_num="4" id="memory.resource.adaptor.mem.4">
    
    <dt>Requires:</dt><dd><code>p</code> was previously allocated using <code>A.allocate</code>, where <code>A == m_alloc</code>, and not subsequently deallocated.</dd>
  </cxx-requires>
        <cxx-effects para_num="5" id="memory.resource.adaptor.mem.5">
    
    <dt>Effects:</dt><dd>Returns memory to the allocator using <code>m_alloc.deallocate()</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="memory.resource.adaptor.mem.6">
    
    <pre><code><cxx-signature>bool do_is_equal(const memory_resource&amp; other) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        <p para_num="7" id="memory.resource.adaptor.mem.7">Let <code>p</code> be <code>dynamic_cast&lt;const <var>resource_adaptor_imp</var>*&gt;(&amp;other)</code>.</p>
        <cxx-returns para_num="8" id="memory.resource.adaptor.mem.8">
    
    <dt>Returns:</dt><dd><code>false</code> if <code>p</code> is null, otherwise the value of <code>m_alloc == p-&gt;m_alloc</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.resource.global">
    

    <section>
      <header><span class="section-number">8.8</span> <h1 data-bookmark-label="8.8 Access to program-wide memory_resource objects">Access to program-wide <code>memory_resource</code> objects</h1> <span style="float:right"><a href="#memory.resource.global">[memory.resource.global]</a></span></header>
      
    

    <cxx-function para_num="1" id="memory.resource.global.1">
    
    <pre><code><cxx-signature>memory_resource* new_delete_resource() noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="2" id="memory.resource.global.2">
    
    <dt>Returns:</dt><dd>A pointer to a static-duration object of a type derived from <code>memory_resource</code> that can serve as a resource for allocating memory using <code>::operator new</code> and <code>::operator delete</code>. The same value is returned every time this function is called. For return value <code>p</code> and memory resource <code>r</code>, <code>p-&gt;is_equal(r)</code> returns <code>&amp;r == p</code>.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="3" id="memory.resource.global.3">
    
    <pre><code><cxx-signature>memory_resource* null_memory_resource() noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="4" id="memory.resource.global.4">
    
    <dt>Returns:</dt><dd>
        A pointer to a static-duration object of a type derived from <code>memory_resource</code>
        for which <code>allocate()</code> always throws <code>bad_alloc</code> and
        for which <code>deallocate()</code> has no effect.
        The same value is returned every time this function is called.
        For return value <code>p</code> and memory resource <code>r</code>, <code>p-&gt;is_equal(r)</code> returns <code>&amp;r == p</code>.
      </dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <p para_num="5" id="memory.resource.global.5">
      The <dfn>default memory resource pointer</dfn> is a pointer to a memory resource
      that is used by certain facilities when an explicit memory resource is not supplied through the interface.
      Its initial value is the return value of <code>new_delete_resource()</code>.
    </p>

    <cxx-function para_num="6" id="memory.resource.global.6">
    
    <pre><code><cxx-signature>memory_resource* set_default_resource(memory_resource* r) noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="7" id="memory.resource.global.7">
    
    <dt>Effects:</dt><dd>
        If <code>r</code> is non-null, sets the value of the default memory resource pointer to <code>r</code>,
        otherwise sets the default memory resource pointer to <code>new_delete_resource()</code>.
      </dd>
  </cxx-effects>
      <cxx-postconditions para_num="8" id="memory.resource.global.8">
    
    <dt>Postconditions:</dt><dd><code>get_default_resource() == r</code>.</dd>
  </cxx-postconditions>
      <cxx-returns para_num="9" id="memory.resource.global.9">
    
    <dt>Returns:</dt><dd>The previous value of the default memory resource pointer.</dd>
  </cxx-returns>
      <cxx-remarks para_num="10" id="memory.resource.global.10">
    
    <dt>Remarks:</dt><dd>
        Calling the <code>set_default_resource</code> and <code>get_default_resource</code> functions shall not incur a data race.
        A call to the <code>set_default_resource</code> function shall synchronize with subsequent calls to the <code>set_default_resource</code> and <code>get_default_resource</code> functions.
      </dd>
  </cxx-remarks>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="11" id="memory.resource.global.11">
    
    <pre><code><cxx-signature>memory_resource* get_default_resource() noexcept;</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-returns para_num="12" id="memory.resource.global.12">
    
    <dt>Returns:</dt><dd>The current value of the default memory resource pointer.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.resource.pool">
    

    <section>
      <header><span class="section-number">8.9</span> <h1 data-bookmark-label="8.9 Pool resource classes">Pool resource classes</h1> <span style="float:right"><a href="#memory.resource.pool">[memory.resource.pool]</a></span></header>
      
    

    <cxx-section id="memory.resource.pool.overview">
    

    <section>
      <header><span class="section-number">8.9.1</span> <h1 data-bookmark-label="8.9.1 Classes synchronized_pool_resource and unsynchronized_pool_resource">Classes <code>synchronized_pool_resource</code> and <code>unsynchronized_pool_resource</code></h1> <span style="float:right"><a href="#memory.resource.pool.overview">[memory.resource.pool.overview]</a></span></header>
      
      

      <p para_num="1" id="memory.resource.pool.overview.1">
        The <code>synchronized_pool_resource</code> and <code>unsynchronized_pool_resource</code> classes (collectively, <dfn>pool resource classes</dfn>)
        are general-purpose memory resources having the following qualities:
      </p>
      <ul>
        <li>Each resource <cxx-term><i>owns</i></cxx-term> the allocated memory, and frees it on destruction –
        even if <code>deallocate</code> has not been called for some of the allocated blocks.</li>
        <li>A pool resource (see <cxx-ref to="fig:memory.resource.pool.resources"><a title="fig:memory.resource.pool.resources" href="#fig:memory.resource.pool.resources">Figure 1</a></cxx-ref>) consists of a collection of <dfn>pools</dfn>, serving requests for different block sizes.
        Each individual pool manages a collection of <dfn>chunks</dfn> that are in turn divided into blocks of uniform size, returned via calls to <code>do_allocate</code>.
        Each call to <code>do_allocate(size, alignment)</code> is dispatched to the pool serving the smallest blocks accommodating at least <code>size</code> bytes.</li>
        <li>When a particular pool is exhausted, allocating a block from
 that pool results in the allocation of an additional chunk of memory 
from the <dfn>upstream allocator</dfn> (supplied at construction), thus replenishing the pool.
        With each successive replenishment, the chunk size obtained increases geometrically.
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    By allocating memory in chunks, the pooling strategy increases the 
chance that consecutive allocations will be close together in memory.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></li>
        <li>Allocation requests that exceed the largest block size of any pool are fulfilled directly from the upstream allocator.</li>
        <li>A <code>pool_options</code> struct may be passed to the pool resource constructors to tune the largest block size and the maximum chunk size.</li>
      </ul>
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    <cxx-ref to="fig:memory.resource.pool.resources"><a title="fig:memory.resource.pool.resources" href="#fig:memory.resource.pool.resources">Figure 1</a></cxx-ref> shows a possible data structure that implements a pool resource.
      <cxx-figure id="fig:memory.resource.pool.resources">
    
    <figure>
      <figcaption>Figure 1 — <wbr><figcaption>pool resource</figcaption></figcaption>
      
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABY0AAAMjCAYAAADp9z/kAAAgAElEQVR4nOy9b3BTV7ruuQ7GxA5/IluSLUuBiA5JHGwZH0iIDZLRIU1dd8ZN06QTnMAFOZZozz0kgcoZFyc56TLVB7gpT5pMkYFTMHdUlqtxY6mLMFN9oOdDm5mqO/SHU+WuuhVLdghuutrlbkuK4ZJg6lCTNR/srWzJe+vvll4t6/lVPVVdkbS93kdri16Plt7FGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgDVsaYU0HtjLE+Ja0wmH5TbqwbLTYte6yyX23MjLE9KnU6GWMmzV0FAAAAAAAAAAAAAACAAlPP4oPPTiYLSZc9VtmfGKqysvJHjDEu1wpj3f2aZzfPJsrcuG12y75erqSdxy7wjhNXi05bD3yoON4t+3r52s077yrVWfPs5tmyJ4zfJPrCysofyb1bYTTfZPEh9PEE/1vy/YYDAAAAAAAAAAAAAABKC3kIfJQthJOx0NJgCjJZqPm4yXpPHnxat75yTx6Sbj3w4aJQtevSFPcEolAa6ro0Fedd+weX40LoTXvefiT3v3p946z8/Vm2cs29WOisMw4w5R3PFYWbXgAAAAAAAAAAAAAAgGKhmc0HhD2Msb6yVVXnpDCxbJUuzBRC4I0/cD+UwkkptNx96jp5kAqlr/0Xx2Lvnf1wv+KO59jOb/muZoPpd2xxwGwt/LQFAAAAAAAAAAAAAABkg4nNh3p7WMLOYCkQXLNuw92aZzfP1n//wDdb9vXy1q6TsTCx89woebgJ0Uu+q3lXr29RwLzCWHefMcaXPfb4A4VWGe0MfZkBAAAAAAAAAAAAACgoLWzhULhynXFAvkO47AnjNzXPbp5du3nn3cSdwWgFAWmtQwO3F7XKMDdui+vLLLXFWK6r8bP43coAAAAAAAAAAAAAAIAMkFpIxNpHLFu55h5jjFevb4wdCmc/3I8dwlBRS2qLsePI2bjdyky2U1nWY7md4QA/AAAAAAAAAAAAAFDiOBljPVIwLO0YllpIyNtH7L84Rh4AQpCWknYqSz2WzY3bYgf4STuUy1ZVnWPzBzE6GQ7qAwAAAAAAAAAAAABLiHomtZQwmH63vMo4xRjjUm9hKRjGjmEImpe0Q7m16yTf+AP3Q+mgvrJVurCsh3Inm9+VDwAAAAAAAAAAAABA0VLB5ndEHpX6DTPG+OMm6z2ppcSuXh9/7ZOb5KEcBImoznOjsR7K1q2v3FuzbsNdxhhfYTAFZX2TnYwxHdWHAAAAAAAAAAAAAAAobZoZY65ynXGgXFd7m5WVP6p5dvPsxh+4H0r9hqlDtlLT7lPX+frWDr6+tYPvPnWdfDxQ4d53qW9yzbObZ5dVrHq4vMo4tcJg+g2bb2+BXskAAAAAAAAAAAAAQHN0TGoxYawbZWXlj9as23B3g2Pvffvhfr63/wZ5cAZF+ZZ9vZwxxhljfMu+XvLxQHR67ZObfOexC3zjD9wPpV7J5ca60WWPVfYzxvYwxkyEnycAAAAAAAAAAAAAQEDqGWM9Kwym3yyvMk4tq1j1UGox0XHiKu+6NEUeikGLhdAYSqaOE1f51gMf8rWbd94te8L4zbKVa+6VG0y/Y/O7kdEfGQAAAAAAAAAAAADEYWKMdS7X1fjLVunCj5us9+q/f+CbnccuoAexQEJoDGWi/RfH+K5eH9/4A/fDNes23F22cs29hZYWLsaYlfDzCAAAAAAAAAAAAAAQUMEYay9bVXWuXFd7u+wJ4zfWra/c23HkLO88N0oeZuVTe/tv8I4TV/mhgdspn9t5bpR3nLia1BPpekqvlQ4tS3UNJR0auM07TlyN9ard1etTHfPuU9d5x4mr/LmX34yFxs+9/CbvOHE1JrUex0rj339xjO88diE29nTG23HiKpd6We+/OJb1eyN5tqvXl/b7lOx9ODRwm+/q9fEdR86mrGX3qet864EPefsHl7OuQWRJ7/sGx977K4x195dXGafKdcYBNt/OAofrAQAAAAAAAAAAACxB6hljx6WexObGbbOtXSdLqh/xzmMXYqHqUy/sSvl86bmMMcUQcfep67HHtx74kHsC871kn3phV9xrJW1oezVla49DA7f5xvYuxdezhTBYHqTKa0ol++F+1fFLO5Pth/t5WeXquNdJtSnVX9fQovi3yqtqVF8nV+e5Ub6xvYtX1q5VHff61o6kobtSHXv7byiObdWTT/Odxy7Evb7jxFW+6smnFz23ev3GJf8lSjK99slNbj/cz9du3nl3WcWqhysMpuBCT2QcrAcAAAAAAAAAAAAgMC1lq6rOSS0nNu15+1G6O0eXonYcORsLBC2b2lI+n8kCRKXwsOPE1biwcseRs4sC10TVPNOsunv20MBtxfAyUfLQM5PQuLXrZNLxt3adVHydUquLrQc+TOtvPvXCLtV6O05cTemXpLLK1aq7f7N5HyQPU9VRXlWDFi0LknZiV69vnF22cs092S5kAAAAAAAAAAAAAFDktJfrjAPLVq65V72+cba162RJ75aUK5+hcc0zzbH/XVm7lrd2nYy1l1jf2rEoSFX6e/L2EutbO+JC0tc+ucmb977Ly6tq+I4jZ2P//dDAbb71wId8y75ebtnUFlffln29cUoMb+Xjf+qFXbGgtbJ2bew1dQ0tcX/PE4jGhctllau5fMf6oYHbfOexC7y8qiauFqV6pR7MZZWr+Ya2V/nOYxdi15F2ucqvs6HtVcXrqL0PNc80x9pcbD3wYVyQXFm7ljfvfTfOr/YPLvOOE1fj/nuy8Zey9l8c+24X8mOPP1iuq/EzxjrZfOsbAAAAAAAAAAAAAEBMBVs4xG7ZY48/MDdum7Uf7i/JnqyplM/QWH5dpZ218kPqGGOKu1elgLSscrVqG4tDA7dVH8v0IDyl8SfbCe0JRHnXpalYK4myytWqvZI7z43GhbRKbVDaP7jMN7Z3JZ2ru3p9ceNTGptSHU+9sGuRT+0fXE57J7X9cH/cc3A/qevQwG2+48hZbt36yr1lFavmZIfpoQ8yAAAAAAAAAAAAQIGpL9cZB8pWVf136RC7dA8NK1XlOzRWCirlkvfYtf2wZ1HwJj1WWbs2q/pyDY0ra9emnEO2H/ao1pDsuc+9/GbW75u8ZYdS+JzJ+5DY5ziZT/I+y4l9kCFldV2aih2mV7Za//XCDmT0QAYAAAAAAAAAAADIIzrGWM8Kgyn4uMl6z364H0FxBspnaFxZuzblIXfy/rk1zzQvelzeikFtB28y5Roap9Pvunr9xqSeqF2/rqEl6/dN3nZDKbzN5H2Qe5Sq7YS8XUhiP2gotbouTfEdR87y6vWNs8urjFOMsR7GmKkAn5MAAAAAAAAAAAAAJUHLcl2Nv2y1/uv67x/4JptAEcpvaLzqyadTXu+1T24m3U0sDymlXsGpgmi5cgmN0xm/JxCNtZwoq1yd8rmd50Zj1y+vqsn6fZOHxon9lTOtQ952ItXuZ3lv43T8hNT12ic3ef33D3xT9oTxm4X2Fe0F+uwEAAAAAAAAAAAAWFJUMMZcy6uMU9XrG2d3HDmbUYAILRZ1aCwPURlji97P/RfH4loxMPbdgW3pHGaY79A4cfyZKtm1pV2pW/b18ua973LLpraY5Duwcw2N5XMgVWicqZ9Qetp57AI3N26bLVulCy+rXPkPDL2PAQAAAAAAAAAAAFKiW1ax6p/K1hiiGxx77ysdmAZlJ+rQOJ1r7r84xp96YZdi6LqxvStpO5J8h8ZKB86lK7Xrd54b5c+9/GbcoXnJhNB46ajz3ChvaO/6ermuZnb5yuozDK0rAAAAAAAAAAAAABahW77S+J+X62pmm37093P7L46RhzpLTdShsfywO5Zi5+3e/huKYWpl7VrVXcf5Do13n7oeN46OE1fTltKYDw3cXrSz2rKpjW/Z1xsn+XMQGi89HRq4zV984/1H5dW198qrai4whMcAAAAAAAAAAAAAjC2rXPkPjxnrZv721WNzONguf9rV64uFgOkczMY0Do339t/IeGfyoYHbfMu+3rjwWG3s+Q6N918cSzv0TkfyHdU1zzSrhuFa9jRGaFy86ro0xVsOnnhUUWuOLF9p/M9svkUPAAAAAAAAAAAAQMnRvrzKONXQ3vU1dhbnX4k7ZVM9n2kcGssDy3RCa7naP7gcNx6lLxfkIWfz3ndTXjOXg/AYYzyXOdt1aSruWsm+LEFoXFo6NHCb/+2rx+bK1hiijLHOgnwSAwAAAAAAAAAAABQB1hVG801z47ZZ9CwunBIPcksWVMrDRZZGaFxWuZq3f3A56d+Xh5+pAkslVa/fGHv93v4bix7feuDD2OPrWztSXi+b0Fg+htauk1m/F/IAP9XfRmhcmtp/cYxbt75yb4XBFGSMNRfkkxkAAAAAAAAAAACAgscMdccqa9bOpgoYofxIvrtVLfTc1etb1Es4VWjMGOPlVTV896nritdM3CmsFPqmUmXt2qSB985jFzLaSZ1NaGw/3B/3N7JtpyJv1VFeVaP6vPYPLse9FwiNS0+7T13na9ZtuFtuMP/PBfmQBgAAAAAAAAAAACggugrjk//3M87XZ7suTZEHMaUq2w97VHcHHxq4zZv3vhsX7rIMQmPpmq1dJ7n8Pd5x5Gxc8Km0C1g68G3HkbNcaX7IdxGrBaPy3buMMd5x4mrssc5zo4vaSWQTGnsCUV7zTHPc69SC8v0Xx7j9cD+3bGpbFJJ3XZqKG6tSOw15QC0JoXHpatOP37m/sOsYB+UBAAAAAAAAAABgSdBcYXzyzy+/97//O3XwUura239j0S7iytq1cS0Q2EKgKP9vqULj8qoavurJp+PCY8umtkV/q7yqhiu1JJGH1eVVNdyyqY3bftjD17d2xF2XJYTBiZIHuowxXr1+Y6ylxNYDH6qOP5PQuP2Dy7y8qkbRQ0nyNhZqY5aHslLdz738Jt/Q9mrc9esaWhAaQ9wTmP9ipKLWHGGMOfPwOQ0AAAAAAAAAAABQGFZUG18zfq9xWil0hOiCJ3mrh0RJu14zCY1XPfk0PzRwmz/1wi7V69Y806x4HU9gPsxONia2EKoqhaaJY0oMdCUlvjbb0NgTmN9FnKxWueoaWhQPzeu6NMU3tL2q+rqyytV8x5GzceNEaAwdGrjN6za+FH7MUHdM0w9rAAAAAAAAAAAAgELwWI35Pz3Z/HfRbPu+QvnT/otjfOuBD/mGtle5ZVMbX9/awVu7TsbtAt7V6+Nb9vXyrQc+VGwZoRZW7ur18fWtHbFdt8173+U7j11QvEaidhw5G9vlLOmpF3bx1q6TafcP3n9xjDfvfTfuGs173130+q5LU3zLvl6+ZV9vyjBaTR0nrvIt+3pjPkp67uU3F/mZ7Brymje0vcpbu07GAvb9F8di41S6XiZ1vPbJzdhzU/UV333qeuy5ai04IBp1XZrizzhfn62ss35C/TkPAAAAAAAAAAAAkDYrqo2vPdn8d1HqcAXKn3LZqQtBUO56/j8curdcb/xH6s97AAAAAAAAAAAAgHRw1m18KYwD75a2EBpDEL2e2tr+Vdka/X+k/tAHAAAAAAAAAAAASIbp8dqnppV6uEJLSwiNIYheXZem+KonvxdljNXn8sHdefyK9cD710cP/OP/uSfZ88pW679gafTyLnYt1JEV6XoFAAAAAAAAAACABcqNdaMdJ66SBylQ/oXQGIKKQ699cpOvMNTdYYxVZPvZ3Xn8ivXgP13nB//pOk8RiJLXq4UWPrvy7VXJh+z4MiJ94BV80tInkBmYV+kDrwAAAACQLXvWbt55lzoMgAojhMYQVDxqaO/6elnlyn/I9sNbHoSmCETJa9VCC59d+faq5P3ClxHwCnOKdk7hVxHpgXkFr7T2CvcfAAAAkEC5rvb23v4b5P+4Q4XR7lPXY6Fx9fqN5OOBoFLW/otjvGyNIcqy3G2sFISqLArJa9VCTOPQOMkCmrxWSr/wZQS8wpwqjjmVLLzCjlDMK3ilvVeZ/CoJgCWNt0HvGmg09Pma9OcHbfoRn03v9TasNFGPCwBQcFqq1zfOUv/DDhVWu09d5x0nrvLOc6PkY4GgUpd16yv3GGOd2XyAJwtC5Yue7zXYyevUQixPobHCApG8Vkq/8GUEvMKcKq45hXAP8wpeFcarDH+VBMDSw2vT7/HZ9MHBJgNPlM+mP574fF+T/vxgk4EP2vQjFOMFAOSX5Surz7z4xvuPqP9hhyAIKlXtPHYhaZCplQ788//DD/5vt8jrzUWMsYJ49UPP/yq8V5Jf2fx/A3wZAa8wp4pzTiHcw7yCV/n1KsNfJQGwtPA1GnqUwmJJA42GvsTXeBuqOqXHvc9XtxAMGwCgAe6hsNM9FHZ6AuEe9+Vwn9sfPtM9PNOOA/AgCIJo1XlutCBB6MGf/V/8wP8yyruH/kJec7ZiBQqN9x//P4T3qlB+4cuI0vIKPqU/p7L9/+ylGO5hXsGrfHiVz/sP4TFYcnht+nqfzTAnC4lHBxoNfb6G6qODTYZR1dDYyiqk1yk9DgAoDg4HIvVvDc+43JfDfZ5A5IrbHxnxBCLBZP+Yui+H+8pW6cJoUQBBEEQrlsfFzcEPrs21tPcIH4Dm4lMmXv3HD66fWa2vI69VK7/yHjDgy4iS8go+FdecWirhHuYVvNJaBbn/NAqP3UNhp/tyuG9+HR/ucXkn4865cHknK2Ibvy6H+9xDYWfiNVxD09bY48OR467hGbSeBZnhazJci7WhaDT0yB8btOlHkoXCsdeiRQUARYHLO1kR+8fFH73mDkST9iR2B6Kzbn9kxO2PjLgDX512Xw73dfvDna6haeuylWvu7b84Rv4POwRBUCmL5SM0XghAX/uffmNi+BlzJl6xUvcLX0bAK8yp3H1CuJffOVWq8wpepaeC3H+L/79DxriGZ5oTx+72h8/In+P2h8/EPx6Zcw3PNMeu4Z2scPsj0/HXiVzJdkygRPE16WcHmwzc12QYSnwsZWhsM5yZ73lsmM77QAEAi4jtIg5Ezrv90VGlfxjd/si059fRIfflcF/38Ey7eyjsTOcbxhUGU3D3qevk/7BDEASVqvZfHOPLVq65l82/D4qLQOVFDHmdWohpvWBWX/CR10rpF76MgFeYU0U6p5ZguJc3rzCv4JXWPmkYFku8NTzjShy72x+J26w5/wvi+Oe8NTzjkh5XDJ4D0dlcxwZKCG/DSlOsL7FNv2j7fKrQeKDR0Ce9Pu+DBQAwxr77iYlaiwm3Pzrq9ofPSDuGs/07y3U1/h1HzpL/ww5BEFSq6jhxlZcb60az+QyPW9wkX8SQ16mFmFYL5tQLPvJaKf3ClxHwCnOqyOYUwj3MK3hVEK8y/FVSzmgRGs+fW7ToGnNajRGUAN5GgzMWGtfrrImPp95prD+N0BiA/OManjF5AuGexN3E8+0lotekHkaJfY5yZM/azTvvUv/DDkEQVKra+AP3Q8bY0Ww+wDuPX7GmuYghr1MLsVwXzOkv+MhrpfQLX0bAK8ypIplTCPfS9wrzCl5p4FWGv0rKme7hmfZF4/91NK47gOfX0aHE57h/FW2RHp/PEBI9iAS1HitYwnht+vpYaPx8dUvi42mExlfm21PoMfEA0BiXd1L31vCMK/EbRLc/Muf5dXSo2x/u1DgkTqSibI0hir7GEARBhVfXpSleXl17jzGW1ULE6fJWpLmIIa9VC7EcFswZeFXyfuHLCHiFOUU8pxDupe8V5hW80tCrDH+VpAkLPYsn588pilw5HIjUyx8/HIjULxx0P+cJRILuwFenF11jOHJc2njm9kdGlA7LAyApsZ7GNv3xxMeShcZeK6vw2QzTC69FM20ANKL7cmSP0reGnkDkylvDM648B8VxLKtc+Q8N7V1fU//jDkEQVGpqOXjiUXlVzYV8f85XV6/5/9j8AkpoLdSRd0rdL3wZAa+09go+pQ/CvfTBvIJXWnuV4a+SAFg6DNr0N+cPwtPPJraoSBYa+2x6r7RLWW0nMgAgfeZ3FSe0n/BHry0ExTqiYVWs0NdMd54bJf8HHoIgqFR0aOA2r6g1R1iWu4wzhD/69l+FF8thwQy/tKfUw/VMgFdpUlZ+nzHG9frV5LVqIaNxzReZWoBwT3tw/2VAid+DGf4qCYClg7yvsc9mmPY26F3SY0qhsbdeZ/U1GYZir2nSz3obVuLmASBLFprcT8r+T9KkJxDucQ3PFMt91WLcsCncdWmK/P88QhAElYKebP676Ipq42sF+ownDzBFCEHhF3yCV0XhFfxKhxIP9zKEfC4U/XyCZwCAgUZDnxQCS+Gxr8lwzdeknxxsMvBBm34kJtnzBpsMXB4yAwDSw+WdrHjLHz7q9kemZUHBpPy002Jiud74j8//h0P3qIMUqPDqOHGVd5y4yl/75GZOz4EgKD21HOx7sKLW/F8K+BFPvnATbPFHXqsgfpHXKIhP8Ap+wStar8jrE8AjeAYAYMzXpD+fGAinks+mX9RoGwCgjss7qUsMi93+6Gj35cge6rGl4rGatee2vN7736kDFahw2n3qemyXR/X6jVk/B4Kg9OR851/+/THjk9cL/PFOvnATbPFHXqsgfpHXKIhP8Ap+wStar8jrE8AjeAYAmMfboGtW2k28SDb9iNemr099RQAAY/M7i92Xw33zJ5/OhwNuf2REhLBYTmXN2qstB/seUAcrUGHUceJqLBBe9eTTWT8HgqDUcr7zL//+uPmp/5cxVrDDThcgX7gJtvgjr1UQv8hrFMQneAW/4BWtV+T1CeARPAMAxOOt11m9jQanr6H66ECjoW+g0dDna6g+6m00OBMPywMAJMc9FHZ6ApGgFAy4/ZER91DYST2ubFlRa/4v39v+wyh6HC99ITSGoMLI9j/89O7CDuNCB8aMYfEHv+AT9bwir1Mgr+AXvIJHdPMJngEAAABa4fJO6roDEe93wUAkKHJYLOexGvN/Mm7YFO48N0oetkD5E0Lj1Np96jpf39rB17d28N2nrpOPBxJLhwZuc3PjttkK49qThB/p5As3wRZ/5LUK4hd5jYL4BK/gF7yi9Yq8PgE8gmcAgOzwWnU6b6PBST0OAIqNt4ZnXFLfYrc/MucejhynHlMeaKkwPvln5zv/8u/UwQuUHyE0Tq0t+3pj9W/Z10s+HkgcdZy4yitqzRHGWDvh5zhjWPzBL/hEPa/I6xTIK/gFr+AR3XyCZwCUIgONhr5Bm37EZ9Of9jasNGXyWp9NHxxsMnBfk/58vsYHgEgcDkTq3f7oNSkUcPuj11xD01bqceUR3WPGJ69/z77n7v6LY+QhDKR9qMUQGicVQmMoUx0auM2bfvg/fl1urBtljGX0/7vyBPnCTbDFH3mtgvhFXqMgPsEr+AWvaL0ir08Aj+AZAKWMz2aYkw6489kMcz6bPu0dkb4m/eT86/TefI4RgGLH5Z2scA9Hjrv9kTlPIMrd/sh0tz/cST2uQlG2utrzmLFupuXgiUfUgQyknRAapxZCYygT7Tx2gVfUmiPLdTV9hB/ZiZAv3ARb/JHXKohf5DUK4hO8gl/witYr8voE8AieAVDKSIFxnGz6m94GXXOq1yI0BoAx1/BMc/xBd+EzLu+kjnpcBOjKq2ourFm34W77B5fJwxnoO+3tv8HbP7jMt+zr5bt6fbzjxFV+aOB2ytflMzQ+NHCbd5y4ynccOct3HDnLO05c5bkcrihdb+uBD3n7B5d5Jv22s/Fn96nrvOPEVf7cy2/G6n/u5Td5x4mrMaXb4zhXL/b23+AdJ67G/bf9F8f4zmMX+JZ9vYsegwqv3aeu85pnN8+uMJh+w4pjd7Ec8oWbYIs/8loF8Yu8RkF8glfwC17RekVenwAewTMAShnZLuPpxPDYZ9Of9lrVT/JGaAxKHU8g3PPd7uLoqPtX0RbqMRUBzSuM5ps1z26eRVhFp85zo3xjexevrF0bCzUTtb61I2m4mo/QuPPcKH/qhV2qYyqvquE7j11Iu872Dy7z8qoaxWvVPNPM1b7AyMWfnccuqL4mUfbD/Xn1Yvep64t2OtsP9/OyytVx19p64EPyOVmK2tt/g6/dvPPuCoMpyBhzav1hqxHkCzfBFn/ktQriF3mNgvgEr+AXvKL1irw+ATyCZwCUMrKA2Ot9vrplsMkwmhAcB70N1YqHtCA0BqWKyztZ0R2IeKVgwO0Pn6EeUxHiLDfWjdY8u3kWO48Lq44TVxeFhmoqq1zN1fpRax0a7zhyVjXgTdRzL7+ZdLdt16WpuF2+yZQY3ObqTyahcWvXybx6Ifd/y75e3tp1UvEaaJ1RWO0+dZ2v3bzzbrmu9jZjbE+On6X5hnzhJtjij7xWQfwir1EQn+AV/IJXtF6R1yeAR/AMgFJGHhpL/81n0x+X9zqOhcpWXdxP7hEag1LkcCBSL7WjcAeis92XI8UeCFDjXGE031yzbsPdHUfOkoc5pSCpz25Z5Wq+oe1VvvPYBb63/wb3BKL8tU9ucvvh/rjAckPbq4rX0TI0th/ujwsxLZvauP1wf6yVQ2vXSb6+tSPuObYf9qher3nvu4uCVam1RPsHl/nG9q5YMPzUC7s09efQwG2+9cCHfMu+Xm7Z1BZX05Z9vXFSanOhpRdy/596YVes5sratbEx1DW0cNx7hdGuXp/UhiLIij8sliBfuAm2+COvVRC/yGsUxCd4Bb/gFa1X5PUJ4BE8A6CUUQqNGWPMa9PXD9r0N+ODY8O0t0Hvkp6D0BiUGt3+cKc7EJ31BEbUWRoAACAASURBVObbURwOROqpxyQQzct1Nf6yJ4zfNP3o7+cy6TkLZSYpNFXbQSyFW0wWSiqFm1qFxl2XpuLaQKQbBpdVrlZsD7H/4ljcTmG1QPS1T27yuoYW/tzLb+bFH08g84PwtPZC7r+kmmea0+pZDWmj/RfH+ItvvP9ohbHufrnB9DtWvG0o1CBfuAm2+COvVRC/yGsUxCd4Bb/gFa1X5PUJ4BE8A6CUUQuNJXyNhh5fk342LjxuMlzzNqw0ITQGpYLLO1nh9ofPSCGBOxA57/JOqvb7BkkxLatY9U9lq3Rhc+O22Z3HLuR0ABqUvVY9+XQsaJR22sqlVWhs+2FPXKCZalx1DS2x569v7Vj0uLwthdLjhfLHE8g8NNbai8TQuLJ2LQLjAmnnsQvcuvWVe8tWrrm3fGX1GcaYtWCfotpCvnATbPFHXqsgfpHXKIhP8Ap+wStar8jrE8AjeAZAKZMqNGaMsfmA2HAtYdfxnNTCAqExWMq4hqat7kDkpicQ5W5/ZO6t4RkX9ZiWEO0rDKbflK3Wf13//QPfvPbJTfIgqJQkb62gdOCaVqGxvNVDOm0Sdhw5GxeCJj4uD3N39frI/PEEMg+NtfYiMTTG4ZP5Vee5Ud70o7+fK3vC+M0Kg+k3jLHOwn1c5g3yhZtgiz/yWgXxi7xGQXyCV/ALXtF6RV6fAB7BMwBKmXRCYwlvg97lsxmm5eExQmOwlHEPhZ1SOwpPIBJ0Dc80U49piaJjjPUsrzJOVa9vnLUf7k/aOgDSRvJQVCnA1CI0PjRwO602D3LtvzgW9xr5TvSuS1MZXy9f/ngCmYXGWnuR7nsE5aZDA7f5jiNnublx22zZKl14WcWqf2KMmQryyVgYyBdugi3+yGsVxC/yGgXxCV7BL3hF6xV5fQJ4BM8AKGUy3S3step0Ppvei9AYLHW6h2fa3f7I3HxwELni8k7qUr8KaEBLuc44sGzlmntr1m2429p1UrGXK5Seui5N8R1HzvIt+3p58953uWVTW0ypdr1qERrv7b8Re7yscnXa42ayoFTeGuK1T27G/nt5VQ2pP55AZqGx1l6k+x5BmWv/xTFuP9zPzY3bZpc99viD5boaP2OsvWCfgoWFfOEm2OKPvFZB/CKvURCf4BX8gle0XpHXJ4BH8AyAUsbbUN3uazT0eBtWZrRrxttocPqaDEM+m/6Kt9HgzNPwACCh+3JkjxQYdwci+FKEjuayVVXnylbpwmvWbbi7+SfvPUILi/TUeW6UP/fym3EHxiVTvkJj+YFymYSa8hYU8pYL2V4vH/54ApmFxlp7ke57BKU/J+yH+3nNs5tnl61cc69cZxxgSzcolkO+cBNs8UdeqyB+kdcoiE/wCn7BK1qvyOsTwCN4BgAAAEi8NTzjkkIE9+VwH/V4QIzmZRWP//PyKuPU4ybrvc0/ee/R7lPXyYOmYtShgdtxQSNjjFs2tfEt+3rjJH9OvkLj9g8uZxVqynf5ynfXahEaa+WPJ5BZaKy1F+m+R5C6XvvkJm/tOsnXrNtwt2yVLrwQFDsL8YFWRJAv3ARb/JHXKohf5DUK4hO8gl/witYr8voE8AieAQAAAIwhMBaI+mUVj//zCoMpuKxi1cO1m3febe06ybELeV5PvbArFiTWPNOs2t6jED2N5e0kGGNpjT+xb7G8j28218uXP55AZqGx1l6k+x5B36nz3CjfceQst2595V7ZE8ZvllcZp8pWVZ1jjJVyv3ryhZtgiz/yWgXxi7xGQXyCV/ALXtF6RV6fAB7BMwAAAMB9Odz3XbgQ7qEeD0gbHWNsT9mqqnPLq4xTZU8Yv9ng2Ht/x5GzJdkLuevSVFzLhWSHrRUiNE4MPdMJ9nefuq56zWyuly9/PIH40Lh577sp/7aWXqT7HpWy9l8c4zuPXeD13z/wzQpj3f2yVbrwQn/iTra0DrPLBfKFm2CLP/JaBfGLvEZBfIJX8Ate0XpFXp8AHsEzAJY63oaqTp9NH/TZ9MHE/sO+RkPPQKOhLxd5G6pLoecfWMLIA+O3hmdc1OMBOWFijLmW62r8Zat04cdN1nv13z/wzc5jF/j+i2PkIVa+lSpklKsQobEnEN+TN1Ww6glE+XMvvxl7/oa2V3O+Xr788QSifOuBD2PPWd/akfLva+0FQuN4HRq4zXf1+vjGH7gfrlm34e6ylWvurTCYfsMY62GMWQvxASQg5As3wRZ/5LUK4hd5jYL4BK/gF7yi9Yq8PgE8gmcALHUGmwyjg00GPthk4D6b3pvwGM9ZNv0IVW0A5Io7EDnvCUS52x+Z6/aHO6nHAzSnnjHWs8Jg+s2ylWvulT1h/Gbt5p13tx74cNGhYktBe/tvxELE8qoa1ee1f3A5bsdtPkPj1q6TsedU1q5NusN2b/+N2LjKKlcr7hZPvF6yLwNau07GhbNa+uMJRPnOYxfixpLq/dHai1IPjXefus5bu05y69ZX7j1ust5b9tjjD8oNpt8xxo6y0m45kQnkCzfBFn/ktQriF3mNgvgEr+AXvKL1irw+ATyCZwAsdRAaA6BMdyDi9QQWAuPhGeyYLw1MjLE9yx6r7C831o0yxnj1+sbZjT9wP9xx5KzwfZETWyAo7Wa1H+6Pew7Lc2jcdWmKV9aujQtrlQJ7++H+uKDW9sOetK5XWbt20fU6TlyN7RS2bGrLiz9SaCl/nnwcnedGFwXaWntRSqHx/otjfFevj2/a8/ajmmc3zzLG+AqDKbjQk7iTzX9BBDKHfOEm2OKPvFZB/CKvURCf4BX8gle0XpHXJ4BH8AyApY7Xpt/jazJc89n0V7zPV7fIH0N7ClCqSC0pEBgDxlgLY+zocl2Nf3mVcWpZxaqH5sZts1v29fJdvT7hgmR5n122EEw+9/KbfEPbq7y8qib23+saWgoSGnsC8zty5SGoJMumtrhxyP97sn7DO46cXfSassrVcS0lJCW2ddDKH0k1zzTHXa96/UZevX4jZ4zxrQc+zKsXSzU07jw3yjtOXOVb9vXytZt33i17wvjNspVr7i3sIj7OGHNq+xFQ0pAv3ARb/JHXKohf5DUK4hO8gl/witYr8voE8AieAQAAKC3eGp5xSeEEAmOggI4x1s4Y6ys3mH63vMo4xRjjNc9unq3//oFvpNYWyUJNSnVdmuIb2l5dFD5KKqtczXccORsXOOY7NPYEovy1T24qhqKJY1MKWpXU/sHluJBXSetbOxa9T1r5I/dAbRxqr9PKC9FD465LU7zjxFVuP9zPN/7A/bDm2c2zrKz8UdkqXXjhlwB9jLE9DIfW5RPyhZtgiz/yWgXxi7xGQXyCV/ALXtF6RV6fAB7BMwAAAKVD9/BMu9sfmZsPLcI91OMBQuFkjPVIrS2WPfb4g7InjN/UPLt5dsu+Xr7z2AW+t/8GeRAnDxSfe/lNbtnUxi2b2viGtld5a9fJWG/c/RfH+JZ9vXzLvl7F3dRdl6Zij6uFn+k8Ryns3bKvl29oezU2NsumNtVxJNP+i2O8tesk39jeFXet5r3vprxWrv4kjqN577uLxpDqi4VcvcjGfyrt7b/Bd/X6+JZ9vdzcuG12hbHuPisrf1RurBst1xkH2HwfYidjrILyJi9ByBdugi3+yGsVxC/yGgXxCV7BL3hVQK8+f9FoCm2vOxpy1J0f217bAo+ygrxeAT0DAAAgAq7hmWZ3IDrrCUS5O/DVaerxgCWBic0HXX0rDKbflOtqbzPG+Apj3f2aZzfPbvyB++GWfb2848TVogqUISgfeu2Tm7zjxFW+9cCHsd7Dj5us9xhjvFxXe3uhvUQfm9/Jb6W6aUEc5As3wRZ/5LUK4hd5jYL4BK/gF7wqoFfjdvPohMPCJe14ooy8vmLzKA3I6xXQMwAAAMWOa2ja6glEJz2BKPf8OjpEPR6w5LGy+TD5KGOsb343ZXygvGnP24+kVhei9U2GSldSv+HWrpN8y75eXvPs5tk16zbcZYzx5VXGqfld+JX97LvewzigrrghX7gJtvgjr7VQfk1sszQH7SZnaLulZ9xu7gvaTc6YWkxW+KQZ5HUK5BX8gldZM7a9tkUeGE84LLxvwyry+orJozQhr1dAzwAQG2/DSpPXpk+6qPM1GnoGbfqRwSYDH2wyjPqa9Oe99TprgYYIQE64vJM6tz866glEudsfGXF5J/HzZ0CJlc2HacelVhdS32Sp3cXazTvvbtnXy6VQuePEVfKwECoN7e2/EeszvGVfL9/g2HtfvmNY6jdctqrqHJvfNexkjDUT3Usgd8gXboIt/shrzZdfE9sszSFH3flxh2U2MVhR0rjDMhuym6+N2819463mxHUEeY0CzSvyOgXySlO/Hj74jP+x7w0+0b6RT3Q08T/2vcEfPvhsKflFPi+KyavQ9rqjiZ9jPpuBvL5i8ihNyOsV0DMAxMVr0+9ZCIK5t9HgVHqOr0l/XnqOXL4m/azaawAoFlzeyQq3P3ptPhCJBF3eSR31mABIgtTuYg9jrE8KlRcOBeOMMV69vnFW3vpi57ELaH8BpSVpl7DUW1hqISEdQMekNhLf9RnuY4y5GHYML2XIF26CLf7Ia9XSrxErqwhtt/SE7OZgOkFxMoXslpExh7lzKfqEOVU0Xmnq1xevv7RoHn/59itLyS/yeVFMXgXt5tMIjTWBvF4BPQNAXAabDKODTQY+aNPfVHrc21DdrhQYx4Jjm2Haa8WhNaB48fw6OuQJRLnbH5l2DU1bqccDgAa0MFnrixUG02/k7S8YY3xZxaqHUhho3frKPemwNPvh/tjOZbTEEF/7L47F3s8dR87GDsWTdgfXPLt5/sC5hXkh7RKW9RaWWkg4GQ6gK1XIF26CLf7Ia9XKr4ltlmYtwuJFO5DtlpvPLv8b8hoFmlfkdQrklWZ+RX//C9U5/GDWv1T8Ip8XxeTVuMPsTXyvP31eR15fMXmUJuT1CugZAGLitep0sV3GDXqX0nNioXKTgftseq+3Xmf11uusPpveG/vvDdVHCzx0ANLCfTnctxAYz7mGZ/DzaVBK6Nh3YWAnmw8I+8p1xgFp57LUEoPJ2mJIknYxS9rV64uFkx0nrvJDA7fJA9Oloq5LU3Hetn9wmcu9l+8GlreJYIzxZSvX3Iu9n7oav/Q+s+92BzsZDpwDySFfuAm2+COvVQsdMq/g4w7LnNaBsaR/a63j08PHyesUZF6R1ymQV5r5NT18XHX+fvWHT5eKX+Tzopi8CtnN1xLf69PPriavr5g8ShPyegX0DAAx8TYanLHQWKGnccIu49HEHcWpdikDQIn7V9EWtz8y5wlEefflyB7q8QBQ5EhtMSQdZd8FkH3lBtPvpHBy/qCzxx+wheCSMcbXrNtwVx5s1jy7edbcuG1WHn7KJe/VnKjdp66TB7lKOjRwW3XM0qFwiar//oFvEn2pXt84K/eOlZU/knu7wmi+Kfeexe8GdjK0iQDaQr5wE2zxR15rLnr44DN+q8uZl6BYSX+5+jPymgWYV+R1CuSVZn7dn/TyibZ1i+et01qQvsYF8ot8XhSTVyG7ZQShsSaQ1yugZwCISVxo3LDSlPi4fDex16ZfFLoNNBr6pBYVhRkxAOnh8k5WeALRyfldxuEz1OMBoARoZvHBppMx1s7iw8+Y5L2aE7XCYAoyeahaJFr22OMP1MYsOxQuUT0KvrRk5TAA+YF84SbY4o+81lx0a789zf7E5mDIbhkZt5v7FDQ0bjePphUct60ryK5NwecVeZ0CeaWpX3+++M6iOVuoHfIF8ot8XhSTVyGHeTLx/X57XQV5fcXkUZqQ1yugZwCIibdhpUntEDxvw0qTz2aYS9a3WAqNB5sMuOFAUdEdiHjnA+PoqMs7iT6dAAAAgDLkCzfBFn/ktWar2+/9KI1+xOahkL2uPR0jRqysYsxh7lT6yXecOprIay/yeUVep0Beae5X+MZH/M6pg/zOqYM8+vtfLDW/yOdFMXmF0FgzyOsV0DMAxMXXpJ8dbDJwX5PhmvTfvFZWMWjTj6TqWeyzGc4shMpzhRsxAMnp9oc7pT7GhwMR/IwbAAAAUId84SbY4o+81mx059TBVGHxaLDFZM3WlJC9rj3kME8vtTYVDMFesXkFv+BV1ih9Nr1RV05eXzF5lCbk9QroGQDiIgW/Um9in01/2mfTB787/E55lzFjjMmC5dFCjxsAJVxD01Z3IDo734M03EM9HgAAAKDIIV+4Cbb4I681U/3l6s+St6Jw1J0fUfn/+pkw2qzTKe3kE3m3MUOwV2xewS94lTVKn00dxuXk9RWTR2lCXq+AngEgLvI2FEryNuhdiq+r11ljwXKT/nyBhw2AIm5/ZGQ+MI5coR4LAAAAIADkCzfBFn/ktWaiB7N+/sXOp9UD4+0WTb9gH2811487LHNKfyt84yNyP4p0XpHXKZBX8AteZcXnLxpNSp9LrauWkddXLB5lAHm9AnoGgNh4bfp6+e5iqeWEWlsKxhjzNRmG1PohA0CB+3K4b6EtxbTLO6mjHg8AAAAgAOQLN8EWf+S1ZqJkfYxDDkteDgoOOerOK/29O6cOkvtRpPOKvM5i9Wq0WacLbbf0hBx150N2y0jIbhnZW4udoRlAXmexeBVsMVmVPpcaV/wNeX3F4lEGkNcroGcALA28jQanr6H6qLfR4PRadUlDN59Nf2XQph8ZaDT0FWh4AKji/lW0xe2PzHkCUe4eCjupxwMAAAAIAvnCTbDFH3mt6Sr6+1+oBsYXG6rz5tfENkuz0t/84vWXyD0p0nlFXmcxeTViZRXjDvOecYfZq7ZrfXr4OHm9xeJXCsjrLBav1EJjaxlC4ywgr1dAzwAAAFDh8k7qPIHopCcQ5e7AV6epxwMAAAAIBPnCTbDFH3mt6Wqio0kxMP5i59Nc/zf59eu/vmRa/Lfb1vGHDz7Lqpa//vbnfGrwPf719C818ebBrJ9Hf/+LYplX5HNFrvuTXh6+8VFMD2b9eb8HP3/RaJrYZnGF7OYrakGxXLe6nOQ+pevlny++w++cOsinh4/z8I2PYvMuXb+CdpMzUaPNyTd3Fevcyla5zC2Jse21LUpzCR5lBXm9AnoGAEjEZ9Mf99n0Xq9NX089FrC0cfvDZ+YD48hNl3cy54NcAAAAgBKCfOEm2OKPvNZ09Nff/lw1cJsafC/vfn36vE7xb9+f9GZUx8MHn/EvXn8pLni+G7yQkzd/+rTnu+u1b0x6vWx9Ctnr2scdZq/SwYDjDstcyG4ZGbebh8Yc5k6WpzkV/f0v+Jdvv8K/eP2llDtz/3L1Z/zLt1/hE06r4vs2+f5PNL8HP3/RaAptrzs6brfcTBUS52vX+tfTv+R/+rSH3/m4W7MvJCSFb3zEJ9rWJa1j3G4eldpuhOyWEdWDJBUUtJvT2SiT1WfHl2+/wid2Paf4xc8Xr7/Eb/10V0F3eyfOrdFmnW7MYe4cd5i9IbtlJPGLhnG75WbIUXc+aDc5pdcE7Sanwr04m6/7r9DK9P7LEfJ6BfQMAJBIqoP0ANAC1/BM80If4znX8Ewz9XgAAAAAwSBfuAm2+COvNR3d6nIqh20/3lIQv95eV6H49zM9DO/PF99RrSEbKbbsaN+o2bwK2evaMwn+JhwW/m+tdfzLt1/RPLRMDP3++tufL3rO1OB7SQ9KlOuPfW9ocg9+/qLRNG43D2UaFMfNgZ1P5+zP19O/jA/Jnda0dp+nfQ/+dFfW9aWjcYdlLg270x7vX3/7c+WgOJmc1rzMXbW5Ndqs04UcljOZjDFkN18bbdbplELjkMM8mYlHxaxMP6tyhLxeAT0DACSC0BgUAncgcnM+NA7n5TAXAAAAYIlDvnATbPFHXmsqfT39S9Udjl/94dOC+HXIvELx7ysFl8mkdpBftruN1cL0XOfViJVVqB0AmEkQmmmorqa7wQuLri9v6RD9/S9U25ckCwiTtRdJx6vQ9rqj4w7LrBahabptM9R05+PupB7lKrVd21ppIfBMRcpxPnzwWdIDMws9d9Xm1pjD3BlymKez9Go6aDefTvzv43bLzXQ8EkHpflZpBHm9AnoGAEgEoTHIN55AuGdhl/E02lIAAAAAWUG+cBNs8UdeayrdOXVQOdiR7dDNt197a5crjmFq8L2MapkafE/xOndOHczYF7UwPdnO5XR8GrGyipDdfE2TMNBpzbiFR9q+7XqOP/r2X/n08PGUbRPUlKwlQSqvxu3mvmzCvpDdMqL0WK67gm/tty+eCxoe1pjvncYhu/lKGrdi0jE+fPCZog+Uc1dJap8nGnh4LZVHoiidzyoNIa9XQM8AAIkgNAb5xDU8Y3L7I9OeQJR3+8Od1OMBAAAABIV84SbY4o+81lRS20EqD2zz7ZdWofGDWb9ywLkQgGaiuF7GMv3p056c5lWurRYSdeunu3KeA4qhcds6Pvn+T3Ia252Pu7PyKrS97mi6f2Pcbh4dt5uPT2yzNDO2cEieBnMpUXG9sh3ah8bR3/+Cf/HjLXkJOyccFi7v15uEpGPUOtjWYu6mNZc10rjD7E3lkShK57NKQ8jrFdAzAEAiCI1BPnEHIufndxlHr1GPBQAAABAY8oWbYIs/8lqT6cGsXzkgSWgtkG+/tAqNH32rHmxl+nP4ifaNitdJ1o81lU/jdvNxtUAqZDcHx+3mvqDd5ByxsgrGGJvYZmkO2k3Ocbu5L2Q3BxVf27Yu59YL2QRtt/bb+Z1TB2O+KvW3TdbXWM2r+dYdydsKjNvNo6Htlp7PXzSalK6h9Hqp1Uq2yndoLOmrP3zKwzc+4nc+7uZ3Th3kd04d5Le6nNxnM/CFw++m43xI41C8hbAzHVTHpdSeI6b2jbG5IH1uxOo4dVD1XtJi7iZ6p7YrXjpQMuSoOz9uNx8P2k3OoN3knNhmcYUcdefTaYOC0DhryOsV0DMAQCIIjUG+cP8q2iIdfnc4EKmnHg8AAAAgMOQLN8EWf+S1JtNfrv5MORBM6NWab7/Uehr/5erPMq4pfOMjxWt9+fYraV9D8QA8BV8ymVefv2g0jTsscyoh6NBos06XzKMRK6sYt5uP/7ft5kWvzzUQzSQ0vvXTXYptBZRC1WSeq3k1sc3iUg/tLLPjDvOeVPNpUT/ajqac7xWl4DMfoXE2c2v+wDfloD3kME+nmlsyFP92sr7nt366K2Xw+/DBZ/Ohs8I1cp278r+hFk6H7ObgeKs56Rpw4f5K2hJl3G7uU/NINCWbT3mAvF4BPQMAJILQGOQLtz866glEuTvw1WnqsQAAAACCQ75wE2zxR15rMqn1M05swZBvv95eV6E4jmwPy1La9ZrqYDa51A76ShViJ/MpZDdfUQmijqfr04iVVZx+drVmPklSa8WRGLwmC/i0Co3V2neE7Oag2s5iRb+31x0dt5v7OozLNblXlOZUPtorZDW3VA5VHHdY5sa217ak6xlT+bxSOxAyWfuRRD188Bn/8u1XNJ+7qeZwyFF3Xtq5nw5Jv7RAaJwt5PUK6BkAIBGExiAfvOUPH/UEotwTiE7i8DsAAAAgZ8gXboIt/shrTSa1Q60Sw8F8+9W3YZXiOO4GL2RVl9pP6ZMdzCbp4YPP+ITTunhX6c6ns55X463mepUgNO22aeOt5vpxu3lUS59ifql8eSAPjFPtJlUKjSff/0nmXtktN5XCz1Q7RZOgyb2i5Esmu9dzlZpfQbvJqfa+hbbXHc3Vq7vBC4rXvrXfnvbY7wYvqPZOz3XuSvfsFzufVrq/0jn8bxGqITxC42whr1dAzwAAiSA0BlqzcPjdnCcQ5d2XIyl/ygYAAACAlJAv3ARb/JHXmkyKP+d2Wgvu12d/W6MYKGXb7/Tr6V9mHXRNDx9X3lV56mDW82pRu4SFIFQ6vC0Zo8063bjd3KfW2kKL1gtJQ+P2jWm9D0q7SP988Z2MvVLqzRuyW0ZymF7a3CtZzgmtpOTXiJVVqPW6Hrebh7Tw6o99byyuvW1dWm0lHsz65+eWSmsLLebuo2/V2+ykc38pMdqs0yn1OF4I4Qv2nhd6PuUR8noF9AwAkAhCY6A1bn/4zPwu40hW3zIDAAAAYBHkCzfBFn/ktSaT0u68iV3PFdSvESurUAx8FMaRiRR/Ut+2LulBdo++Vd4xO+FIfgBeMp/UDnYLOSxnUvmyEBarH9DVto5Hf/+LnOdBstA43fYBi4K7FF6rzSmlncbzIajlZtBuPh2y17Vn0KOXMQ3uwfuT3qIMjZW+jFjYYRvMpCWDmldqO3iT7SCXXnfn1EHFHftaz121ez3bXcYSigcLbrO4tJhPxSCl+ZRHyOsV0DMAQCIIjYGWyHcZ4/A7AAAAQDPIF26CLf7Ia00mpTDnix9vKahfaj+vz/Wn/2q7DxP7NculFg6mOgAvmU8T2yzNStdU6887YmUVoe11R9UONpNravA9TeaBWmicbt2Pvp3fVXr7vR/xCaeVf7Hz6ZStQNTmVMhhOZOqbikYDTksZ0L2uvYUUyxnf9TmRbKd1For0a+JbZZmpd3n6e5gT8err/7waUZfoDx88Bn/06c9yl9G5WnuPvpWud90hr2cF4HQWFPI6xXQMwBAIgiNgZZglzEAAACQF8gXboIt/shrVdODWb9yaPz6SwX1S223ZLJwNx2p7ZJM9pN4tfD0r7/9edbzSulgrXG75Wbi86Q2FOmExRNOa8pD+TKRYt1t6/j9SW/B78GQva49ndA4LkB2mKdDjrrzwRaTVeGSOY9VLTzVMvjMxK+FXeiK/a2z6GOs6tXU4HtpfakktaFIJyzWeu6qBfo5eMAYQ2isMeT1CugZACARhMZAK+S7jF3DM9l+0w4AAACAxZAv3ARb/JHXqia1sKXQobFaSJpOz9RUUuzH6lA/fEsx9GrfmNO8Uto5u3CgFmOMsc9fNJpCDsuZpG0oZOrbsCqtVhmZSCk0VpoHhboHx+3mvkyD45i3DrM3oX1FzmMN3/hI8W9pGX5m4pfabuwcMG0/UwAAIABJREFUez8v8mry/Z8s+hvylhxfT/9y/jnJ2lDIdPu9H2k+d5Xem//6kgmhcQ73Xx4gr1dAzwAAiSA0BlqBXcYAAABA3iBfuAm2+COvNZkUwx2Fnbj58kt1V2kGQW0y3Q1eUKzxj31vLHruX3/7c8XnZrLjWcmnkN0ysijYbDXXB1tM1pCj7rzqAXcKYejCTlrN50GxhcaMze9AT9ebReGpwzw53mqW2tPlPFa10Djdfs9a+qXWziXkME+rtTzJgLi/qdTf+27wAr8/6Z1vRaJ2wF2Cvnz7lbztWlfaDX15kxGhcY73n8aQ1yugZwCARBAaAy3ALmMAAAAgr5Av3ARb/JHXmkzUB+GF7OYrSiHTnY+7tatRIfj6YufTi56ndnDewwef5TSvEg92G3dYZscdZm96QbFlLuSwnElou6D5PCjG0Jix+ZYdoe11R9UOx0vh3exCcJzzWIslNJ7fla68M3/cYd6jwS0Zf+/8eEv833Fa+Zdvv5Lee9C2jk++/5O8tjh59O2/8j9ffGfR3/70eR1CYw3uPw0hr1dAzwAAiSA0BlrgDnx1GruMAQAAgLxBvnATbPFHXmsyTXQ0KQY+iUFPPvxS2zE50bZO05+wK+1EnHDE9yn+evqXirsmJ9//Sc7zSjF8SifwtJv7VHaOaj4PijU0ljParNONOcydIYflTLohcshuDlb+Te5+qR2qWOjQWGnX+kJg7M3uLkw+t5QOmEspp5XfOXVQ8zYUmczd08+uRmis8f2XI+T1CugZACARhMYgV1zeyQq3PzKNXcYAAABA3iBfuAm2+COvNZnUdg0m7vTNh19qB3nd6nJqWuPDB58pBsJfvv1K7DlqB+Cp9T7OZF6ldbCdFHI6zNPjdvPxhJ68eZ9TIoTGiYw263QT2ywutd3qkg4/+VjOY1X74qGQofEh8wq1OTM5YmUVuXipNrfSOthOmi87n+Z3Pu7mD2b9BfPk0bfKO419NgNC4zzffxlCXq+AngEAEkFoDHLlLX/4KHYZAwAAAHmFfOEm2OKPvNZkUuvjO9G+Ma4tg9Z+TWyzuNTCJy0OwEuUYji+0Hri4YPPFMOxbMJrJZ/S2WkccpgnQ9stPWmGf5r7I2JoLGdse21LyG4OKnl7bUtNzmOdHj5OGhqHb3zE/9t2s+IYxrbXtmjlI8tmp/Gu5/ifL76TURsXLaX03vxbax1C4wLef2lAXq+AngEAEvE2Gpy+huqjXmvSb9YBUAS7jAEAAICCQL5wE2zxR15rMj188BmfcFoVwyD5AXBa+jXeaq5XO+BM613GktR60k4NvqcaCP7l6s80mVfJWimE7ObgQhCVCZr7I3pozNhC/2OVXd25fhFB2dP4/qRX9R4N2s2ntfSQpeppnPDF0tTge3mvP5Wiv/+F4vhyPRRQKTQet5uPJ3okqhhC42L3DIClg7dB7xpoNPT5mvTnB236EZ9N7/U2rMz15FYAMgK7jAEAAICCQL5wE2zxR15rKqkebNW2Lha2aeXXQrCnvPNW417GiVLaNXlrv125r3P7Rs3mVchuvrY4fLLczOHgMs29WQqhMWOMjTvMe5Tm1vTw8ZzGShUaP5j184n2jYp/e9xuHtWwLYVE3N+/td++eF78eEtWX6jkS2rtZ3Lt86wSGvcleiSqGELjYvcMAPHx2vR7fDZ9UGorIZfPpj+e+Hxfk/78YJOBD9r0IxTjBUsb7DIGAAAACgL5wk2wxR95ramkdgjchMPCJ5xW/tUfPtXErxErq1AKUCX9se+NvNap1rdYSfJd1rnOq9B2S49S4Jeib3Ey4uv6uJtPOK381n571iHmUgmNR5t1OqX3M7FHd6ZSC43lhylqrYcPPuNfvP6ScmDssMxNbLPkY80TNwalfsETHU2a9S3WYu4++vZfVX0K2evaszEh2GKyjjsssyo7u/N6XxRKDKFxsXsGgNj4Gg09SmGxpIFGQ1/ia7wNVZ2xvsXPV2vZewmUON3DM+2eQJS7A5Gb1GMBAAAAljjkCzfBFn/ktaajOx93q4eoTivfW7s8J7+CLSar2sF3Ew4L/+xva/LeE/X+pDe90NhpzXosTGFeBVtMVuVAy3wty52isb+36IC2jqbs3v8iCY0/f9FoCtpNzmwD9c9fNJoUQ+NTB3Maa7L2Jvny5/Z7P1KdowttEvJBWvfMrf32nO9Xrebuo29Vwm3H/MGSmc6l8VZzvdqvIRZ2L+f1viiUGELjYvcMAHHx2vT1PpthThYSjw40Gvp8DdVHB5sMo6qhsZVVSK9TehyAbPEEIlfmW1OEe6jHAgAAACxxyBdugi3+yGtNRw8ffKb6M3hZUDUUbDFZMzVgzGHuVNq1J9s1OWst+5uC1Km2I1Guyfd/ovm8CtktI8qeWm6Ot5rrs5lTf+x7Q3H82fTvLYbQOGSva5fmybjDMjfmMHdmOtfG7eY+JU/+fPGdnMZa6NA42a74kN2Sz1/tpn3PfPHjLfxu8EJW9Wk5dx99+6+qh1lKwXG6O47HHeY9yT6rFrzP631RKDGExsXuGQDi4msyXIu1oWg0xIV0gzb9SLJQOPZatKgAGuEanjG5/ZE5tz8y5/JO4hBFAAAAIL+QL9wEW/yR15qu7k96Ffv+KuyQvTLuMO9JtoNvtFmnC22vO6rav/i7wHguaDc5C+XTot2NCro/6dV8Xk1sszQnC83H7ebj6QTy463m+r4Nq1QDsgmHJasdoNSh8YiVVSiFdSG7+crC/EjKxDZLc7LWJ7m2kVA7bC0foXGywFgK04N2k1NJGvQ4XjSer/7wqfr94rTyOx93p3XP3A1e4Lff+5Hmc1eS2m5jSUG7+bTaFzRj22tbxu3moTQ++4JKHokohtC42D0DQFx8TfrZwSYD9zUZhhIfSxka2wxn5nseG6bzPlBQEsQOwPt1dNF8BAAAAIDmkC/cBFv8kdeaidINjmMhlt08GrJbRuRKtlNvUQiz3dJTSJ/UDs2SdKvLmbd5FbSbT6flp6Pu/Ljd3CcpZDdfGbdbbqbjZ7Z9oalD42Sh+neBnTS/zN6Qo+58yG4ZSfWlxITDwn/3Yq0290UBQuNM+m6r+uQwT4fslpGg3Xx6fv5k1NdXcVxqO4Pj1NHEb7/3I37n1MGYbnU5+Rc/3pLWuLXoaX7rp7tSf2Y5LHPxn1nmYNqfdw7LnGif6encfwWAvF4BPQNATLwNK02xvsQ2/aITf1OFxgONhj7p9XkfLCgJPIFI0BOI8u7hmawOOgAAAABARpAv3ARb/JHXmqnuBi+kbFWRq8YdljlZYFxQn758+xXVceW6IzXVvBp3mL358vRWlzPrnZrUobHaAXZa6I268pzHWojQOGlf8RwVcljO5Pp5ley+oZy7cj188FnaIXW2KlQrnXwr1WeVxpDXK6BnAIiJt9HgjIXG9Tpr4uOpdxrrTyM0Blrh/lW0Zb6XcXSSeiwAAABAiUC+cBNs8UdeazZ6+OCzpAdx5RRg2c3BiW2WZiqf1PrT5nIQVybzKuSoO6+pp23rcj7ojTo0Zky9H3Eu0vLgMqUvUrLt6Zuov/7253kNOscdlrk0W1ckHafmnwkazN1EPZj180+f12nh2ey4wzKX+N9bVy3L631RKKXzWaUh5PUK6BkAYuK16etjofHz1S2Jj6cRGl+Zb0+hD+Z9sGDJ0x2IeD2BKHdfDvdRjwUAAAAoEcgXboIt/shrzUV//e3PM2pXkTKIsZuHVHohF7QupcO97nzcXbB5FbLXtWfys3g1ffn2Kzn1YJb0p097yENjxrQNjoN282kt51biTuAvfrwlr/NRa41tr120ds/mPvzrb3+uyS8RtJq7anNr3G7uUwp90wiL50IOy5nRZp0u5LCcSXzcvAw7jbOAvF4BPQNAXGI9jW3644mPJQuNvVZW4bMZphdee6UggwVLFpd3ssLtj8x5AlHuGpq2Uo8HAAAAKBHIF26CLf7Ia9VCu6rL+LjdPJpVUOywzIYcdefVDqGi8Onr6V/yCac1bpxfT/+y4PNqzGHuTHaAm5I+fV7Hpwbf4w9m/Zr5odR+QesdoOl6NbHN0pxtG49xh2Vu3G4eSjg8T7MxTw8fn+/X+3G3pv5PdDTlNTAOOczpnieUkRe39tszGsetLqfmczfZ3Pr8RaMp5LCcSbfPeshRd/7zF40myYzPXzSa5F/uhLbXHS30Z1Wh7788QV6vgJ4BIC6DNv3N+YPw9LOJLSqShcY+m94r7VJW24kMQLp4AuEeTyDK3f7ICPVYAAAAgBKCfOEm2OKPvFYt/Qq2mKwT2yyu+cPIzJOqO/XmD5i6NrHN4tLiZ/H50INZP58afI//+eI7mgTGucyr0WadLmSvax+3m/tCDssZ2SFdVxYOxDsetJucC7u08+JH3G7X9o2atV7I1qsRK6sI2evag3bzabUDFuMONdtu6SmGXezZSGmnd5zaN3KfzcBDdsuI/JDERIXs5muJO9hDdnNw3GFedBaRClndR3/97c/5nVMH+eT7P+FfvP4S/+L1l/itLmcsYA/f+CjvQXGquTW2vbYl8f4at5v7JrZZXAlfMixiYpulOdhisooyn7S4/zSGvF4BPQNAXOR9jX02w7S3Qe+SHlMKjb31OquvyTAUe02TftbbsNKkdG0A0sUdiNz0BKK82x/upB4LAAAAUEKQL9wEW/yR11oIv4ItJmuaP38vaZ80Im/jvxu8wL/6w6dLyau8+qWlor//xXzIeuog/9OnPTx846O44D5Tv8a217ak2N0vrFfEc4u8PgE8gmcAlDoDjYY+KQSWwmNfk+Gar0k/Odhk4IM2/UhMsucNNhm4PGQGIBtcwzPNnkCUuwPRWZd3Mp3dKwAAAADQBvKFm2CLP/JaBfGLvEZBfIJX8Ate0XpFXp8AHsEzAABjvib9+cRAOJV8Nv3p1FcGIDnuwFen50PjyHnqsQAAAAAlBvnCTbDFH3mtgvhFXqMgPsEr+AWvaL0ir08Aj+AZAGAeb4OuWWk38SLZ9CNemz7Tn8cAoIjbHx31BKK8e3imnXosAAAAQIlBvnATbPFHXqsgfpHXKIhP8Ap+wStar8jrE8AjeAYAiMdbr7N6Gw1OX0P10YFGQ99Ao6HP11B91NtocCYelgdALriGpq0LB+DNoTUFAAAAUHDIF26CLf7IaxXEL/IaBfEJXsEveEXrFXl9AngEzwAAANDgCYR7PIEo9wQiV6jHAgAAAJQg5As3wRZ/5LUK4hd5jYL4BK/gF7yi9Yq8PgE8gmcAAABocPuj1zyBKH9reMZFPRYAAACgBCFfuAm2+COvVRC/yGsUxCd4Bb/gFa1X5PUJ4BE8AwAAUHhc3skKtz8y5wlEuWt4xkQ9HgAAAKAEIV+4Cbb4I69VEL/IaxTEJ3gFv+AVrVfk9QngETwDAABQeLqHZ9o9gSh3ByI3qccCAAAAlCjkCzfBFn/ktQriF3mNgvgEr+AXvKL1irw+ATyCZwAsZXw2/XHpMLt8ydtQ3U5dJxAPdyBy3hOIcvflcB/1WAAAAIAShXzhJtjij7xWQfwir1EQn+AV/IJXtF6R1yeAR/AMgKWKt15nHWwy8LzLph+hrhWIhycQnVxoTdFMPRYAAACgRCFfuAm2+COvVRC/yGsUxCd4Bb/gFa1X5PUJ4BE8A2CpgtAYFCuu4ZlmTyDKPYHoJPVYAAAAgBKGfOEm2OKPvFZB/CKvURCf4BX8gle0XpHXJ4BH8AyApQzaU4BixD0cOe4JRHl3IOKlHgsAAABQwpAv3ARb/JHXKohf5DUK4hO8gl/witYr8voE8AieAQAAKCxuf2TEE4jy7suRPdRjAQAAAEoY8oWbYIs/8loF8Yu8RkF8glfwC17RekVenwAewTMAAACFw+Wd1HkCUe72R+Zc3skK6vEAAAAAJQz5wk2wxR95rYL4RV6jID7BK/gFr2i9Iq9PAI/gGQAAgMLRPTzTvhAaoxc2AAAAQAv5wk2wxR95rYL4RV6jID7BK/gFr2i9Iq9PAI/gGQAAgMIh9TN2+8NnqMcCAAAAlDjkCzfBFn/ktQriF3mNgvgEr+AXvKL1irw+ATyCZwCA7/A+X90y0Gjo8zUZhgZt+hFJvibD0Pyhd3qX18rQUgBkjScQueIJRHm3P9xJPRYAAACgxCFfuAm2+COvVRC/yGsUxCd4Bb/gFa1X5PUJ4BE8AwAw5rXp9wza9DcHmww8lXw2w7TPpj/utep01OMG4uEJRCc9gSh3DU1bqccCAAAAlDjkCzfBFn/ktQriF3mNgvgEr+AXvKL1irw+ATyCZwCUOt4GvSudsHhxeKwPIjgGmRA7BC8QnaUeCwAAAACw+INf8Il4XpHXKZBX8AtewSO6+QTPAChFvA1VnUphsM+mPz3fjqK63WvT75lvWaE/77MZpuOe22S4Rl0DEIfuy5E9nkCUewKRK9RjAQAAAAAWf/ALPhHPK/I6BfIKfsEreEQ3n+AZAKXIoE0/ErdzuEHXnOo1vobqo3HBcaOhpxBjBeLjvhzu8wSi3H053Ec9FgAAAABg8Qe/4BPxvCKvUyCv4Be8gkd08wmeAVBqeK2swmczzEl9ijNpNeFtqG6X7TYeyuc4wdIhdgje5cge6rEAAAAAAIs/+AWfiOcVeZ0CeQW/4BU8optP8AyAUsPbaHDKDrc7k+nrfU36yfnQWD+Zj/GBpYfbH5n2BKLc5Z1EL2wAAACAHvKFm2CLP/JaBfGLvEZBfIJX8Ate0XpFXp8AHsEzAEoVeWjsbdC7Mn29z6a/Ir0+D8MDSwzX0LR1vp9xFF8yAAAAAMUB+cJNsMUfea2C+EVeoyA+wSv4Ba9ovSKvTwCP4BkApYq3XmeVQt+BRkNfpq+XDsXz2QzTeRgeWGLgEDwAAACg6CBfuAm2+COvVRC/yGsUxCdWXl52f+HvCK2FOgoB+bwQZW7BK3gEz4rGMwDExddkuPZdT2NWke7rvM9Xt3zX01h/Pp9jBEsDd+Cr055AlL/lDx+lHgsAAAAAGGNY/MEv+FQM8wqkD/m8EGhukdcpgFfk9QngETwDoJTxNuiaMw1/vVadbrDJMLoQNs95bfr6fI8TiI/bH73mCUR59/BMO/VYAAAAAMAYw+IPfsGnYphXIH3I54VAc4u8TgG8Iq9PAI/gGQCljq/R0PPdgXj608meKw+M53shV3UWapxAbDyBSNATiHLX0LSVeiwAAAAAYIxh8Qe/4FMxzCuQPuTzQqC5RV6nAF6R1yeAR/AMgKWMz6Y/PtBo6EslX5N+UhYcX1F7njww9tn0Xm+jwemt11mp6wTFj9sfmfMEovhwBgAAAIoH8oWbYIs/8loF8Yu8RkF8AplDPi8EmlvkdQrgFXl9AngEzwBYqsgPusurbPoR6lpBceManjHNH4IXnaQeCwAAAABikC/cBFv8kdcqiF/kNQriE8gc8nkh0Nwir1MAr8jrE8AjeAbAUgWhMSgW3L+KtngCUe72RzBXAAAAgOKBfOEm2OKPvFZB/CKvURCfQOaQzwuB5hZ5nQJ4RV6fAB7BMwCWMum2p8hFXpt+D3WdoLjp9oc7PYEo7w5EvNRjAQAAAEAM8oWbYIs/8loF8Yu8RkF8AplDPi8EmlvkdQrgFXl9AngEzwAAAOQX93DkuCcQ5e7L4T7qsQAAAAAgBvnCTbDFH3mtgvhFXqMgPoHMIZ8XAs0t8joF8Iq8PgE8gmcAAADyizsQOe8JRPlbwzMu6rEAAAAAIAb5wk2wxR95rYL4RV6jID6BzCGfFwLNLfI6BfCKvD4BPIJnAAAA8ovbH73mCUS5eyjspB4LAAAAAGKQL9wEW/yR1yqIX+Q1CuITyBzyeSHQ3CKvUwCvyOsTwCN4BgAAIL94ApGgJxDlrqFpK/VYAAAAABCDfOEm2OKPvFZB/CKvURCfQOaQzwuB5hZ5nQJ4RV6fAB7BMwAAAPnF7Y/MeQJRfDADAAAAxQX5wk2wxR95rYL4RV6jID6BzCGfFwLNLfI6i92r8vKy+wvXF1oLdRQK8jlR7PMKgCWJ16bfM2jTj/hshunBJgPPRL4mwzXq8YPixTU0bfUEotwTiE5SjwUAAAAAcZAv3ARb/JHXKohf5DUK4hPIHPJ5IdDcIq9TIK9A+pDPCcwrAAqMr8lwLdOgOE42/Qh1DaB4cQ+FnZ5AlLv9EcwTAAAAoLggX7gJtvgjr1UEv7B7D+QR8vtHhHsQXoE8Qj4nMK8AKCBem35PtmGxz6YPDjQa+rwNVZ3UdYDi5a3hGZcnEOXdgYiXeiwAAAAAiOP/Z+/+QqNI933/P7BYIDRuelJF8CJCiDdx+o8iwyAoGBEkzt6avsky2eMW0fEwihANCHEvOQY8EBB08CLoRaCw2klcGQcZMvu4xrmIehPx4kS8afAcWhDEkzWzkMWGnxc/9u/5XZgqqzv9pzpd3d960u8XfOAs012p55vutbs/q85T4l/cDPvyJ75Ww+YFRE38/WPQe1B8nQbNCuGJvyZ4XQFt5Gat14FtJuacVGKL/7OM5ayWwyVln5P6bMR7jpO2B9p+0oitb+79ffc3f/ltMpjT939/8PFK478//GbutwEv3BQPAABx4l/cDPvyJ75Ww+YFRE38/WPQe1B8nQbNCuGJvyZ4XQFt4vSqTbW2mKhWGq/+bOLjz+x3waIZnS2wf3GofPPDb99JnzMAAB1M/IubYV/+xNdq2LyAqIm/fwx6D4qv06BZITzx1wSvK6BNnFRyp3/FcIUtJtyMNVWtNFbq01XKd9L2ZMtPFsbwriyuXxj//u7E/N/4HxwAAJAj/sXNsC9/4ms1bF5A1MTfPwa9B8XXadCsEJ74a4LXFdAmTtoeqLXNhH81cdZ+WOn53pXI3AgPQd/c+/vuMKXxyR9+Oy99rgAAdDjxL26GffkTX6th8wKiJv7+Meg9KL5Og2aF8MRfE7yugDZxtnft/nSlcdfgmp+nrBOrpfBSpecHtqj40PqzhUm++eHvy3VK49cnnNebpM8TAIAOJ/7FzbAvf+JrNWxeQNTE3z8GvQfF12nQrBCe+GuC1xXQJk4qscW/CV7a/nbNz4NXIlfYtzifsRY/XolsvW/PGcMUp/7ye65WaXzqL7/npM8RAADw5Y95AUYRf/8Y9B4UX6dBs0J44q8JXldAG3n7ErsZ60H5z5xetcnN2O9Wt6iYc3qVf2Wo05/s9W+il7WX23vW4TnDX22Z/dPh3Pcjucm5kSFnbmRocW5kaNE5McBVri32zQ+/v6u4l/H93yteuQ4AANpO/IubYV/+xNdq2LyAqIm/fwx6D4qv06BZITzx1wSvK6CN3Iz9Xa2riYM/dzNWwc3Y37lZ65abtd5/+nf7O4lzr8YZ/mrL7NGhibmRodf3RnO6UpyRXK/0eW50J3/47Xyl0vjE/N92Sp8bAABQSvHlj3kBZhF//xj0HhRfp0GzQnjirwleV0AbORmr383YH6qVv05/sjdYEJfHzdjvglcgS3KGv9pyb3RorrQgHno/N3Lk4fcjucnZ0SOD+ZF/GciP/MtA2ZXGU+rjf2kQQuTiKABAu4l/cTPsy5/4Wg2bFxA18fePQe9B8XUaNCuEJ/6a4HUFtJmTsk7kM9aim7VuVf55cmel4tjNWAVne9fudp9vJbNHhybmRoc+3BvN6bnRoQ9zI0PO3aOHw56bdFlGCPkYAEB7iX9xM+zLn/haDZsXEDXx949B70HxdRo0K4Qn/prgdQXEkNObTDqprsE7aXvyTtqedFJdg05vMil+Xrlccm7kyMPAlcVzzvBXa7bZqEMrpXTx7T8IIQJRlMYAIEX8i5thX/7E12rYvICoib9/DHoPiq/ToFkhPPHXBK8rAKE4JwY2zY0OFbxtKGb/dDi3zkNRGhMiGEVpDABSxL+4GfblT3yths0LiJr4+8eg96D4Og2aFcITf03wugIQyr3RoQf3RnN6bmTo9ezo4f4mDkVpTIhgFKUxAEgR/+Jm2Jc/8bUaNi8gauLvH4Peg+LrNGhWCE/8NcHrCkBdcyNHvvWuMHZGcr1NHo7SmBDBKEpjAJAi/sXNsC9/4ms1bF5A1MTfPwa9B8XXadCsEJ74a4LXFRAhN2NNePsQtypOqmuwnWtyTgxsujcy9O7eaE43sSVFEKUxIYJRlMYAIEX8i5thX/7E12rYvICoib9/DHoPiq/ToFkhPPHXBK8rICJOf7I3n7V1y5OxFtu5ru//9Z9HVq8yXo7okJTGhAhGURoDgBTxL26GffkTX6th8wKiJv7+Meg9KL5Og2aF8MRfE7yugIhs1NL43ujQ3L3RnP5+JHciokNSGhMiGEVpDABSxL+4GfblT3yths0LiJr4+8eg96D4Og2aFcITf03wugIitBG3p7g3cmTp3mhO3z16eHdEh6Q0JkQwitIYAKSIf3Ez7Muf+FoNmxcQNfH3j0HvQfF1GjQrhCf+muB1BaCmuZGh1/dGc9rJ5ZIRHZLSmBDBKEpjAJAi/sXNsC9/4ms1bF5A1MTfPwa9B8XXadCsEJ74a4LXFYCavNI4wkNSGhMiGEVpDABSxL+4GfblT3yths0LiJr4+8eg96D4Og2aFcITf03wugJQE6UxIRsritIYAKSIf3Ez7Muf+FoNmxcQNfH3j0HvQfF1GjQrhCf+muB1BaAmSmNCNlYUpTEASBH/4mbYlz/xtRo2LyBq4u8fg96D4us0aFYIT/w1wesKEORkrJybtefyGWvRzVrv81lbuxn7w8f/bM+5aftbp1dtkjxHSmNCNlYUpTEASBH/4mbYlz/xtRo2LyBq4u8fg96D4us0aFYIT/w1wesKEOCk7YF8xlrKZ21dL27GfuekPhuROldKY0I2VhSlMQBIEf/iZtiXP/G1GjYvIGri7x+D3oPi6zRoVghP/DXB6wpoMyfVNRimLF5bHlsPJM6X0piQjRVFaQwAUsS/uBn25U98rYbNC4ia+PvHoPeg+DoNmhXCE39N8LrYnz6WAAAgAElEQVQC2sjpTSbdjP2upAzO2nNOxso5aXsgmDtpe9LNWq9LHpvqOt/uc6Y0bm1uTs/osfEJfXXquvi5kM6IojQGACniX9wM+/InvlbD5gVETfz9Y9B7UHydBs0K4Ym/JnhdAW3kZq1bgSuHC04qsaXec5zUZyOBrSo+OKnkznacq+fe6NB7SuPWZc/efVoppfv6trX9dz9bfqWfLL1c13OfLL3Us/MLenZ+QReKK+s6hvf89Z5DpWM1cz6dEkVpDABSxL+4GfblT3yths0LiJr4+8eg96D4Og2aFcITf03wugLayM1YBX+f4v5kb+jnpbrOB8rmqRaeYgln+Kst90Zz+t7I0LsIDxtJafzzL091d3d3sAAryRdf7tYXL13Rz5ZfiZd0tSJVGh/JDZfM6/LkVN3nOPn7ev+Bg2vmnkhs1kdyw/pF4U3dY1y8dEX3b/98zd+rp2drQ1dbF4oremx8Qvf1bav4999/4KD43zauCcypYSMTD3qP/ftfl49dWsjVetwfNlv/u9p706SsrmNdmBWACsS/uBn25U98rYbNC4ia+PvHoPeg+DoNmhXCE39N8LoC2sTpVZs+bUlh3Wr0+d62Fu3c23j2T4dz90Zzem7kyMMID6uVar40vnjpSqgio7u7Wzv5++JFXbVIlMa3Z+6umdPY+ETN55w5d6HurLM7dlUtjp8svdRffLm77jGOHT9V9/xn5xd0T8/WuseK4grmjZjAjBo2MvGg9/jlv+rjl/+q6xSi+vT9vxuf9c6JWQGoQvyLm2Ff/sTXati8gKiJv38Meg+Kr9OgWSE88dcEryugTZxUcqdfGqftbxt9vpu1H64Wzq9bcX6V3BsdWl4tjRs+3xoiKY3Hxif88uvy5FTJ9gSXJ6fWXM368y9Pxcu6Sml3aVworvizCV6lW6s0dvL3/cd5VwR7heyTpZd6/4GD/s+/+HJ3xWMMHjrsP2bw0GH96PFz/2e3Z+6WXL1c64rjR4+flzz2zLkLenZ+Yc35jo1PsE1FlQTeFw0LFqF1ClHxElO6CGVWACoQ/+Jm2Jc/8bUaNi8gauLvH4Peg+LrNGhWCE/8NcHrCmgTJ20PeKWxk7Fq/n9XrsTNWI73/FacX7nvR3InvK0pnBMDmyI8dOSlcXlp6JWjwTIzu2OXeFlXKVGWxoXiSt3tOC5PTmmlPm4pcXN6JlRp7J1jrVkHryIuL+hn5xf8n1XbNuLnX57qRGJz3b+VV3QnEpv17Zm7Dc0n7luVtCve32I9b95KRWiVQlS8xJQuQpkVgArEv7gZ9uVPfK2GzQuImvj7x6D3oPg6DZoVwhN/TfC6AtrE6U0mvdL3TtqebPT5+ay97O2H3ILTK/H98Fc750aHPtwbzenZPx1uuOCuoy2lsVdmekWkUiqWpWFUpfG1G9O6r29bzfL32fIrfx4XL10pKXOrPe/J0stQW0cEr0Y+c+5Cyc+OHT/l/+zHn36teoxgyV/pbxrcVuPipSsNz+jY8VM6u2NXw2XzRos3w/W8eWsVocFCtC+1V7zElC5CmRWACsS/uBn25U98rYbNC4ia+PvHoPeg+DoNmhXCE39N8LoC2sjNWq/zWVvnM9ZSI89zetUmN2N/+Lg9hR3l/sJrzI4eGfQK43tHj3zXgl/RttK4+Lb0Ktlqexv//MtTfXXquj52/JTes3efPpIb1mPjEzULzqiO0Wxp7JXF3hprlcbDR7/2f1ehuBKqNA7uHV2rbC0UV/xtI8rXErwKud5avMdVujGfN6tEYvO6/geAYHndyeWxUqpmkRlVjv2Pp/r4zP8RLzObLUKZFaUxECHxL26GffkTX6th8wKiJv7+Meg9KL5Og2aF8MRfE7yugDZyM9YDf1/jjDWxzudNteLcnBMDm2aPDk3cG83pjxl6EPG2FJ62lsZeUaoqlMaF4oo+efps8MrLNdl/4GDNgrLZY6y3NC4vi5VSes/efSV7BQfz8y9P15S/YUrjYOle7SZ3XrI7dlV8rHee9db440+/Vr2qOXjV+OChw+t6zfz4068l56g6tDxWbSpCj//3R/rYzWV9au7/iheacS+NN8qsWvB/L4CNRvyLm2Ff/sTXati8gKiJv38Meg+Kr9OgWSE88dcEryugjZztXbu9K4ZXb2p3y+lP9tZ+fLAwtj84Gas/6vP6/l//eWRuZOi1Xxi35gpjT1tL4+BVrsEiM3hDOKWU7t/+uR4++rUeG5/QR3LDJT/r7u6uWPpGcYxGS+NKZfH+AwdrzqD49lOhGyxcw5TG3vPCnN+R3LB/PO9GecFj1Pu7B7fC2LN3X8nPgqV3raupw8TJ3y8pw1WHlceBdTcszJYLx//88MPuwW+NLkCjKEKZFYByf/zjH/5T1fgfmU3J6jraQfyLLl+W0eHE3z8GvQfF12nQrBCe+GuC1xXQZm6q67xXAvvJWItuxnpwJ21P3knbk27WfuhmrEL549y0/W1U55Ef+ZeB2dGhqXsjQ+/8snjkyNLdo4d3R/U7qmhbafzo8XP/6tTy0jO47cLw0a91obhS8vNCcaWkBD15+uya40dxjLClcaWyePDQ4TU3nauUq1PXtVIft3UIXokcpjQOe5Vw8W3pVd3Bv8ngocP+v1fbIqT49h/6ReFN1dI4uHXFtRvTenZ+QR87fsov5hOJzXrP3n365OmzVa+2Ls/s/ELJPsqqQ8rjwHobVrMI/fPDD//2579+N3zxP7Yoxc3dmBUANIeSHZDFe7Ah4sUc5d7Gw3sQ6FBu1p5bUxzXiZuxnPX8rrtHD+/+fiQ3OfevQ7fmRoYW740cWfq0BcWnsvj7f/3nkajXWYVWqvWl8bPlVyVXGV+dul7yM69Mzu7YVfP3BEvJ4JXCURyj+LZ+adxMWewVsT09W7VSa0vrMKWx9/Mvvtxd93edOXfBf3ywePVKa6U+Xo1d6YrrF4U3JX/T8tI4eIzyeZQnkdjc0I3yfv7laUmx7f1NN2p5HFhnwyoWoaUFqP8+ly4xpYtQZgUAANAxxAtfSmMA2ECcVHJnPmMt1i2MM9ais71r3Vf/3hsdWl5TEgfy/UjuRITLCiPy0tjbEsLL8NGv/UJX1Skgg2VypVyenPIfe3N6JtJjFN9WL43Lt77w1hn2Klov3n7LPT1b11wJ3UhpXD7Den+TazemS34W3KKip2erPnb8lP/32n/goH8TvWq/L3hs7xgnT5/Vt2fu6tn5BX3txnTJje6Uqn3jvkp5svSy5GppFbIsNy2B9TWspAitXID673PpElO6CGVWAAAAnYErQgEALeGkkjudtD3gZqwJf3uKjDXhpO0BJ5Xc2ezxvx/+auf3I7nJ70dyk/dGh+bmRoYWy4vjudGhwtzIkci2vqgj8tK4Vk6ePrvmBm7BK2LrXbEbvDlb8OrVKI5RfFu9NA7u79vd3R36yuJgfv7lqV+el5e4xbeNlcb92z9v6G9SfvX3s+VXa/YRLk9wq4jym90Fj33s+Kk1BbiX4DYW6y18g3NRStW8EaKJCaytYSMTD3rrFKD++1y6xJQuQpkVAAAAAAAwzvfDX+2cGzny7dzoUCFYHs+OHhls8a+OvDTO7til9+zd5+dIbliPjU9UvSo3uBVBeaFcnmB5O3z060iPUXxbe3uK4DYM3d3d+sy5Cw0VmF4JW237jDClsbe1RZg9jYNFerXZ3565698ocM/effrMuQv+3+rZ8quSYjj4vODV2pUK8EpzSyQ2N/SaqnSlcdgbFJqUwPoaNnDC2VSnAPXf59IlpnQRyqwAAAAAAIDR8iP/MhDcxmJuZMhxTgxsatGvi7w0rnYjvGoJXvEapkhUFQrfKI4RPE6lcrJQXNGXJ6f84latFqEnT5+tWx47+fv+cy5PTunZ+YU1CRaxw0e/9v89eBVvIwVs8KZ/9Yr0SgmW2OVbfpTfCK/WcYJXLD9Zehnq71NeFvf0bNWXJ6eqXtFscgLrbJmurn/6r+A8Tc3qOlqKWQEAAAAAgFhbvfL4w8fi+MjDFhXHoYrWemmmNA6Wm/VKxWpbS0RxjOLb+jfCK76tXh4fO36q6u++eOnKusuf4DkGy/F6RbB348FGr/CtdM4//vRryc+CJXi1q6Ir/W1qleudVhZ7Cay3lcRv5GHQzUDE12nQrAAAAAAA2PicjJVzs/ZcPmMtulnrfT5razdjf/j4n+05N21/6/SqVl3xW9HqVcfvvSuOW/ArxEvj4DYK5eVkeW5Oz/iPDd7ELopjFN+GK429VCqPlfp4lXB5eRy8UV+jCV7lG7y5XK0rfINbSxzJDTf89ywUV/x1VbppX/D4+w8crHks76Z73d3dFX/eqWWxl8C6W0m8xDSoCBVfp0GzAgAAAABg43LS9kA+Yy3ls7auFzdjv3NSn4208/y+H/5qp1ccfz+SOxHx4cVL42CJW6/gDF49G7xqNYpjFN82VhoHC9Zq5XEjex6H2dM4eJV0+dYawQS3unDy9xv+ewbneXlyquJjvPUmEpurXvX8bPmVf/O/PXv3lfys08tiL4H1t5J4iWlQESq+ToNmBQAAAADAxuSkugbDlMVry2PrQTvPc/ZPh3P3RnP63sjQu4i3qRAvjQvFFf9q1ERis749c7fi44L76J48fTbyYxTfrq80Dp5DeXlcb+uGYMKUxsW3pTfkq7TOJ0svdXd3t1/CNrqOazem/aK3r29b1QI3eHX3mXMXKs4juDVF+bmePH22o8tiL4rSOG5FqPg6DZoVAAAAAAAbj9ObTLoZ+11JGZy155yMlXPS9kAwd9L2pJu1Xpc8NtV1vp3ne2/kyNK90ZyePZqL8veKl8bFt//Qt2fullxxevL0WX175q6enV/Qt2fullyR2t3dXfEK3iiO0UxpHCxLvfK4FaVxsPhOJDbrM+cuaCd/X8/OL+irU9f9wjiR2FzxKuPZ+QW9Z+8+PTY+seZGfOUzevT4edXzCJbTSik9eOiwP++b0zMl+y9nd+xa8/zho193dFnsRVEax60IFV+nQbMCAAAAAGDjcbPWrcCVwwUnldhS7zlO6rORwFYVH5xUcmc7zlWpT1cbz40MLUZ42FiUxsW3H7dU8K5wrZYvvtxds8hs9hhRlMZeCsWVujflCyZsaVx8W1ocV0q1wrj4tvQmdtWS3bEr1N8xzLH2HzhYsaB/svSyo8tiL4FZtZJ4iWlQESq+ToNmBQAAAADAxuNmrIK/T3F/sjf081Jd5wNl81QLT7GEk8slvS0qIjxsJKXxzekZ3d3drfv6tumff3m67uM8evxc7z9w0N9qQq1uXbD/wMHQV6Q2cwzvRnPruXlcs3n0+Lnu69umu7u7a97kzot39XRwnV98uVufPH22ZuFbKK7osfEJ3b/985Jyt69vm96zd1+o3x2Mtzdx8Krjvr5tev+Bg2tuNEjWRlEax60IFV+nQbMCAAAAAGBjcXrVpk9bUli3Gn2+t61Fu/c29m6IF+G+xpGUxoSQ9UVRGsetCBVfp0GzAgAAAABgY3FSyZ1+aZy2v230+W7WfrhaOL9uxflVc290aPneaE5/P/xVVNtiUBoTIhhFaRy3IlR8nQbNCgAAAACAjcVJ2wNeaexkrFyjz3czluM9vxXnV8290aG5e6M5Pfunww2fcxWUxoQIRlEax60IFV+nQbMCAAAAAGBjcXqTSa/0vZO2Jxt9fj5rL3v7Ibfg9Kr6fiQ3eW80p++NDkW1LQalMSGCUZTGcStCxddp0KwAAAAAANh43Kz1Op+1dT5jLTXyPKdXbXIz9oeP21PYD1t1fhV/9/BXW+ZGhz7cG81pZyTXG8EhKY0JEYyiNI5bESq+ToNmBQAAAADAxuNmrAf+vsYZa2Kdz5tq5TlWMvevQ7fujeb0vZEjSxHcEI/SmBDBKErjuBWh4us0aFYAAAAAAGw8zvau3d4Vw6s3tbvl9Cd7az8+WBjbH5yM1d/GU/54Hrlccm50qHBvNKfnRoacJotjSmNCBKMojeNWhIqv06BZAQAAAACwMbmprvNeCewnYy26GevBnbQ9eSdtT7pZ+6GbsQrlj3PT9rdS5z07erjf26ZibuTIQyeXS67zUJTGhAhGURrHrQgVX6dBswIAAAAAYONys/bcmuK4TtyM5Uif992jh3ffGx16f280p+dGhwqzo0cG13EYSmNCBKMojeNWhIqv06BZAQAAAACwsTmp5M58xlqsWxhnrEVne9du6fP1zI4e7r83OrR8bzSnvauOZ/90ONfAISiNCRGMojSOWxEqvk6DZgUAAAAAQGdwUsmdTtoecDPWhL89RcaacNL2gJNK7pQ+v2pmj+bOe1cdf7xJ3tC7uX8duvX9SO7E98Nf1TpvSmNCBKMojeNWhIqv06BZAQAAAACAuHNyueT3I7kT90aOLPnlcVnmRocKzvBXWwJPozQmRDCK0jhuRaj4Og2aFQAAAAAAMMns6OH+2aO583MjQ05w+4p7ozlddtM8SmNCBKMojeNWhIqv06BZAQAAAACADYrSmBDBKErjuBWh4us0aFYAAAAAAGx8zvau3XfS9qSbtefyGWvRi5u15+6k7UknZZ1wetUm6fOMGKUxIYJRlMZxK0LF12nQrAAAAAAA2Lic1Gcj+ay9nM/aul7cjP3OzVgTTm8yWf/IRqA0JkQwitI4bkWo+DoNmhUAAAAAABuTm7EmwpTFa8tjq7BBimNNCIlFHNU64iWmQUWo+DoNmhUAAAAAABvP6hXGa8pgN2NNfdyOomvQSVkn7qTtSTdjOW7G/lDy2Kz9UHoNEZAuygghn9Iq4iWmQUWo+DoNmhUAAAAAABtPcEsKN2MVnFRyZ63HO71qk5vqOl9SHKftb9t1vi2ilWJ7CkIkoyiN41SEiq/ToFkBAAAAALCxOL1qk3flsJux3zWy1UTwCmU3a8+18jzbgNKYEOEoSuM4FaHi6zRoVgAAAAAAbCxO2h4I3Nzuu0af72at9x9LY+t1K86vjSiNCRGOojSOUxEqvk6DZgUAAAAAwMYSLI2dlHWi0ee7GeuB9/wWnF47URoTIhxFaRynIlR8nQbNCgAAAACAjcXpTSa90vdO2p5s9Pn5jLXkbW3RgtNrJ0pjQoSjKI3jVISKr9OgWQEAAAAAsPG4Wfvhpz2N1aawz3NSyZ2f9jS2brXyHNuA0pgQ4ShK4zgVoeLrNGhWAAAAAABsPE4qudO/GV7I8tfpVZsCVxl/cPqTvS0+zVajNCZEOIrSOE5FqPg6DZoVAAAAAAAbk5u2v/10QzxrqtZjnV61ybs6+eNeyJ+NtOs8W4jSmBDhKErjOBWh4us0aFYAAAAAAGw8Tiq500nbA8Ei2M1YD+6k7clKyWesRe9x+ay9XO1xXpyM1S+9xhAojQkRjqI0jlMRKr5Og2YFAAAAAMDGEyiAWxInZZ2QXmMIlMaECEdRGsepCBVfp0GzAgAAAABgY3F61SZKY6UUpTEh4lGUxnEqQsXXadCsAAAAAADYeNxU1/l6W0w0E0NukkdpTIhwFKVxnIpQ8XUaNCsAAAAAALBBURoTIhxFaRynIlR8nQbNCgAAAAAAbFCUxoQIR1Eax6kIFV+nQbMCAAAAAABhuRlrws1YjpOx+qXPJQRKY0KEoyiN41SEiq/ToFkBAAAAAICwuBGeuXmy9FLv2btP79m7T//406/i50M6I4rSOE5FqPg6DZoVAAAAAAAIq5NL4x9/+lXPzi/4efT4uXgh10hm5xf8Au/ajem2/L6b0zP62o1pPTu/sO7jPHr8XF+7Ma1vTs80dZzi24/Fuff3e1F409A5zM4v6KtT1/Xtmbt6dn5BF4or4n9TE6IojeNUhIqv06BZAQAAAACAsDq1NN6zd1+w/FqT/QcOtqWIbSbtKI2fLL3Uw0e/1t3d3RXndPL02VBl7ZOll3rw0OGKx+nu7tYXL11p+Nyc/P01xwrznOyOXRXXkkhs1idPn9XPll+J/23jnMDMWvY+ly4xDSpCxddp0KwAAAAAAEBYnVoaqwqlYaXs2buvoStY25lWl8az8ws6kdhcd0Z9fdtqXqX76PHzNWVxX9+2NcceG58IfW6F4krF8rfWcy5PTq05hz179605TnbHLq46rpHArFr2PpcuMQ0qQsXXadCsAAAAAABAWJ1eGu/Zu6+k3JydX9Bnzl3QPT1b/cd88eVu8aKuUlpdGo+NT2illO7p2aovXrri75v8bPmVvjp1vaQIPnn6bNXj9G//vKQYfrL00v+Zk7+v+/q2+T+/OnU91Ll5BXAisbnk+NUe/+jxc7+k7uvbpn/+5WnJz58svdRffLl7XQV2p0VRGsepCBVfp0GzAgAAAAAAYVEa76v48ydLL0tK0dszd8XLuvJEXRqXF6lO/r6+eOlK1atug7+/u7u74mOCW0gMHjpc9zjZHbvqnuez5Vf+3+bipSslW41Ue07wKuOb0zNVj+s9Zv+Bg2t+btqe162KojSOUxEqvk6DZgUAAAAAAMKiNK5cGpcXjceOnxIv68oTVWk8O7/gF6+NPje4tUOlvYCP5IZr/txLsPgtL6/LM3z065JtMcKUxt5zlFIlVzqXx7vquX/75yX//mTppV981zu/jR5FaRynIlR8nQbNCgAAAAAAhEVpXL00DnMF7LPlV/ry5JQePvq1zu7Ypfv6tun9Bw7qsfEJfzuHelnvMZotjYNl8XpnW6uMfVF4428JUe8K4mBBf3lyqurjfv7l6Zqrv8OUxseOn/IfMzu/UPExheKKf77lV0W/KLwpmVMnl8eK0jhORaj4Og2aFQAAAAAACIvSuHpp7F1dqqrsa3x75u6aG7yV5+KlKzXPo5ljrLc0rlQW9/Vtq7ptQ63sP3DQP0b5NhbB8ztz7kLN4wS3sai1P7J3ZXNw+4gwpfG1G9N1t8m4eOlKze1Irk5dL9nr2jtWp5XHgfW3iniJaVARKr5Og2YFAAAAAADCojSuXhrfnrlbtcj0bhKn1MebsR3JDevLk1P+FcPBcrFaCdrsMRotjSuVxf3bP1/31haF4opfeFcr1cOe36PHz/3HDh/9uuJjvOI3kdhcUtSGKY2Lb/9RcqO7wUOH9YvCG/9nZ85d8H9WaT/j4JqvTl0vuXmfd7xOKY8D627Z+1y6xDSoCBVfp0GzAgAAAAAAYVEaVy+NBw8drlh6Plt+5W9j0L/984pl4ZOllyXFYvljojhG2NK4Ulmc3bGr6Zv73ZyeqXk19NWp66FL4+BV3ZX+JoXiil+ilxfoYUvjF4U3JXsw9/Rs1Zcnp9aUydVu/FeeazemO7I8Dqy3Ze9z6RLToCJUfJ0GzQoAAAAAAIRFaVy5oAxeeZrdsaukSDx5+mzNbQy8BK+0PZIbLvlZFMeoVxq3qiz2ZuSVuD09Wyve5C54JXW1fYQr/U0q7X/szaunZ2vJFcLFt+FL40p/22DWe8X1tRvTJWW02uDlcWCdLXufS5eYBhWh4us0aFYAAAAAACCsTi+N+/q26bHxCT/7DxwsuXq0fCuE4tt/+GVp//bP6/6eYLEa9TFqlcbBG8up1XLcyd+PrDgMlt7Vytb1lsZ9fdtK/v3R4+f+VdlXp66veV4jpXHx7ce9iyvtI92//fOmCvXbM3fXlMfrLaLjnMD6WvY+ly4xDSpCxddp0KwAAAAAAEBYnV4a18r+Awf1o8fPS55XKK5UvfK3UoJbXHhXK0dxjOLb2qXxseOn/J9V2yN4vQluS1Fre49gaRzmJnvVjundbK/SFcjFt+FL40ePn+v+7Z+XzN7J3y+5mZ9StW/EVy+F4krJ8aKefRwSmFWriJeYBhWh4us0aFYAAAAAACCsTi+Nu7u79Z69+/ycOXdBj41P6B9/+rVq8agaKBeHj37tP967YjmKYxTf1i6Nb8/c9a/OVatX716duh56v95qcfL3/eP29W1bs1VEMI3saRws0gcPHS5Zh/fv1f4mYUrjR4+f+1cXd3d3r7ny2cnfD3Xzwlrnf3lyquQYicTmSLYCiVu89bXyfS5dYhpUhIqv06BZAQAAAACAsDq9NK51pWyl/PjTr/5zz5y7UPfxwcLXu2o5imMU39bf0/jZ8it98vTZkvLYu/nbesrjn395WlK8ll+FXZ5rN6b931vpRnnBBIv04NW53k3qenq2lmwjEkxwOxHv38q34vCK5URic9Xy+cnSy5LSN8yexNXK4pOnz1bc53kjxFtnK9/n0iWmQUWo+DoNmhUAAAAAAAiL0rix0vjZ8quGth4IblUQ5TGKb+uXxsHfV6k8vnjpSs0rhYMpL4zDFKrB86u3zuAVxcGCWX0qKBtKIrHZP0awkD52/FTN8wjuBV2r6H5ReKPHxidK9kbe6GVxhb9Jq4iXmAYVoeLrNGhWAAAAAAAgLErjxkrj4HOr7bEbjHcVbPkN76I4RtjS2Eul8ri7u1uPjU/ULI+fLL30y9FEYnPoG+q9KLwp2cqi1mODN9YLXsFcfmO5sAnONbgHc6Ub6VWbaaWCuZPL4vLXbivf59IlpkFFqPg6DZoVAAAAAAAIy0nbA26q67zTm0xKn0sIsSiNvS0TVJ0tDIJXz5bvkRvFMRotjb1UK48rXVn7ZOmlX1o3Uhh7OZIb9n9HtW0hCsUVf3uHL77c3fDfo96exsEZ1tsOJFgwX56cKvlZeVmsVq+gfrL0suVFbZwSWH/L3ufSJaZBRaj4Og2aFQAAAAAA2KBiURoHS8jsjl0VrzAtL1vLHxPFMdZbGnupVB7X+v2NFsbFt6UlbLUb5wX3bF7POuqVxi8Kb/yf9/RsrVryFoorJWV+sOQObimiOrQs9hKYQ8ve59IlpkFFqPg6DZoVAAAAAADYoGJRGpcXlT09W/WZcxf0zekZfXN6Zs0VqdWubm32GM2WxsFC1CuPa53fnr37amb46NdrbrBXKK6U7Mnc17dNnzl3QTv5+/ry5FRJSfvFl7vXdYO+eqVx8W3p9hfelhyz8wt+rt2YLrmhXvnWFF5p3Gx9LQsAACAASURBVMllcfl7p5Xvc+kS06AiVHydBs0KAAAAAADzuFn7YT5jLbYybsaakl5nk2JTGr8ovCnZeqFSEonNNcvcZo8RVWkcPJ/gfw6WqGFTqVAtL44r5Ysvd6+7jA1TGhff/qPurL0cyQ1XLK87Zc/iegnMqlXES0yDilDxdRo0KwAAAAAAzOL0J3u9G9K1NBlrUXqtTYqsND6SG9Z79u6ru8dtvdycntHDR7/2i8u+vm16z959emx8ouSGbq04xqPHz/2rfKvtF9xMxsYn6l5dHMzgocNVrxQuFFf05ckp3b/985LC3ru6ej1XGHu5eOmK3rN3n95/4GDdx/78y1P/b+9dye3Nm6uIw0VRGsepCBVfp0GzAgAAAADALE5vMtmO0tjNWI70WpsUWWlMCFlfFKVxnIpQ8XUaNCsAAAAAAMzjpJI7nbQ9UDOpz0bcjP0hn7W1m7XeOynrRLXHuhlrKlAWT0ivLyKUxoQIR1Eax6kIFV+nQbMCAAAAAGDjcXrVpnzGWvxUGCd31nvOnbQ96RXHTsbKteM8W4zSmBDhKErjOBWh4us0aFYAAAAAAGw8wSuHnVTXYAPPcz5ebWx/cDJWfyvPsQ0ojQkRjqI0jlMRKr5Og2YFAAAAAMDG42at16tbTTxo5HlOKrElsKXFrVadX5tQGhMiHEVpHKciVHydBs0KAAAAAICNxelP9vr7E6ftbxt9vpuxHqxebfyuFefXRpTGhAhHURrHqQgVX6dBswIAAAAAYGNxUl2Dfmmc6jrf6PPdrD3nPb8V59dGlMaECEdRGsepCBVfp0GzAgAAAABgY3F6k0m/NM7aDxt9vpu13q9uT/G6FefXRpTGhAhHURrHqQgVX6dBswIAAAAAYOPJZ+3lTzfCs06EfZ6bsSb8wjljOS08xXagNCZEOIrSODZFqGVtDv49jM3qOgAAAAAAQKPcjDXllb9eAeykkjurPd7Z3rU7uC1Fo2VzTFEaEyIc9ansa9n7XLrwNaU0ZlYAAAAAAEC5WfthsAReLY8L+Yy1GIybsd+teVzWfuj0qk3Sa2gSpTEhwlGUxnEqQsXXadCsAAAAAADYmJzeZDKfsZbKC+EQWd4AhbFSlMaEiEe1uDT+4x//8J+qwe0N4pjVdbSaeOFLaQwAAAAAQEw4qa7BfMZarFsWZ6wlJ2Wd2CCFsVKUxoSIR30qRiFPvPClNAYAAAAAIGacVGKLk7YHnNRnI3fS9uSdtD3pprrOf/y36vsdG4zSmBDhKErjOBEvfCmNAQAAAACANEpjQoSjKI3jRLzwpTQGAAAAAADSKI0JEY6iNI4T8cKX0hgAAAAAAEgTv7kVIcQP5IkXvpTGAAAAAADEiJOyTtxJ25Nu1rqVz1iLbsZynFRii/R5tdhbJV+UEUKU+k+FOBAvfCmNAQAAAACIASdj5dyMVchnbV0eN2NNlD/ezVq38llb5zPWosT5Rky6KCOEfArkiRe+lMYAAAAAAAhz0/a3lcpiL3fS9mT5c5zUZyPez53tXbsFTjtKWin2NCZEMorSOE7EC19KYwAAAAAABDkZq9/N2B8CJfHynbQ96aa6zuez9nLV0rhXbfKeV+nnhqE0JkQ4itI4TsQLX0pjAAAAAAAEuVn7ob8NRdr+NvizfMZarFUK+881f4sKSmNChKMojeNEvPClNAYAAAAAQJCbtd7ns7Z2s/Zc+c/qlsYZ+7uPex7b71p+oq1FaUyIcBSlcZyIF76UxgAAAAAACHFSiS3+vsQZK1f+83ql8Z20Pek9v+Un21qUxoQIR1Eax4l44UtpDAAAAACAECdtD/ilcX+yt/zn9a80tqYojQkhUURRGseJeOFLaQwAAAAAgBAnY/X7pfH2rt3lPw9RGj/4uD2FVWj5ybYWpTEhwlGUxnEiXvhSGgMAAAAAIMjf0zhjTZT/rFZp7PSqTW7Gfrf63AdtOdnWoTQmRDiK0jhOxAtfSmMAAAAAAATlM9bSxxvhWe/Lt6ioVRq7GcvxrlKudiWyQSiNCRGOojSOE/HCl9IYAAAAAABBwX2N3Yz9zklZJ7yfVSqNnf5kr5u15/znZK33TiqxReLcI0RpTIhwFKVxnIgXvpTGAAAAAAAIu5O2J70S2CuP3az90M1ar/NZW+cz1qKfwOPyWVsHS2aDURoTIhxFaRwn4oUvpTEAAAAAADHgZq1b5YVwvbgZa0r6vCNCaUyIcBSlcZyIF76UxgAAAAAAxISTSu6sdDXxmmSsRSdj9Uufb4QojQkRjqI0jhPxwpfSGAAAAACAmHH6k71O2h5wU13n76TtyTtpe9JNdZ130vZA+c3yNghKY0KEoyiN40S88KU0BgAAAAAA0iiNCRGOojSOE/HCl9IYAAAAAABBTiq500nbA872rt3S5yKI0jiQJ0sv9Z69+/Sevfv0jz/9Kn4+pDOiKI3jRLzwpTQGAAAAAECI05tMuhn7w8eb2tkfpM9HUKSl8ez8wpqYVL7Ozi/4Bd61G9Nt+70///JUz84v6J9/edrwc58svdTXbkzrsfEJPTY+oWfnF/SLwpvQz39ReKNn5xf02PiEvnjpip6dX9DPll81tZ5Hj5/7f/8nSy/F/65xj6I0jhPxwpfSGAAAAAAAIU7Gynk3t3Mz1gPp8xEUWWm8Z+++YPm1Jv3bP9dXp67rQnFFvKSrlnaXxi8Kb/Tw0a/939nXt62h5+4/cLDqvC9eulLz+T//8lQfyQ1Xff7w0a8bKp+9OPn7a44l/XeNewKzgjzxwpfSGAAAAAAAIU6qa9AvjbPWLenzERRZqaeqlI/l+eLL3U1fydqqtLM0dvL3dU/P1pLZhC2NXxTe6OyOXWuem0hsLvm3sfGJqr87zN+qr29bQyV/obiy5ryien1t5ARmBXnihS+lMQAAAAAAQpxUYktge4p3Tq/aJH1OQiIvjffs3ef/m7dNwdj4RElBmt2xS7yoq5R2lMbPll/pwUOHS4rZ4P+73vPLi9mx8YmSLSBm5xdKjllpHWPjE/7vu3jpir8txovCG3116rru7u72n3/s+KnQa7s8OaWVUjqR2Kz7t39OaRwyitI4TsQLX0pjAAAAAAAE3Unbk5+uNrYfdmhx3NLSOJgnSy9LyszbM3fFy7ryRF0aV9qj2CtTE4nN+sy5C7pQXGmoNL49c7dkC4lKj/nxp19r/j2c/H19eXKq6lXEwTl0d3eHWuuz5Vf+lc4XL10p2a6kkfl0YhSlcZyIF76UxgAAAAAACHOz1i2vOM5nrEUnldgifU5t1rbSuPj205WoSil9JDcsXtaVJ6rSeHZ+wS9Ny3/W07NV7z9wUD96/HzN7MKUxsF9iGvtORwsbdezHUjwauYwz/f2Zva2tKhXGj9Zeum/XmbnF8T/9pJRlMZxIl74UhoDAAAAACDI2d6120nbA27Wngvsb/zezVhTd9L2ZJg4qa5B6XU0qa2l8c+/PK27RcWjx8/12PiEPpIb1tkdu3Rf3za9Z+8+febchdDl4nqP0WxpHCyLq802uJVE+ezqlcYvCm/8q3nrbfERLOgvT041vJbgDfoqnXMwwSubvSvI65XGLwpvSubUyeWxojSOE/HCl9IYAAAAAABB/hXGzSRjLUqvo0ltLY0fPX5e83HXbkyX7KdbKd6WDtV+RzPHWG9pXKkszu7YpZ38/YZmV680Dp7fmXMXaj42eLO7k6fPNvz3DK6n3s3wvKuS9x84WPH51Z53c3qmZMsS73XRaeVxYP2QJ174UhoDAAAAACDE6VWbKI2VUm0ujYP78ZYXmd7N2dTqPronT5/VN6dn9LUb0/rY8VMlN9KrtrVFs8dotDSuVhY3ul+z99x6pXFwfvXOL1jQV9v7uFoKxRW/eP/iy901H3t16rpW6uMezcE9isOUxl6u3Zgu2Q7Dex11SnkcWDfkiRe+lMYAAAAAAAhyU13nw25DwfYU4YuvWqVxsEi8OT3j/3vwJmr92z8v2e/XS/mN9MpvohbFMcKWxpXK4i++3L3um/t5x6hXGnsFbb3z89Ya5m9SKTenZ/znXrx0perjXhTe+EV8+f8I0Ehp7OX2zN015fHgocMb/oZ5gfVCnnjhS2kMAAAAAACktaU0flF4o0+ePltSsAZ/fuz4Kf9ntYrX4JW25VcKR3GMeqVxpbI4iitivWPVK42DV1KH+Z3eY+vtfxxMobjiF8E9PVtr3mzP+5tWetx6SuPg36h8zhu5PA6sE/LEC19KYwAAAAAAIC3y0rivb5seG5/ws2fvvpJtIRKJzWuuAvZ+3r/987q/x7tSuKdna+THqFUaX7x0pWXbJ6gWl8b1jhtMsHwPXg1enuBNDa9OXV/z82ZK4+Dfo7w8Xs8NCuOewPogT7zwpTQGAAAAAADSIi+Na2Xw0GH9ZOllyfMKxZWqV/5WyuChw/7jvRu0RXEMr6RUVcrJYJna6B7BYWfXSGkcpjz1Hht2e4rg9heDhw7XfKxX5la7ijmK0rj49uNV6sG/V9Szj0MC7xHIEy98KY0BAAAAAIC0yEvj7u5uvWfvPj9j4xP66tT1qlsLBG/YVr4vbqUMH/3af7x3zCiOUXxbuzR28vf9m8Op1YL38uRUSenc7Oyi3NP4ReFNQ0W6k79fsid0rW0pgnse//jTrxUf02xp/KLwRo+NT5TMPJHYvO59o+Mcb33teMOjLvHCl9IYAAAAAABIi7w0bvSmaz/+9Kv/3DPnLtR9fLDw9ba5iOIYxbf19zSuVGT29GzVFy9dqVmyhp1dvdL42o1p/7Fj4xM1HxvcPuLY8VN1H+utqa9v25qrwcvzxZe7/bUHtyIJJnjDQe/fwhS+1crik6fP6mfLr9pa5rYritI4TsQLX0pjAAAAAABazEl9NuJmrIKbsQpO2h4I/sxN29/eSduTzcRJdQ0KLS0q4qXxs+VXDW09sP/AwTVXsEZxjOLb+qVxebHpXZmrVq+wHhufWFd5rEKWxsHzq7fO4A3/Ll66UvVxwcK4u7s71M3m1KeSs6EkEpvrzrSTyuIK84Q88cKX0hgAAAAAgBbLZ+3lfNbW+ayt3YzllP1MN52MtSi1toiIl8bB51bbH9dLobhS9YZ3URwjbGns5dnyK33y9NmS8ng9Raf33Hql8YvCG/931XvsydNnK15NHcx6CuPi23/oI7nhki1IKiVY/nr/VmmbjE4ui8v//m1716MW8cKX0hgAAAAAgBajNK4rFqWxt92BUqpmcRm8erZ87+IojtFoaeylWnlcbwuJ8tnVK4KLbz8Wtt7jq+0nHCzGq/09goVxIrG56rHWmzB7Gnd6WVz+92/Tex61iRe+lMYAAAAAALSYk7FybtZ+6GasB872rt3Bn7E9hVIqJqVxsMjN7thVcU/dn3956u+T293dvaZYjOIY6y2NvVQqjxuZXZjSOLjOvr5tFbfDCBbLldbx6PHzksLYyd+PvAitVxoHtxTp1LK4/O/frjc9ahIvfCmNAQAAAACAtFiUxsW3/9CDhw77x+jp2aqPHT+lb07P6Gs3pvXJ02dLrki9OnW9JcdotjQOFqJeeVz+s5vTM2tuGuf9Tm9f5GAKxZWS5xeKKyV7Mvf1bdNnzl3Qt2fu6rHxiZIrrqvtexwsdHt6ttbdamLw0OE151EvYUrjTi+Ly987bXvXoxbxwpfSGAAAAAAASItNaVworuhjx08FC7Q16e7u1rdn7rbsGFGVxl4qXQXsXekcNpWumC4UV/Tw0a9rPq/WjfIaPYdq51ErYbanIKXvnUjf2Vgv8cKX0hgAAAAAAEiLrNTzbo4Wdh/fanHy9/XJ02f1nr37dCKxWff1bdODhw7rsfGJ0FekrvcYT5Ze+lfXRr3Hr5ex8Ym6V/aGvcL35vSMPnn6rH91cXd3t95/4GDdwvvipSuhz2G9Vxp7v2Pw0GHxUjbuUZTGcSJe+FIaAwAAAAAAaVwJSohwFKVxnIgXvpTGAAAAAABAGqUxIcJRlMZxIl74UhoDAAAAACDIzdoP8xlrsZm4GWtCeh1NojQmRDiK0jhOxAtfSmMAAAAAAATls7ZuOhlrUXodTaI0JkQ4itI4TsQLX0pjAAAAAAAERVEau1l7TnodTaI0JkQ4itI4TsQLX0pjAAAAAAAEOankTidtD4SNm7GmvLL4TtqelD7/iFAaEyIcRWkcJ+KFL6UxAAAAAACGuZO2J/2rjFNd56XPJwKUxoQIR1Eax4l44UtpDAAAAACAgdyM5eSztnYz9gcnY/VLn0+TKI0JEY6iNI4T8cKX0hgAAAAAAAM5vcmkm7HfbZBtKiiNCRGOojSOE/HCl9IYAAAAAABDuRnrQT5r63zGWpQ+lyZRGhMiHEVpHCfihS+lMQAAAAAAhnKz9kNviwrpc2kSpTEhwlGUxnEiXvhSGgMAAAAAYCCnN5l0s9b7fNbWbtZ6LX0+TaI0JkQ4itI4TsQLX0pjAAAAAAAM46QSW7yrjD9eaWw9kD6nJlEaEyIcRWkcJ+KFL6UxAAAAAACC3FTX+TtpezJM3Iw1lc9Yi15Z7MVJWSek19EkSmNChKMojeNEvPClNAYAAAAAQFB5Adxo3Kx1S3oNEaA0JkQ4itI4TsQLX0pjAAAAAAAErbssztjv3Iw14fSqTdJriAClMSHCUZTGcSJe+FIaAwAAAAAgyM1YE2G3p7iTtiedlHXCSdsD0ucdMU0IiU0gT7zwpTQGAAAAAADSpEsyQsinQJ544UtpDAAAAAAApGml2J6CEMkoSuM4ES98KY0BAAAAAIA0SmNChKMojeNEvPClNAYAAAAAANIojQkRjqI0jhPxwpfSGAAAAAAASKM0JkQ4itI4TsQLX0pjAAAAAAAEuVn7YT5jLbYqTtoekF5jCJTGhAhHURrHiXjhS2kMAAAAAICgfNbWrYyTsk5IrzEESmNChKMojeNEvPClNAYAAAAAQJCbtV5TGlMaEyIdRWkcJ+KFL6UxAAAAAADCnFRii1ceu1nrvZOyTjhpe6BS3Iw15RXCbtZ+WO1xfnrVJun1hUBpTIhwFKVxnIgXvpTGAAAAAAAIcnrVpnzGWvpUGCd31nvOnbQ9adiVxPVQGhMiHEVpHBt//OMf/lN9+nsYm9V1AAAAAACARgWvHHZSXYMNPM/JZ23tZuwPTn+yt4Wn2A6UxoQIR30q+wAAAAAAACDF6VWb3Kz1/mP5az1o6LmpxBY3Y39YvUL5VqvOsU0ojQkRjqI0BgAAAAAAkOekkjv9/YnT9reNPt/NWA9WC+dCK86vjSiNCRGOojQGAAAAAACQ56TtAb80TnWdb/T5btae857fivNrI0pjQoSjKI0BAAAAAADkOb3JpF8aZ+2HjT7f39oia71uxfm1EaUxIcJRlMYAAAAAAADxkM/ay59uhGedCPs8N2NNBArnuRaeYjtQGpdldn5Bz84v6EJxRfxcSGdEURoDAAAAAADEg5uxprzyd3V/YsdJJXdWe7yTSu4Mbkux3q0tYobSOJDZ+QW/wLt2Y1r8fEhnRFEaAwAAAAAAxIebtR8GS2Dv5nb5jLUYjJu1Xq95XNZ+6PSqTdJraFJkpfHN6Rm9/8BBvWfvPj9HcsN6bHxCj41P6B9/+lW8nKuXdpTGFy9dKZlRtTTy+58tv9JHcsN6z959+tjxU6Gf92Tppb48OaX37N2n+7d/rvv6tuk9e/fpsfEJ/Wz5lfjfo1OiKI0BAAAAAADiw+lNJvMZa6m8EA6RZac3mZQ+/whEVhr39GwNll8V09e3Tc/OL4iXdNXS6tL42fKrujPysmfvvlDHvHZjWnd3d5fMuN5zCsUVfez4qZq/P5HYrC9PTon/TTohgbkDAAAAAAAgLpxU12A+Yy3WLYsz1pKTsk5sgCuMPZGVxipQWnpXF3tXvyYSm0sKybhu/dDq0vjJ0kv/+N3d3TWvNL46db3msR49fq737N1XsZivdx4XL10pOY/9Bw7qsfEJfez4Kd3Xt63keHEu+TdKFKUxAAAAAABAfDmpxBYnbQ84qc9G7qTtyTtpe9JNdZ3/+G/V9zs2WOSlcaUrZF8U3ugz5y6UXMUax+0P2lkah72SuFIuT075RXx3d3dJCRy2NO7p2aovT06tueFfobiij+SG/eN98eVu8b/LRo+iNAYAAAAAAECMtKU09jJ46LD/uLHxCfGyrjxRlsaz8wt68NDhkn+LqjT2rgY+khv2y3fVQGn8ovBGvyi8qfrzQnGlZMuL8mL5ReGNPpIb1j//8lT8b7YRoiiNAQAAAAAAECNtLY1vTs/4jysvVMvzZOmlvj1zV1+7Mb3um+g1eowoSuPZ+YWSbSPKzyfMnOrl5Omza7aNUA2UxmESLPifLL2suo7BQ4cpj5uMojQGAAAAAABAjLS1NH70+Ln/uP7tn6/5eaG4os+cu1BylWsw+w8crHmFbLPHaKY0Li+LK60xqtK41vyjKo2DW1RU2kqkfO9jyuPm/3ZteL8DAAAAAACgEU7KOnEnbU+6WetWPmMtuhnLcVKJLdLn1WJtLY1//uVp1SuNHz1+rr/4cndJEdnd3b2m/O3p2Vr1quFmj7Ge0rhSWdzXt63i800qjbM7dvnzq/TzQnFFX56c0j09WymPI/rbrecNPDLxoPfYv/91+dilhdx6ng8AAAAAAIAKnIyVczNWIZ+1dXncjDVR/ng3a93KZ22dz1iLEucbsbaWxsEbtl28dKViSalW9+p99Pi5/7MnSy9LbqTXv/3zNfvsRnGMRkrjSmVxdscufXN6pupzgqVxX982PTY+4Wd2fqGpslVFWBoHrwgfPvp13cdfuzHNlcdNRDVZGh+//Fd9/PJfda3y+A+brf8d/PuYmtV1rGtOYct1ZsWswmJW4TGr8JhVeMwqvNE/L+w99u8P/59/u/QfU/Ue2+mz4nUVHrMKj1mFx6zC4wIioMXctP1tpbLYy520PVn+HCf12Yj3c2d7126B046SVqo9pfGz5Vf+VamJxOaSQvH2zF3/+SdPn636O44dP+U/7vLkVMnPojhGmNK4Wll8e+Zu3RkFS+Nq6evbFupY1eYfRWk8fPRr/3hO/n7o51Eery+BeTUsWBrXKY/16ft/Nz5RzCnEByvxdTIrZhXXMCtmxazMnNXonxf2fppV3fJYfJ28rphVXMOsmJXBswLQCCdj9bsZ+0OgJF6+k7Yn3VTX+XzWXq5aGveqTd7zKv3cMC0vjX/86Vd9dep6yRYRY+MTJY/xtpRIJDZX3D/Xy7PlVyVFbdTHqFUaP3r8fE1Z/MWXuxsueLM7dum+vm16z959foLH9FKr+K41/2ZL4+AM6t2ssFpuz9wtuerbO1b5DfVI6d9uPW/gSqVxlQ8O4h+G4vKBKsQHK/F1MitmFdcwK2bFrMycVbA0DlEei6+T1xWzimuYFbMyeFYAGuFm7Yf+NhRp+9vgz/IZa7FWKew/1/wtKiIvjetl+OjXa7aFSCQ2a6U+3qSu3u8JlsNRH6NWaRy8QnnP3n16dn4h0uLwydLLkt+hlGrod3jPaaY0flF4o/u3fx6qfA+T8vK40SK8UxL4mzesVmkc/ODQl9or/mEobh+oanywEl8ns2JWcQ2zYlbMysxZVSqNa5TH4uvkdcWs4hpmxawMnhWARrhZ630+a2s3a8+V/6xuaZyxv/u457H9ruUn2lptK433HzhY8eZzwSt/w+yfG9w6wSs1ozhG8W3t0ji4H3K1G91FkZOnz67rSt/gua3n9xaKKyVXPdfamzns8cpvlEdpXP1vV6/4jSLH/sdTfXzm/4h/KIrbB6oKH6zE18msmFVcw6yYFbMyc1a1SuMK5bH4OnldMau4hlkxK4NnBSAsJ5XY4u9LnLHWvIHqlcZ30vak9/yWn2xrRV4aZ3fs0rPzC34q3bAumB9/+tV/bvm2FZUSLHy9EjqKYxTf1i6NXxTe6JOnz/pXNCuldE/PVn15cqruGhtJsADv6dna8PzXWxoPHjrsH+PMuQvrPv9KZXEisVmfPH1Wvyi8aWsZa0pUm0rj4//9kT52c1mfmvu/4h+M1pt2zEltkA+fzIpZMStmZUqYFbNiVszKlDArZmXqrCiPgQY4aXvAL437k73lP69/pbE1RWlcubSsdiO8ann0+Ln/3GPHT9V9/JHcsP94r4SM4hjFt+FuhPds+VXLy+Pg/s+Nzn89pXGwRA9zpXalvCi80RcvXalYFje7zcVGjzev9byBw/yvy8f//PDD7sFvjS6L+fDJrJhVPMKsmBWzYlamhFkxK2bFrExJO2Z1/M8PP/zbn//63fDF/9iynu+dQEdxMla/Xxpv79pd/vMQpfGDj9tTWIWWn2xriZfGheKK/9wjueG6j/f2I+7u7o70GMW34UpjL5XK4+7ubj02PtHUFbXBtTRSAK/nOcW3pYXxem5896LwRo+NT5QU3ZTFjcWb23rewDVL49IPBuIfhqJIS+ZUNi9mxayYFbNiVswqrlnvrMJsT3H88l/1v13+n/+r02fF64pZMStmtRFnFUVZfGL+b1u+uf/7rdP3//769P2/629++H3xxPzfSo576i+/57754fd3qz//8M1ffpssP87qMfTHx/x9+b/d/72/2XMDIufvaZyxJsp/Vqs0dnrVJjdjv1t97oO2nGzriJfGxbefrqxNJDbXvFr32fIrv6Qt/z1RHKOR0jh4vCjL459/ebquEtd7TiOl8dj4hP+8/QcONnSldKWyWK1e6U1Z3FgC82tYxQ8KlT8YiH8Yiu0HqrXzEl8ns2JWcQ2zYlbMysxZ1SuN/+3y//xfo//+MMuseF0xK2bFrDbsrJr2zfzvE+Xn/s387yV92un7vxfKHxMslr+59/fda2bw49/X3GcMEJfPWEsfb4RnvS/foqJWaexmLMe7SrnalcgGiUVpHLz528VLV6o+7tjxU/7jbs/cjfwY6ymNvVTbtqLRWQRvRnd5cqrh+YctjZspjAvFlTVl8fDRr/WTpZcipavpCcyxYSUfVD51oQAAIABJREFUFGp/MBD/MBS7D1TV5yW+TmbFrOIaZsWsmJWZs6pWGpeVxcyK1xWzYlbMauPOqmmn7v/ulJ/7qfu/O8HHVFrfN3O/DXg/Pzn/txNrfv7D74tRnyvQtOC+xm7GfuekrBPezyqVxk5/stfN2nP+c7LWeyeVMH0/mFiUxsGrf5X6eDO78hIzWApnd+xqyTGaKY2D5xEsj71/f1F4oxOJzfrY8VP651+ernnez7881fsPHFz3HL3nhSmNL166UvJ4J3+/5OaF5Skvg58svaQsjjDeLNfzBh6ZeNAb8oOB+Ieh2Hygqj8v8XUyK2YV1zArZsWszJxVeWlcpSxmVorXFbNiVsxqw86qad/88Nt35ef+zQ+/fVfymPt/f1/+mBPzf9vp/fzUD7+NrD0GpTFi6k7anvRKYK88drP2Qzdrvc5nbZ3PWIt+Ao/LZ20dLJkNFovSuPj2H/rm9ExJ6auU0v3bP9f92z9f82+VStcojhFFaezl2fIrfebcBf8/vyi8KTkHpZT+4svdes/efRXPudYWD96ezGGSSGxec6zyeYRJ8BiF4oo+dvwUZXFECcy5YQMnnE0hPxiIfxgS/0AV/oOU+DqZFbOKa5gVs2JWZs7KK43rlMXMSvG6YlbMillt2Fk17dRffs+Vn/upv/yeCz7m9P3fHwR//s0Pv7874bze5P38xPzftnzzw+8fSh9TWjzX4mbtuZKeLmMtuhnLuZO2J52UdcJJ2wMb4OJOxImbtW6VF8L14masKenzjkhkpXG1fYIbyc+/PK1ZaA4f/bruNgrNHCPK0rhSLl66ont6tlY9t+7ubn3x0pW6a2y09I26NCbRJjDnlunq+qf/avRvHsesrqNhDZTrzIpZhcaswmNW4TGr8JhVeLnzD5IhymKlFLPidRUeswqPWYXHrMJrZFZROfWX33Pf/OW3yW/+8ttkeWGslFInnNfJkz/8dv6bv/w2+c387xPlN8pTSqkT83/b6R3j5PzfTjTy+/0LPOt2dvY7N2M5Tiq5s/5RgTqcVHJnpauJ1yRjLToZayPd2VErFU1p/PMvT/Xs/IJ+9Ph508d6svRSz84v6LHxCX3txrSenV9oyzEKxRV/S4ZG9vhtND/+9Ku+OnVdj41P6LHxCX97iEbXFiaVrqh+tvwq9POrHYNEF/XpA0NL3+v/7//3P41PG+bErJgVs2JWzIpZxTbMilkxK2ZlSphV7Ga1IThpe2BNUtaJO2l70s3Y33288th+V7JLQNoekD5vbBBOf7LXSdsDbqrr/J20PXknbU+6qa7zTtoeKL9Z3gYRWWlMCFlfFKVx3D5Qia+TWTGruIZZMStmxaxMCbNiVsyKWZmSNs2qozgZq9/N2g/L71UGoDGUxoQIR1Eax+0Dlfg6mRWzimuYFbNiVszKlDArZsWsmJUpadOsOo53DzNKY6yLk0rudNL2gLO9a7f0uQiiNCZEOIrSOG4fqMTXyayYVVzDrJgVs2JWpoRZMStmxaxMSZtm1XEojbFuTm8y6WbsD6sbZH+QPh9BlMaECEdRGsftA5X4OpkVs4prmBWzYlbMypQwK2bFrJiVKWnTrDoOpTHWzclYuU93VbQeSJ+PIEpjQoSjKI3j9oFKfJ3MilnFNcyKWTErZmVKmBWzYlbMypS0aVYdh9IY6+akugb90jhr3ZI+H0GUxoQIR1Eax+0Dlfg6mRWzimuYFbNiVszKlDArZsWsmJUpadOsOg6lMdbNSSW2BLaneOf0qk3S5ySE0pgQ4ShK47h9oBJfJ7NiVnENs2JWzIpZmRJmxayYFbMyJW2aVcehNEZTvBfQx6uN7YcdWhxTGhMiHEVpHLcPVOLrZFbMKq5hVsyKWTErU8KsmBWzYlampE2z6jiUxmiam7VuecVxPmMtOqnEFulzajNKY0KEoyiN4/aBSnydzIpZxTXMilkxK2ZlSpgVs2JWzMqUtGlWHYfSGE1xtnftdtL2gJu15wL7G793M9bUnbQ9GSZOqmtQeh1NojQmRDiK0jhuH6jE18msmFVcw6yYFbNiVqaEWTErZsWsTEmbZtVxKI3RFP8K42aSsRal19EkSmNChKMojeP2gUp8ncyKWcU1zIpZMStmZUqYFbNiVszKlLRpVh2H0hjr5vSqTZTGSilKY0LEo9pQGv/xj3/4z8DvMTar62gpy/6n/5JeZxRZXUdLMavwmFV4zCo8ZhUeswqPWYXHrMJjVuExq/CYFWqhNEZT3FTX+bDbULA9BSGkVVGfPjAgHsSvNjDoigXxdTIrZhXXMCtmxayYlSlhVsyKWXXErDoOpTHQPEpjQoSjKI3jRvyDo0EfPsXXyayYVVzDrJgVs2JWpoRZMStm1RGz6jiUxkDzKI0JEY6iNI4b8Q+OBn34FF8ns2JWcQ2zYlbMilmZEmbFrJhVR8yq41AaA80T37+HEOIH8SD+wdGgD5/i62RWzCquYVbMilkxK1PCrJgVs+qIWXUcSmOgeUtKvigjhCj1WiEuxD84GvThU3ydzIpZxTXMilkxK2ZlSpgVs2JWHTGrjkNpDDRvSsmXZYQQpRyFuBD/4GjQh0/xdTIrZhXXMCtmxayYlSlhVsyKWXXErDoOpTHQPOmijBDyKYgH8Q+OBn34FF8ns2JWcQ2zYlbMilmZEmbFrJhVR8yq41AaA83TSnEjPEIkoyiN40b8g6NBHz7F18msmFVcw6yYFbNiVqaEWTErZtURs+o4lMZA8yiNCRGOojSOG/EPjgZ9+BRfJ7NiVnENs2JWzIpZmRJmxayYVUfMquNQGgPNozQmRDiK0jhuxD84GvThU3ydzIpZxTXMilkxK2ZlSpgVs2JWHTGrjkNpDDSP0pgQ4ShK47gR/+Bo0IdP8XUyK2YV1zArZsWsmJUpYVbMill1xKw6jnRp7KSSO520PdBUMla/xLkDHkpjQoSjKI1j5Y9//MN/qk9/E2Ozuo6Wsux/+i/pdUaR1XW0FLMKj1mFx6zCY1bhMavwmFV4zCo8ZhUes0It0qWxm7Ve57O2biZuxipInDvg0UpRGhMiGfXpAwNgGvErMwy6ukN8ncyKWcU1zIpZMStmZUqYFbMyeFYdZ0OUxlnrtcS5Ax5KY0KEoyiNYS7xD9kGfVAXXyezYlZxDbNiVsyKWZkSZsWsDJ5Vx4lBaXwrn7EWwyZYMrsZ68GdtD3pZKycxLkDHkpjQoSjKI1hLvEP2QZ9UBdfJ7NiVnENs2JWzIpZmRJmxawMnlXHkS6NG+X0JpP5jLW4eoXxeyeV3Cl9TgClMSHCUZTGMJf4h2yDPqiLr5NZMau4hlkxK2bFrEwJs2JWBs+q45hWGiullNOrNuUz1tLHq43td05vMil9TuhslMaECEdRGsNc4h+yDfqgLr5OZsWs4hpmxayYFbMyJcyKWRk8q45jYmmslFJOKrHFzdgfTDx3bDyUxoQIR1Eaw1ziH7IN+qAuvk5mxaziGmbFrJgVszIlzIpZGTyrjmNqaayUUm7Gclb3N16WPhd0NkpjQoSjKI1hLvEP2QZ9UBdfJ7NiVnENs2JWzIpZmRJmxawMnlXHMbs0tr/zborHFhWQRGlMiHAUpTHMJf4h26AP6uLrZFbMKq5hVsyKWTErU8KsmJXBs+o4JpfG+ay97JfGqcQW6fNB56I0JkQ4itIY5hL/kG3QB3XxdTIrZhXXMCtmxayYlSlhVszK4Fl1HBNLY6c3mQxsTaHdjP1B+pzQ2SiNyzI7v6Bn5xd0obgifi6kM6IojWEu8Q/ZBn1QF18ns2JWcQ2zYlbMilmZEmbFrAyeVceRLo2dlHXiTtqeDBs3az90s9Z7rzBeLY2/kzh3wENpHMjs/IJf4F27MS1+PqQzoiiNYS7xD9kGfVAXXyezYlZxDbNiVsyKWZkSZsWsDJ5Vx5Eujd2s9TpYAK8jy+xnDGmRlcY3p2f0nr371mT/gYN6bHxC35yeES/n6qVdpfGjx8/1ydNn9Z69+7RSSicSm/Wevfv0seOn9KPHz+s+f2x8ouKsy3N5cirU+RSKK/rq1HV9JDesv/hyd8k5nTx9Vj9bfiX+t9nIUZTGMJf4h2yDPqiLr5NZMau4hlkxK2bFrEwJs2JWBs+q45hcGrtZe47CGHEQWWnc07M1WH5VTE/PVn175q54SVctrS6NXxTe6MFDh2vOKJHYXLPsfbb8qu6cvezZu6/uOTn5+7qvb1vN4xw7fkr8b7ORE5g1YBTL/qf/UiH/+yjOWV1HSzGr8JhVeMwqPGYVHrMKj1mFx6zCY1bhMSvUIl4ap+1vG9meIp+xFj/d/M46IXHOQDmtVDSlsXesvr5temx8Qo+NT+gjuWG9Z+8+nUhsLvkvxbBXwLY7rS6NL1664h+/u7tbDx46rMfGJ/TJ02fXFLez8wsVj/Fk6WXJMWpdaXx16nrN87k9c9c/lndl8dj4hJ6dX9BO/r4eG5/Q2R279MnTZ8X/Nhs5gb87YBrxKzMMurpDfJ3MilnFNcyKWTErZmVKmBWzMnhWHUe6NG6U06s2BW+C56Q+G5E+JyDy0rjS1a2F4oo+c+5CSUEZxy0P2lEa9/Rs1Venrq+50V6huKKP5Ib935/dsaviMYKlcZgriavl0ePnuru72/97OPn74vPv1Hh/T4n/AgCaJP4h26AP6uLrZFbMKq5hVsyKWTErU8KsmJXBs+o4ppXGHjdrP1y9Cd4Hpz/Z+/+z9zYhUmR7v+6CffocIbHJrggSL5RQlJPSrEhFmkZQUBGkHChOChv0iijCVoRqC4TyHEGhBwVC2zgo2kFB0JlSQmHT9C0v/WoP/JiUOClxkuC9lCCI18FBmj1w1Kw7sCIqMis/Ir/iv5breeAH71sZGRnryY7euX577RXS1wNuk0lpHGXyxMn4uAuXLouXdfXpZ2m8sLikJ44crfnby+rbDWVxMtXVD3GRq5RqeGy/SuNkQf3bH3919N5om41mq6FJZ4m+B4H7H6BXxH9kW/RDXXycuMKVqcEVrnCFK1uCK1xZ7Mo5bC2Nw5F8vhz476O9jaWvB9wm09I4uR3CwUOHW57v0ZMX+s78XX3z1pxeWFxqWbb26xz9KI0XFpfiB9x14za55/HT5VcbXu9Hafx85XW8ZUh9sZ0m9ddAedxbIpdZ3/wAfUD8R7ZFP9TFx4krXJkaXOEKV7iyJbjClcWunMPW0lgppcol75d4tfGI2iR9PeAumZbGybJxbPuODa9XVz/oU6fPJUu0muzdt7/ttha9nKOX0ri+LFZK6W+/29Oxx2Rp3Og6+1EaX7sxG5+j2wcTjm3fscEr5XF3SXgEsA3xH9kW/VAXHyeucGVqcIUrXOHKluAKVxa7co4voTSulHzNFhUgSaal8W9//BUfd+z4ZM1rj5682FBEjm3fseEBcYVCoen+u72eo5vSuFFZXNq5u+sytrRzd3yNjV7vR2mc3CakmxXcUW7emtvglvK48yT8AdiG+I9si36oi48TV7gyNbjCFa5wZUtwhSuLXTmHraXx2gPxqnFpzEpjECTT0vjK1evxcdduzNa8FpWlSil96vQ5/bL6Nn7t+crrmgfpDQ9vbVh29nqOTkrjfpfFq+8+l97RuSZPnGx4TLI0Hh3dpqemZ+KElfuptuGIPA0Pb43d3J6brznXnfm7+tGTF6mu+8783Rr30T8HDx4+Ey9kbUjCG4BtiP/ItuiHuvg4cYUrU4MrXOEKV7YEV7iy2JVz2Fgah2P5kehBeGtZkb4mcJvMSuOny6/ifXRzuc01hWRyr+Oz5y82/YzkthP1pXM/zpGmNG5UFu/dt7/p6udOklwB3Gy1brI0bpbh4a369tx808+JVgePbd9R85mNcuXq9dTX36g8njhylPK4TRK+AGxD/Ee2RT/UxceJK1yZGlzhCle4siW4wpXFrpxDujT+ddy/UQm8xx1kOVEW6897GnuzEtcOEDHw0nhhcUlfuXpdFwqFpkVkVDTmcptb7lmcfIBbaefuvp+jVWn84OGzhmVxv7ZiSH52/dYd9Tl46LDeu29/Teq35VAtyvNo/Ml8+90ePXnipJ48cVJ/+92eVOdpNZZ6VxNHjjZ8sB+hNAarEf+RbdEPdfFx4gpXpgZXuMIVrmwJrnBlsSvnkC6NyyXvTX0J3EnKJf9PiesGSNL30rhdTp0+17TEPHjocNvPiQrNXG5z38/RqjROrlDu9769z1dex6t/C4VC24f9tTpPcgsO1WTFcvRaLrdZX7h0ueHnhZX7NSvDu7mm+vK40/LZlSS+LwDbEP+RbdEPdfFx4gpXpgZXuMIVrmwJrnBlsSvnsLU0Lpe8N+Xi0A/sZQwmkElpPDy8tek2Bc9XXsfHNdvHN5nkdgpRkdmPc0QlZ/T3+tJ4anomfm10dJu+eWuup4fIRamufqhZ2dvLnsiNrrVRiZ4cR6vznD1/MT62fiuPdnlZfaunpmdqVphTGjdO4l4BsA3xH9kW/VAXHyeucGVqcIUrXOHKluAKVxa7cg7p0jgsemd+HfdvpEm5OPRDOO4fCLcP7ZG4VoBm9L00Lu3crRcWl+K0e99vf/wVv3dqeqbt8cnC97c//urbOVbftS6NG5Wgw8Nb9bUbsz2VxxNHjsbn62T/4FZJlujRw+6SiVY1N3otmaSPtIVvI0+53GZ99vzFmgcTkvVEnrK66QH6xVdf/es/KsX/wsT0rI1joHj+1/9Ij7MfWRvHQMFVenCVHlylB1fpwVV6cJUeXKUHV9AK6dIY4EtAK5XNg/Ca5dGTF/F7G21dUZ9jxyfj46MSsh/nqC9Jmz0Ir1EpWigU9NT0TMelaLK87vcq3OT11b+W3P847XfTbgV3q7K42+02XIla/8EAAF8u4qtYLFoJIz5OXOHK1OAKV7jClS3BlXGunIPSGKB3xEvj6uqH+L3tHgC3+m59P+JCodDXc6y+S1caJ0vSs+cv1jxUrlAoNN0juD7JwjjNlhrdOh3bvmPD68nVza2uNenjwqXLTT1QFveWyFtmdz0ASCA+IbFoUiM+TlzhytTgCle4wpUtwZVxrpyD0higd8RL49V366tic7nNLbd6eLr8qunn9OMcnZTGUZ6vvN5QHrcrTQdZGK++q92uY+LI0Q2vX7l6PX79x9mfmp4nedztufma1yiL+5fIX2Z3PQBIID4hsWhSIz5OXOHK1OAKV7jClS3BlXGunMOk0jjcPrQnLH7zfRh4x8ORfF76egDSYkRpnHzgWqt9fU+dPhcfV//AuH6co5vSOEqj8rjRnsHJwvjgocN9eZheMvUP1ms0jgcPn8Wvf/vdnqbnGR7eGo8jWQRXVz9QFvcxkcesbnoAEEF8QmLRpEZ8nLjClanBFa5whStbgivjXDmHCaVxGHhj5cCrVkq+TqZc8v8MR9SmRu8pB/7P5cCbDQNvLOvrBajHiNL4+crruKBUa1shJAvIl9W3G8rWQZyjl9I4eR3J8jj52tT0THz+0dFtOqzcr3loYH0ePHxW8/6X1bc6l9usT50+t+G16Pr37tvfcpVxlGSxPHHkaE15/Xzldc3r127M1rw3Wq1NWdyfRJ4zu+sBQALxCYlFkxrxceIKV6YGV7jCFa5sCa6Mc+Uc0qVxWMxtKQf+p/rCuF1xXCn5K2vHrEhcN0ASI0rj1Xd/6zvzd2tWryr1eT/e0dFtNX/79rs9+unyq4Gcox+lcZTnK6837AOcfABd2tQX3/Wvj45ua3je0s7dLR/M93T51QZXpZ27N7g6dnxyw2ro6uoHfeXqdcriPiXhGwC+XMQnJBZNasTHiStcmRpc4QpXuLIluDLOlXNIl8blwP85LogD/1Ml8B5XAu9xsjgOi96Z+veFgXc8fj3wjgtcOkBM30rjaGVtt6Xx6ru/9aMnL2pWuNbnwqXLbbdz6OUc/SyNG6W0c3dPpfHqu7/1tRuzG4rdZIaHt7bcpziZBw+f1axMTqZQKAzEAdmYhHcA+HIRn5BYNKkRHyeucGVqcIUrXOHKluDKOFfOYUBp/D4qjJNbTYRj+ZFyyXtTKfm6EnjLrd/r/Z7dFQNspG+l8YOHz/TC4lLTVcCd5GX1rV5YXNJXrl7XN2/NNdyKYVDniLaG6Pdew6vvPq8+brUdRbvtKZJ5uvxKLywu6anpGT01PaMXFpf0oycvuv7uwsp9PTU9o+/M3+3Ld0jSR1EaA7iA+ITEokmN+DhxhStTgytc4QpXtgRXxrlyDsnSOBzJ5xPbUNzb8HpyNXExt6X+9WiVcrnkfczmigEa07fSmBDSXRSlMYALiE9ILJrUiI8TV7gyNbjCFa5wZUtwZZwr5xAtjYu5Leul8DffNzqmXPI+Vkq+Dsf9AxteKw79EL9/JJ8f+AUDNIHSmBDhKEpjABcQn5BYNKkRHyeucGVqcIUrXOHKluDKOFfOYcz2FMWhHxq/7lWb7VscFr0zcWk8lh8Z+MUCNIHSmBDhKEpjABcQn5BYNKkRHyeucGVqcIUrXOHKluDKOFfOIV8ae7+32pc4eiheo4fhlQNvhpXGYAKUxoQIR1EaA7iA+ITEokmN+DhxhStTgytc4QpXtgRXxrlyDunSOBz3D8QPwts+tKf+9ValcSXwltnTGEyA0pgQ4ShKY4AvHs//+h+1fq9bm7VxDBRcpQdX6cFVenCVHlylB1fpwVV6cAWtkC6Nk9dQLnkfw8AbS77WqDQOi7kt5cALo1XGlcB7nPlFAyTQSlEaEyIZtf6DAQC+XMRXsVi0EkZ8nLjClanBFa5whStbgivjXDmHdGkcFocmfh33b5QD/9PaiuP3lcB7HCV6EF458KrJ/z+ZRvsdA2QJpTEhwlGUxgAuID4hsWhSIz5OXOHK1OAKV7jClS3BlXGunEO6NC6XvDf1JXAnKZf8exLXDZCE0pgQ4ShKYwAXEJ+QWDSpER8nrnBlanCFK1zhypbgyjhXziFeGgdetauyOPDfh8Vvvpe4ZoB6KI0JEY6iNAZwAfEJiUWTGvFx4gpXpgZXuMIVrmwJroxz5RzSpXFYzO8Kx/0DqVPM75K4ToBWUBoTIhxFaQzgAuITEosmNeLjxBWuTA2ucIUrXNkSXBnnyjmkS2OALwFKY0KEoyiNAVxAfEJi0aRGfJy4wpWpwRWucIUrW4Ir41w5B6UxQO9QGhMiHEVpDOAC4hMSiyY14uPEFa5MDa5whStc2RJcGefKOaRL47CY3xWO5PMSnw3QLyiNCRGOojQGcAHxCYlFkxrxceIKV6YGV7jCFa5sCa6Mc+Uc0qVxueS9+fxQu6GJTt8bjuTz5cALy4FXHcS1AaSF0pgQ4ShKYwAXEJ+QWDSpER8nrnBlanCFK1zhypbgyjhXziFeGgf++0rJ15WSr8uBF6ZddRwWvTPlkvexUvJ1ueS9GfR1ArSC0pgQ4ShKYwAXEJ+QWDSpER8nrnBlanCFK1zhypbgyjhXziFdGlcC73FUGn8ujv33YfGb75sdHwbe2Ib3UBqDMJoQYkwA4MtFfEJi0aRGfJy4wpWpwRWucIUrW4Ir41w5h3RpHI6oTb+O+zfKgf+ptgj2/wyLuS3J48qBN7PhuC63tgDoJ9IlGSFkPQDwheL5X/+j5P8d03PWxjFQcJUeXKUHV+nBVXpwlR5cpQdX6cEVtEK6NI4Ix/Ij5ZL/Z90K4o9h0TsTbh/aUw68avK1te0sZnmIHpiAVortKQiRjFr/wQAAXy7iq1gsWgkjPk5c4crU4ApXuMKVLcGVca6cw5TSOCIMvOPJfY4bJvCWw2J+l/S1AkRQGhMiHEVpDOAC4hMSiyY14uPEFa5MDa5whStc2RJcGefKOUwrjZWKt6KY3bhlxeeVx9LXB1APpTEhwlGUxgAuID4hsWhSIz5OXOHK1OAKV7jClS3BlXGunMPI0riY21Iu+fc2bEdR8u+xHQWYCKUxIcJRlMYALiA+IbFoUiM+TlzhytTgCle4wpUtwZVxrpzDtNK4HHgz5ZL3sdnWFKw2BhOhNCZEOIrSGMAFxCckFk1qxMeJK1yZGlzhCle4siW4Ms6Vc5hSGofbh/ZUSv5Kw9XFRe/Mhn2OA+9xGHhjktcMEEFpTIhwFKUxgAuIT0gsmtSIjxNXuDI1uMIVrnBlS3BlnCvnkC6Nw2JuSznwwg1lceBVw+LQRHzcSD5ff1w58D+VA282HFGbJK4dIILSmBDhKEpjABcQn5BYNKkRHyeucGVqcIUrXOHKluDKOFfOIV0aVwJvuZMiONw+tKcceNX6VcdZXzdAEkpjQoSjKI0BXEB8QmLRpEZ8nLjClanBFa5whStbgivjXDmHdGlcLnlvEuXvcpotJ8IRtakceDPlwP+0ts/xmyyuFaAZlMaECEdRGgO4gPiExKJJjfg4cYUrU4MrXOEKV7YEV8a5cg4TSuNuH24XBt5YJfAelwOvOoBLA0gNpTEhwlGUxgAuID4hsWhSIz5OXOHK1OAKV7jClS3BlXGunCOL0jgs5raE4/6BcCw/suG1wDsejuTzPZ2/wXkBsoTSmBDhKEpjABcQn5BYNKkRHyeucGVqcIUrXOHKluDKOFfOkUVpXC55v0QPtxvUZwBIQmlMiHAUpTGAC4hPSCya1IiPE1e4MjW4whWucGVLcGWcK+fIpDQOvJC9h+FLhtKYEOEoSmOALx7P//oftX6vW5u1cQwUXKUHV+nBVXpwlR5cpQdX6cFVenAFraA0BugdrRSlMSGSUes/GADgy0V8FYtFK2HEx4krXJkaXOEKV7iyJbgyzpVzUBoD9A6lMSHCUZTGAC4gPiGxaFIjPk5c4crU4ApXuMKVLcGVca6cg9IYoHcojRN5uvxK7923X+/dt1//9sdf4tdD3IiiNAZwAfEJiUWTGvFx4gpXpgZXuMIVrmwJroxz5RyUxgC909fS+Lc//tILi0txHj15IV7IdZKFxaW4wLt5ay6zz3305EXXvhYWl/TtuXl989acXlhc6unzf5z9Sd+Zv6sXFpd0dfUI+JNAAAAgAElEQVSD+PfhShSlMYALiE9ILJrUiI8TV7gyNbjCFa5wZUtwZZwr56A0BuidvpXGe/ftb7m5+8FDhzMtYrtJ1qVxdfWDvnDpcvyZo6PbUr3v6fIrPXnipC4UCg1dnz1/Ub+svm17nrByX5d27m54jlxusz57/qJ+vvJa/Hv50pPwDgBfLuITEosmNeLjxBWuTA2ucIUrXNkSXBnnyjkojQF6p2+lsWpQPDbK3n37UxWaEsmyNF5YXNJj23fUuElTGi8sLulcbnNbz6Oj21quFr52Y3bD8Xv37d9QIpd27mbV8YCT8A0AXy7iExKLJjXi48QVrkwNrnCFK1zZElwZ58o5KI0BeqfvpfHeffvjv0XbHly4dFkPD2+Nj/n2uz3iRV2jZFEav6y+1ZMnTsafk/SSpjSemp6J33fl6vV47+XnK6/1j7M/1aw+Pnv+YsNzPHryIi6eR0e36QcPn9W8/nT5lf72uz3xeaamZ8S/my85keeM730AyBbxCYlFkxrxceIKV6YGV7jCFa5sCa6Mc+UclMYAvTPQ0ri+iEwWmnfm74qXdfXpd2lcX8auvvu7ZiXvhUuX9cvq245K47ByX1+5er3p6t/kGAqFQsNjkquMb8/NNzzm+crr+JiDhw5veN22/apNTuQ543sfALJFfEJi0aRGfJy4wpWpwRWucIUrW4Ir41w5B6UxQO9kVhrXl5WnTp8TL+vq06/SeGFxKd7juf61aBuIZOkafWbaPY3bJVlMN9qTOLnS+enyq6bnGR3dppVSemz7jpq/P11+pZVSeuLI0YbFOOks0XeR9c0PAJkiPiGxaFIjPk5c4crU4ApXuMKVLcGVca6cg9IYoHcyLY2TpWxp5+6Gxzxfea2v3ZjVkydO6tLO3Xp0dJs+eOiwnpqeibdiaJduz9FraZwsi5u5bVTSRsf2qzRuVwqfOn0ufn1hcanhOaqrH+ItLCaOHK15Lbk6Onqd8rj7JFwCwJeL+ITEokmN+DhxhStTgytc4QpXtgRXxrlyDkpjgN7JtDSOVqgq1Xhf4zvzd2u2sGiUK1evt7yOXs7RbWncqCweHd3WdOuHZu76VRofPHQ4PmejbSxu3pqrKXwbnePK1evxMY22Evlx9qea/Zijc1Eed56EQwD4chGfkFg0qREfJ65wZWpwhStc4cqW4Mo4V85BaQzQO5mWxnfm78bH1T+kLXrAm1JK53Kb9bHjk/rajdl4xXCyoGz2gLdez9FpadyoLB7bvqPjVcrRe/tRGldXP8SleasHDiYfdDdx5Kh+WX0bv3bh0uX4tUb7GSc/68fZn+JtLJLnozzu/PvP4oYHABm++upf/1Et/stMW7I2joHi+V//Iz3OfmRtHAMFV+nBVXpwlR5cpQdX6cFVenAFraA0BugdrVR2pfHEkaPxccli9fnK63grhLHtOxoWjk+XX9WUk/XH9OMcaUvjRmVxaefurh/uF52jH6Xx7bn5+HytVmW/rL6t2ft4eHirvnZjdkOZ3OyBe/W5eWuO8rjLJJwBAIBi1RCucIUrXOHKzOAKVxa7cg5KY4DeyaQ0rq5+qFm9Wtq5u6aMPHv+Yvxaq+I1uVL52PHJmtf6cY52pXG/y+J6d72WxtXVD/Fq6uHhrQ0fgtfqe0mm2wcB3rw1V1NGK8rj1N9/Bvc7AIANiE/eLJoAio8TV7gyNbjCFa5wZUsycuUclMYAvdP30nh0dJuemp6Jc/DQ4ZoVqLnc5g0FYlR0jm3f0fZzkqVov8/RqjS+dmO2pgjdu2+/Div3++6ul/Mki/O0pe+Vq9cb7gE9tn1HT2X4nfm7G8rjbovoLz0JRwAAwAQQV7jCFa5wZWhwhSuLXTkHpTFA7/S9NG6Vg4cO60dPXtS8r7r6oenK30ZJbnERrVbuxzlW37UujU+dPhe/Nnni5EBKw15K4+S2FK22CIny6MkLPbZ9R423sHK/5iF6SjXfPzpNqqsfas7Xb29fShK+AQCACSCucIUrXOHK0OAKVxa7co4sSuOw6J2pBN7jcuD/PKjPAJCk76VxoVDQe/ftj3Ph0mU9NT2jf/vjr6blpeqgoJw8cTI+Plqx3I9zrL5rXRrfmb8b75ms1greH2d/Sr3nbxp33ZbGYeV+fG2jo9tqHmrXzHm0urhQKOiFxaUN50vz4MFmqa5+0NduzNacI5fb3PM2Hl9qIkeZ3fUAAGYjPnmzaAIoPk5c4crU4ApXuMKVLcnIlXNkURoDfOn0vTROs8o1md/++Ct+74VLl9senyx8o1XL/TjH6rv2exo/X3mtz56/WFMeRw+Q66U8js7VTWn84OGzmgK4fiV3o0T7Mudym5uW+U+XX9WUvmn2JG5WFp89f7Ht/souJ3KV2V0PAGA24pM3iyaA4uPEFa5MDa5whStc2ZKMXDkHpTFA74iXxs9XXne0fUFyu4N+nmP1XfvSOPl5jcrjK1evt13l28pdp6VxfWGcpthNrso+dfpcy2OT+zhfuXq96XEvq2/11PRMzd7IlMWdf/9Z3fQAAIYjPnmzaAIoPk5c4crU4ApXuMKVLcnIlXNIl8ZhMb8rHPcPDDTF/C6JsYE7iJfGyfeWdu5ue2z0UL36B9714xxpS+MojcrjQqGgp6ZnOiqPo/d2Uho/XX4Vl7S53ObUD+VL7n384+xPLY9N+mhUMFMW9yeRu+xuewAAoxGfvFk0ARQfJ65wZWpwhStc4cqWZOTKOaRL43LJe1Mp+XqQKQf+J4mxgTsYURp/+92eVNsg3Jm/Gx9Xv89uP87RaWkcpVl53Gp1biN3aUvjp8uv4uK7k8K4fvzttvJIFszXbszWvFZfFqu1Vd5Pl1+Jl7C2JeEQAACYAOIKV7jCFa4MDa5wZbEr53ChNK6UfP7ZgYFiRGmcLDJLO3c3XKVaX5TWH9OPc3RbGkdpVB534i5NadxLYbz67vPq4Ojzhoe3Ni15q6sfaor45N7Hye1AFGVxz0m4BAAAJoC4whWucIUrQ4MrXFnsyjmkS+Noe4pyyb8XrwwueW8qgfe4UcqB/z7NcbXv8UKJsYE7GFEar75bfzibWiszL1y6rG/Pzevbc/MbVrU2WyHb6zl6LY2jJMvj+teia0km+sxoa4soV65e3/CAvfox7t23v2UmT5zccI6z5y9u+MyFxaU4N2/NxcW0arA1RVQaUxb3J5Hn7G57AACjEZ+8WTQBFB8nrnBlanCFK1zhypZk5Mo5pEtjpZQKi96Z9SLY/zMcyeebH5vbUin5K2ul8ccw8MayvFaARhhTGr+svtXHjk/WrGCtTy63uWWZ2+s5+lUaJ6+n/m/JMjZN6kvZTt/f6Byr7/5u6ynKseOTG0rn1Xd/s2dxH5PwDQAATABxhStc4QpXhgZXuLLYlXNIl8Zh4I2VA/9TpeTrSuA9DkfUprbvGcnn4+I48Kpp3gMwSPpWGh87Pqn37tvfdp/cdrk9N68nT5yMV9SOjm7Te/ft11PTM/rRkxcDPcejJy/iFbrJ7Rj6mQuXLrddHRxl4sjRDYXt1PRM6vc3O0eUBw+fxd9btAo7csUq4uyiKI0BAGI8/+t/VIf/5aiJWRvHQMFVenCVHlylB1fpwVV6cJUeXEErpEvjaFuKcuB/Cou5LWnfF47lR6KyWXKVNIBSa/+Ski7NCHE5av0HAwAAKFYN4QpXuMIVrswMrnBlsSvnkCyNwxG1KSp+yyX/XqfvjwvnkvdmENcHkBZKY0KEoyiNAQCSiE/eLJoAio8TV7gyNbjCFa5wZUsycuUcoqVx4I1Fexl38/nRtVdKvu5klTJAv6E0JkQ4itIYACCJ+OTNogmg+DhxhStTgytc4QpXtiQjV84hu9I4n48fgBd4v3f6/milMaUxSENpTIhwFKUxAEAS8cmbRRNA8XHiClemBle4whWubElGrpxDek/j9Qfa+Z/CsfxI2veFI/l8ueR9ZHsKMAFKY0KEoyiNAQCSiE/eLJoAio8TV7gyNbjCFa5wZUsycuUc0qVxueT9Eq82LnlvwmJ+V7v3hGP5kahsXlulHGZxrQDNoDQmRDiK0hgAIIn45M2iCaD4OHGFK1ODK1zhCle2JCNXziFdGodj+ZFy4L+PCuBKydeVwHscFr0z4bh/oCbFb74vl/x70cPz1remGJqQuHaACEpjQoSjKI0BAJKIT94smgCKjxNXuDI1uMIVrnBlSzJy5RzSpbFSSoXbh/bUF8FpUx73/y113QARlMaECEdRGgMAJBGfvFk0ARQfJ65wZWpwhStc4cqWZOTKOUwojZVaK45L/p+py+LAf18uDv0gec0AEZTGhAhHURoDACQRn7xZNAEUHyeucGVqcIUrXOHKlmTkyjlMKY0jwmJ+VznwZiuB97gSeI+jFcjlwH9fCbzH5ZL/Z1j85nvp6wRIQmlMiHAUpTEAQBLxyZtFE0DxceIKV6YGV7jCFa5sSUaunMO00hjARiiNCRGOojQGAEgiPnmzaAIoPk5c4crU4ApXuMKVLcnIlXNQGgP0DqUxIcJRlMYAADGe//U/av3fi9ZmbRwDBVfpwVV6cJUeXKUHV+nBVXpwBa2gNAboHa0UpTEhklHrPxgAAECxaghXuMIVrnBlZnCFK4tdOQelMUDvUBoTIhxFaQwAkER88mbRBFB8nLjClanBFa5whStbkpEr55AujcNiflc47h8YaIr5XRJjA3egNCZEOIrSGAAgifjkzaIJoPg4cYUrU4MrXOEKV7YkI1fOIV0al0vem0rJ14NMOfA/SYwN3IHSmBDhKEpjAIAk4pM3iyaA4uPEFa5MDa5whStc2ZKMXDmHC6VxpeTzzw4MFPFN3wkhcQAAQDEBxBWucIUrXJkZXOHKYlfOYUBp/Esl8B4PMuXACyXGBu7wTskXZYQQpf6jAABAKcUEEFe4whWucGVmcIUri105h3RpDPAlIF2UEULWAwAAigkgrnCFK1zhyszgClcWu3IOSmOA3tFKsacxIZJRlMYAAEnEJ28WTQDFx4krXJkaXOEKV7iyJRm5cg5KY4DeoTQmRDiK0hgAIIn45M2iCaD4OHGFK1ODK1zhCle2JCNXzkFpDNA7lMaECEdRGgMAJBGfvFk0ARQfJ65wZWpwhStc4cqWZOTKOUwtjcNx/0BYHJr4ddy/US4O/RCO+wfCwBuTvi6ARlAaEyIcRWkMAJBEfPJm0QRQfJy4wpWpwRWucIUrW5KRK+cwqTQOi/ld5cD7vVLydbOUA//Tr+P+jXAkn5e+XoAISmNChKMojQEAkohP3iyaAIqPE1e4MjW4whWucGVLMnLlHKaUxuWS90ursrhBefw+LH7zveQ1A0RQGhMiHEVpDAAQ4/lf/6PW/71obdbGMVBwlR5cpQdX6cFVenCVHlylB1fQChNK43LgzTQshwNvuRJ4jyuB97gceNVGq47D7UN7pK4bIEIrRWlMiGTU+g8GAABQrBrCFa5whStcmRlc4cpiV84hXRp/3pLC/5Qoih+3WkEcFr0zyQK5XPLehCNqU5bXDFAPpTEhwlGUxgAAScQnbxZNAMXHiStcmRpc4QpXuLIlGblyDunSuFzy760XwP6fad4TjqhNlcB7HL1PemsNAEpjQoSjKI0BAJKIT94smgCKjxNXuDI1uMIVrnBlSzJy5RzSpXGl5K/EexR3sGI4HMnny4H/vpOyGWBQUBoTIhxFaQwAkER88mbRBFB8nLjClanBFa5whStbkpEr55AujaOtKcqB93vn7/V+jwrnQVwbQFoojQkRjqI0BgBIIj55s2gCKD5OXOHK1OAKV7jClS3JyJVzSJbG4Vh+JN6aojj0Q6fvLxeHfojeHxZzWwZxjQBpoDQmRDiK0hgAIIn45M2iCaD4OHGFK1ODK1zhCle2JCNXziFaGo+oTXFpHHiznb4/unZKY5CG0pgQ4ShKYwCAJOKTN4smgOLjxBWuTA2ucIUrXNmSjFw5h/z2FF61232Jo4fhlUvex0FcG0BaKI0JEY6iNAYASCI+ebNoAig+TlzhytTgCle4wpUtyciVc4iXxiX/3tq+xJ/CYn5X2veFY/mRaD/kSuAtD/IaAdpBaUyIcBSlMQBAEvHJm0UTQPFx4gpXpgZXuMIVrmxJRq6cQ7o0DovemXiLipL3JhzLj7R9z1h+pFzy3vSytQVAP6E0TuTp8iu9d99+vXfffv3bH3+JXw9xI4rSGAAgifjkzaIJoPg4cYUrU4MrXOEKV7YkI1fOIV0aK6VUOfB+Xy+A/U/lwAvDcf9AGHhj0TFhMb8rLA5NlAMvjFcYR0XzSD4vde0ASvW5NF5YXNoQm8rXhcWluMC7eWsus8999OSFDiv39dT0jL5y9bpeWFzSL6tvuzpP5P3p8itxnyRdFKUxAEAS8cmbRRNA8XHiClemBle4whWubElGrpzDhNI4HMnny4H/PiqCO0k47h+Qum6AiL6Vxnv37U+WXxsytn2H/nH2J11d/SBe0jVL1qXxj7M/6eHhrU2ddXINYeX+hvdL+yTpkvjOAACcx/O//ke1+D1hS9bGMVBwlR5cpQdX6cFVenCVHlylB1fQChNKY6WiLSc+72+cMithcWhC8poBIrRS/SkXVcp/IX773R79fOW1eFHXKFmVxi+rb/W33+3Z4Gbvvv01f588cTLV+aqrH3Rp5+4N55P2SdIl8Z0BAIBi1RCucIUrXOHKzOAKVxa7cg5TSuOIsJjfVS759yqBt1xfFJdL3ptK4D0Oi94Z6esESNL30njvvv3x36LtEqamZ2pW1JZ27hYv6holq9J44sjR+HMOHjqsFxaXNhxzZ/5uw783yrUbs1oppXO5zXps+w5KY8uiKI0BAJKIT94smgCKjxNXuDI1uMIVrnBlSzJy5Rymlcb1hCP5fHJvYwATGWhpnMzT5Vd6dHRbfNyd+bviZV19+l0aP3j4bMPfooJXKaWPHZ/sebuO5yuvdS63WSul9JWr12u2CenkuohcFKUxAEAS8cmbRRNA8XHiClemBle4whWubElGrpzD9NIYwAYyK41X320sTKXLuvr0qzReWFyKy9v616KVwMPDW/uyv/PkiZNaKaVHR7fp6uqHtqXx0+VX8feUdiUzGWwUpTEAQBLxyZtFE0DxceIKV6YGV7jCFa5sSUaunIPSGKB3Mi2NHzx81naLikdPXuip6Rl97PikLu3crUdHt+m9+/brC5cupy45uz1Hr6Vxsixu5Db5sLqp6Zmenf/2x18bVm63K41fVt/WXB/lsXwS3wcAADABxBWucIUrXBkaXOHKYlfOYWJpHI6oTeG4fyAsDk38Ou7fiMKD78BUMi2NHz150fK4m7fmdKFQqCk163Ph0uWWK3R7OUe3pXGjsri0c7cOK/drjrtw6XL8+tPlVz07jx5+d/DQ4fhvabanuD03X7NVSPR9UB7LJPE9AAAAE0Bc4QpXuMKVocEVrix25RwmlcbhuH+gEniP6x+A1+CBeL+ExdwW6esFiMi0NL4zfzc+7uz5izWvTU3PxK8VCgV99vxFfXtuXt+8NadPnT5X8yC9Zltb9HqOTkvjZmVxs/2aDx46rJX6/MC6Xn3/OPtTfK7kHsVpSuMoN2/NxcVz8vujPM42Cf8AAMAEEFe4whWucGVocIUri105hwmlcTiSz6cpi+uK448mFN0ASmVcGicLzdtz8/Hfkw9zG9u+Qz968mLDe+sfpFf/MLd+nCNtadyoLP72uz1tH+4XffbY9h366fIrfer0uXiP4yilnbv1seOT+mX1bdPzvKy+jQvw+vK9k9I4yp35uxvK44kjR3lgXkZJeAcAACaAuMIVrnCFK0ODK1xZ7Mo5TCiNy4EXNimHVyqB97gSeI/LgVdtWB4H3ozUdQNEZFIav6y+1WfPX6wpWJOvnzp9Ln6tVfGaXKlcv1K4H+doVxo3Kos7WZkbFb3tts9Q6vOD8n7746+G54lcDg9v3VAud1MaJ93Uj4/yePBJ+AYAACaAuMIVrnCFK0ODK1xZ7Mo5pEvjsOidqV1B7N9rtXdxWByaKJf8P9dLY/9TGHhjWV4zQD19L41HR7fpqemZOHv37a/ZFiKX27xhFXD0+tj2HW0/J1qtOzy8te/naFUaX7l6veuyuEE5qAuFgj51+pwOK/f10+VX+unyKx1W7utvv9tTs+q4/hzJhwn+OPvThtd7KY2THurL424eDEg6/ucCAACYAOIKV7jCFa4MDa5wZbEr55AujcuB93uiAP459ftK3i/JonmQ1wjQjr6Xxq0yceTohgfAVVc/NF352ygTR47Gx0cPs+vHOaKyNPp7fUmaXMk8eeJkT46Gh7fq5yuvmx6X3Cqi/mF6UZnbqFBOvt7r9/qy+rbGU7djJun/uRj43Q4AYAfikzeLJoDi48QVrkwNrnCFK1zZkoxcOYd8aey/X9uj+E04ojZ19t7PW1aUA686qOsDSEPfS+NCoaD37tsfZ2p6Rv84+1PTLQ4ePXkRv7d+f95GmTxxMj4+Omc/zrH6rnVpHFbu12wrMTq6TV+7MVtTOrdL9P7R0W0tj7s9Nx9/ztT0TMO/N9u6otfS+GX1rZ6anqkZay63ue1+zaT7RJ6zuukBAAxHfPJm0QRQfJy4wpWpwRWucIUrW5KRK+eQLI3DYm5LL6uFk3shd1o4A/STvpfGrR6E1yi//fFX/N4Lly63PT5Z+EbbXPTjHKvv2u9p3KhQHR7eqq9cvd7ywXVRom0xcrnNqZ0kV/hGW1cMD2+t2QIkmeSD/qK/pSl8m5XFZ89fbLkqmvSeyHdmdz0AgMF4/tf/qBT/6yXTszaOgYKr9OAqPbhKD67Sg6v04Co9uIJWiJbGY/mRxAPtZjt9f3TtlZKvw7H8yAAuESAVWinZ0vj5yuv4vWm2QDh46LCuv+5+nGP1XfvSOEpUsOZym+PjC4WCnpqeaVkeJ/crbnV9yX2LT50+16hc7CitSmrKYvkkvisAAFCsGsIVrnCFK1yZGVzhymJXzmHA9hSf1krj3zt+b8m/x0pjMAHx0jj53mb79Eaprn5o+sC7fpwjbWkc5fnKa332/MWa8rhV4Xr2/MX4uFYP0bszfzc+7tqN2fjvx45P1mz90SjJ8jf6W6N9nimLzUnkP8P7HgDAZMQnbxZNAMXHiStcmRpc4QpXuLIlGblyDunSuBJ4j9cegve+k+I3HFGbov2QKyV/ZZDXCNAOI0rj5ArcZnsfr76rLVPr9y7uxzk6LY2jNCuPk/sRr777W9+8NddwBXF9kg+ga1UuN0qaPY0pi81K9D1kdtcDAJiN+OTNogmg+DhxhStTgytc4QpXtiQjV84hXRqXi0M/rG9R4f+c+n2BNxO/rzj0wyCvEaAdRpTGySK3tHO3frr8asMxDx4+i/frLRQKGwrOfpyj29I4SqPyOPl6dfVDXNYWCoWGD7NLjmPiyNGOr6FdaZzcyoOy2IxE30eWNz4AgMGIT94smgCKjxNXuDI1uMIVrnBlSzJy5RzSpfHnFcNeNd5mopjf1fY9xfyueFuLkveGrSlAGiNK49V3tatrh4e36lOnz+nbc/P65q05ffb8xZqVsT/O/jSQc/RaGkdJlsf1r125er2mtL1w6bK+M39X37w1p0+dPlfzWqsV082SpjSmLDYr0feV6Z0PAGAu4pM3iyaA4uPEFa5MDa5whStc2ZKMXDmHdGmslFJh4I2VS94v5cD7PSwOTbQ9vpjb8uu4f+PXcf8GD8ADEzCmNK6ufqgpTRulUCjoO/N3B3aOfpXGUZo9FG/yxMmW1zi2fUdXhfHqu3TbUxCzkvjuAQCACSCucIUrXOHK0OAKVxa7cg4TSmMA2+lbuRg9pK1+H99OE1bu67PnL+q9+/brXG6zHh3dpieOHNVT0zOpV8Z2e46ny6/ih8c12jqin1lYXNITR47GezGXdu7WkydO6ms3ZnV19UPX571y9breu29/V1tbEJkoSmMAgCTikzeLJoDi48QVrkwNrnCFK1zZkoxcOQelMUDvsCKVEOEoSmMAgCTikzeLJoDi48QVrkwNrnCFK1zZkoxcOQelMUDvUBoTIhxFaQwAkER88mbRBFB8nLjClanBFa5whStbkpEr55AujcNiflc47h8YaFI8XA+gFyiNCRGOojQGAEgiPnmzaAIoPk5c4crU4ApXuMKVLcnIlXNIl8blkvemUvL1IFMO/E8SYwN3oDQmRDiK0hgAIIn45M2iCaD4OHGFK1ODK1zhCle2JCNXzuFCaVwp+fyzAwOF0pgQ4ShKYwCAGM//+h+1/u9Fa7M2joGCq/TgKj24Sg+u0oOr9OAqPbiCVhhQGv9SCbzHLVPyV8ol703b45qkHHihxNjAHbRSlMaESEat/2AAAADFqiFc4QpXuMKVmcEVrix25RzSpXE7wu1De8qB/75c8j6yNzGYCqUxIcJRlMYAAEnEJ28WTQDFx4krXJkaXOEKV7iyJRm5cg6TS+NyceiHcuB/Su5NHBaHJqSvC6AeSmNChKMojQEAkohP3iyaAIqPE1e4MjW4whWucGVLMnLlHCaWxuFIPl8OvN+bPdQuLHpnpK8RIAmlMSHCUZTGAABJxCdvFk0AxceJK1yZGlzhCle4siUZuXIO00rjsJjfVQ68ak1ZHHjLYdE7U7PquDj0g/S1AkRQGhMiHEVpDACQRHzyZtEEUHycuMKVqcEVrnCFK1uSkSvnMKk0Lo/7/04Ww2sri38OR9QmpZQKi0MTtdtVeLPS1wygFKUxIeJRlMYAAEnEJ28WTQDFx4krXJkaXOEKV7iyJRm5cg4TSuNwRG0qB164cRuKb77fcOzG4jiUuGaAJJTGhAhHURoDACQRn7xZNAEUHyeucGVqcIUrXOHKlmTkyjmkS+Mw8Mbqt6MoB141DLyxpu9hxTEYBqUxIcJRlMYAAEnEJ28WTQDFx4krXJkaXOEKV7iyJRm5cg7p0nhDYVzy74Uj+Xy79yWL43LJe5PFtQI0g9KYEN0qUIsAACAASURBVOEoSmMAgCTikzeLJoDi48QVrkwNrnCFK1zZkoxcOYd4aVzy3kTbUXT6cLuoOKY0BmkojQkRjqI0BgBIIj55s2gCKD5OXOHK1OAKV7jClS3JyJVzmFAalwP/fbh9aE837w/H/QNsTwHSUBoTIhxFaQwAkER88mbRBFB8nLjClanBFa5whStbkpEr55AujcNiflea7SgATEYTQowJAAAoJoC4whWucIUrM4MrXFnsyjmkS2OALwHpkowQsh4AAOfx/K//UfL/Pu45a+MYKLhKD67Sg6v04Co9uEoPrtKDK2iFCaVxWPTOlEv+n2n2NA6LuS3dbmUBMCi0UmxPQYhk1PoPBgAAUKwawhWucIUrXJkZXOHKYlfOIV0ah4F3vFLy9drD8H5uelxxaKJc8j5Gx34+3gvDEbUpy+sFaASlMSHCUZTGAABJxCdvFk0AxceJK1yZGlzhCle4siUZuXIO6dK4XPLvrRXGn8JibkujY8KidyZZFtck8JazvmaAeiiNCRGOojQGAEgiPnmzaAIoPk5c4crU4ApXuMKVLcnIlXNIlsbhiNoUrR4uB17Y8Jix/Eg58D/Fq4tL3sdK4D0uB/776G9h0TuT8aUD1EBpTIhwFKUxAEAS8cmbRRNA8XHiClemBle4whWubElGrpxDtDQey4/EZfC4/+9Gx5QD/+f1wtj/M9qOIhzJ58uBV117bSXbKweohdKYEOEoSmMAgCTikzeLJoDi48QVrkwNrnCFK1zZkoxcOYdoaRx4Y+urhYcmNrxesxJ54/YV5XH/39Fr2V01wEYojQkRjqI0BgBIIj55s2gCKD5OXOHK1OAKV7jClS3JyJVzyG5Pkc+32mIiuZdxo4fkheP+gfj9Y/mRLK4ZoBGUxoQIR1EaAwAkEZ+8WTQBFB8nrnBlanCFK1zhypZk5Mo55B+E13xP40rJX1kvlfO76l8Pi0MTlMZgApTGhAhHURoDACQRn7xZNAEUHyeucGVqcIUrXOHKlmTkyjnES+PA+319+4lvvlcq3q84jArhSuA9bvLemfi9a3sdA0hAaUyIcBSlMQBAEvHJm0UTQPFx4gpXpgZXuMIVrmxJRq6cIyqNG23/kAVhMb8rLoebpNF+x0olViI3KZUBsoLSmBDhKEpjAIAk4pM3iyaA4uPEFa5MDa5whStc2ZKMXDlHcouHcsl7Uy55v4RF70w47h8IA28si2soB95ss8K4WZkdBt7xdqUyQFZQGhMiHEVpDACQRHzyZtEEUHycuMKVqcEVrnCFK1uSkSsnKReHfoj2Fk6bcsm/19drGPf/XQm85URZ/L4ceDPNjg9H8vlw3D/QaK9jgKyhNCZEOIrSGAAg5quv/vUftf7vRWuzNo6B4vlf/yM9zn5kbRwDBVfpwVV6cJUeXKUHV+nBFbQjHMuPlEveL52Vxt4b6esGMAWtFKUxIZJR6z8YAAAAOkF8dZRFK6zEx4krXJkaXOEKV064co6wmNuSXGVcLnkfK4H3uBx44a/j/o1yceiHcNw/sCEdPHguLOa2hOP+gXAsPzLAoQCIQWlMiHAUpTEAAHSH+ETXosmy+DhxhStTgytc4coJV85RDryZ6GFy4fahPQP5jLVVzOXAqw7i/ADSUBrXZWFxSS8sLunq6gfxayFuRFEaAwBAd4hPdC2aLIuPE1e4MjW4whWunHDlHL+O+zcqJV//Ou7fGNRnlAMvZEsL+JKhNE5kYXEpLvBu3poTvx7iRhSlMQAAdIf4RNeiybL4OHGFK1ODK1zhyglXzkFpDNA7fSuNb8/N64OHDuu9+/bHOXZ8Uk9Nz+ip6Rn92x9/iZdz7ZJVafzoyQs9NT2j9+7br0dHt+nh4a167779+tTpc/rRkxepzvF0+ZW+dmNW7923X49t36FHR7fpvfv266npGf185bW4S5I+itIYAAC6Q3yia9FkWXycuMKVqcEVrnDlhCvnoDQG6J2+lcbDw1vbPhV0dHSbXlhcEi/pmmXQpfHL6ls9eeJkS0e53GZ95er1pueorn7Qp06fa3uOazdmxX2SdEl8dwAAAJ0gPtG1aLIsPk5c4crU4ApXuHLClXNQGgP0Tt9K4+hco6Pb4tXFx45P6r379utcbnNNqWnq1g+DLo2vXL0en7+0c7eemp7Rd+bv6qnpGf3td3tqHIWV+23PUSgU9MFDh/XU9Iw+dfqcHh3dVnMOkwt6sp7EdwYAANAJ4hNdiybL4uPEFa5MDa5whSsnXDkHpTFA7/S9NN67b/+G115W3+oLly7XrIQ1cQuFQZfG127M6tLO3frO/N2GrydXITfyuPruc2k8PLxVX7sxu+FhfdXVD/rY8cn4HN9+t0fcKWkfRWkMAADdIT7RtWiyLD5OXOHK1OAKV7hywpVzUBoD9E4mpXGUiSNH4+OmpmfEy7r69LM0Xlhc0hNHjnb0nqfLr+LPHx7e2vCYl9W3+mX1bdNzVFc/6EKhEJ+nvlh+WX2rjx2f1A8ePhP3TT5HURoDAEB3iE90LZosi48TV7gyNbjCFa6ccOUclMYAvZNpaXx7bj4+rl2h+nT5lb4zf1ffvDXX9UP0Oj1HP0rjhcUlvXffft2t2+h9udzmrr+LZDn/dPnVBifJ74DyWD6K0hgAALpDfKJr0WRZfJy4wpWpwRWucOWEK+egNAbonUxL40dPXsTHjW3fseH16uoHfeHS5ZqVsskcPHS45SrbXs/RS2lcXxY3G2OrJAvd0s7dXX8XyS0qGm0DUr/3MeWxbBLfBQAAQCeIT3QtmiyLjxNXuDI1uMIVrpxw5RyUxgC9k2lp/ODhs6YrjR89ebHhYXCFQmFD+Ts8vLXpquFez9FNadyoLB4d3dbVSuWp6Zn4HNduzHb9XZR27o7H3uj16uoHfe3GrB4e3kp5bEAS30FHfD/z+8ip//lfK6euLh3v7vYHAADLEZ/oWjRZFh8nrnBlanCFK1w54co5KI0BeifT0vjK1evxcVeuXm9YdCql9LHjk/rRkxfxa0+XX9U8SG9s+44Ne/X24xydlMaNyuLSzt369tx8x+6iEjc6z+jotobjS5Pkau7JEyfbHn/z1hwrj4WTcN8R38/8PnL62n/p09f+S7crj/+12ft/kt+xrVkbR8d0UrDjqrP/MsJ1XwCSeP7X/ygD7p9eszaOgYKr9OAqPbhKD67Sg6v04ApaQWkM0DtaqWxK4+crr+OVrbnc5ppS8s783fj9Z89fbPoZp06fi4+rX4nbj3OkKY2blcV35u+mdvXj7E96anpGX7h0We/dt79mxe/BQ4c37EPcSSZPnIzPFVbup34f5bFcEs47IlkapyiP9fn7/9v6dOOp3lWKQlR8nBa5ct4XgDDiq6MsWmElPk5c4crU4ApXuHLClXNQGgP0zsBL49/++Ev/OPtTzRYRU9MzNcdEW0rkcpsb7sEb5fnK65qitt/naFUaP3ryYkNZ/O13ezoqi6O02m/59tx816uMk9ff7kGDzXJn/m7Niu3oXL0U2aR1Eq47olFp3KLsEy/lTClCKdj76sp5XwDCiE90LZosi48TV7gyNbjCFa6ccOUclMYAvdP30rhdJk+c3FCK5nKb49K03ecky+F+n6NVaZxcobx33369sLjUtatopfHZ8xf13n37Gz5Ar9m+zc3ysvpWj23fkao4T5P68rjV6m3SWxLffUe0Ko0blH3ipZxpRSgFe19cOe8LQBjxia5Fk2XxceIKV6YGV7jClROunIPSGKB3MiuNDx463LAITa78TbMHb3L7hagY7cc5Vt+1Lo2T+yF3+6C7Vnm+8rqmmC4UCqmL3+rqh5riuZt9levPV/+gPErjwaVd8duPHD0/p0/P/7/ixZyJRSgFe0+ulOu+AIQRn+haNFkWHyeucGVqcIUrXDnhyjkojQF6p++lcWnnbr2wuBSn3VYLv/3xV/ze+m0rGiVZ+EYldD/OsfqudWn8svpWnz1/MV7RrJTSw8Nb9bUbs11vJ9EoZ89f7KgAX333t544cjR+z4VLl7v+7EZlcS63WZ89f1G/rL4VL1e/1GRRGp+c+b/0qdsr+ty9/0+8nOslWbhSX0gJmoWrU//zv1a+FF+KH+tgJ+ITXYsmy+LjxBWuTA2ucIUrJ1w5B6UxQO/0vTRu9iC8Znn05EX83lOnz7U9/tjxyfj4qMjsxzlW36V7EN7zldcDLY9fVt/G5x3bvqPt8ckCPG3J3Ogzr1y93rAs7nWbC9I+kfNOb940K0JP/68/P/2f/+u/ft7s/R/ipZwtRaj6QkrQLFyd/l9/fvpSfHVzDwIYgPhE16LJsvg4cYUrU4MrXOHKCVfOQWkM0DvipXF19UP83mPHJ9seH+1HXCgU+nqO1XfpSuMojcrjQqGgp6Znel6VOzq6reH11SdZGHfz4LuX1bd6anqm5sF8lMXZJ3Lf6c3bsjReK4snr/zfW6J7XbqUkyz2OinYcZXe1do/X+JjlfQFIIz4RNeiybL4OHGFK1ODK1zhyglXzpFFaRwWvTOVwHtcDvyfB/UZAJKIl8ar7/6OS8tcbnPL1brPV17HJW395/TjHJ2Uxsnz9bM8ThbgrVxOTc/Exx08dLijVc6NymK1tkqbsjj7JL6DjmhY7m0si+N7XbqUM7YIpWDvxZXzvgCEEZ/oWjRZFh8nrnBlanCFK1w54co5siiNAb50jCiNk/v4Xrl6velxyQfF3Zm/2/dzdFMaR2m2bUXymEYPAqzPlavX4/c3e/hcL4VxdfXDhrJ48sRJ/XT5lXh56moS30VH1JR7zcvi+F6XLuWMK0Ip2PvhynlfAMKIT3QtmiyLjxNXuDI1uMIVrpxw5RyUxgC9Y0RpnFz9q9Tnh9nVF6HJUri0c/dAztFLaZy8jmR5HP092qu4tHO3/nH2pw0reqPVv9H7hoe3Nlz1myyVR0e36bByv+bBg/WpL4OfLr+iLDYs0ffR6c37/czvIynK4vhely7ljClCKdj76cp5XwDCiE90LZosi48TV7gyNbjCFa6ccOUc2WxPkdsSjvsHBpZiftegrh0gDUaUxqvv/ta35+ZrSl+lPj8Ibmz7jg1/e/Dw2UDO0Y/SOMrzldf6wqXL8f9fXf2w4doKhYLeu29/vIdxMmHlfsPz1o8lTZLlc3X1gz51+hxlsUFJfFcdceBMuClFWRzf69KlnHgRSsE+CFfO+wIQRnyia9FkWXycuMKVqcEVrnDlhCvnyOZBeP7PlZKvBxUesAfS9K00brZPcCd58PBZy1J08sTJtlsx9HKOfpbGzc4/ceRoy4L32PHJloVur6UxMS+J72pgDA19/U+n/9yYmLVxdEwnBTuuOvovI5z3BSCJ538Z99/aOAYKrtKDq/TgKj24Sg+u0oMraEU2pbEXUhrDl4xWqj+l8YOHz/TC4pJ+9ORFz+d6uvxKLywu6anpGX3z1pxeWFzK5BzV1Q/xtg6d7BPcaV5W3+rbc/N6anqm5vrSPDjv+crrlttR1KfZqmxiTtT6D4aB3uvS/w26Rf8tvPg4LXKFLwBZxO8di+4/8XHiClemBle4wpUTrpwjk+0pAu94JfAet0q55H1MlsBNjwv89/FxgTfL9hRgAn0rjQkh3UVRGpv2g0p8nBa5wheALOL3jkX3n/g4cYUrU4MrXOHKCVfOYcKD8MLAO55YObwSjuTzTY8t5rZUSv7KWrn8kcIYTIDSmBDhKEpj035QiY/TIlf4ApBF/N6x6P4THyeucGVqcIUrXDnhyjmkS+NwLD9SDvxPaQrj+D0j+Xw58Kprq42r4YjalMW1AjSD0pgQ4ShKY9N+UImP0yJX+AKQRfzesej+Ex8nrnBlanCFK1w54co5pEvjcsm/97n89T+FxVzqZ8aExfyueJuK4tAPg7xGgHZQGhMiHEVpbNoPKvFxWuQKXwCyiN87Ft1/4uPEFa5MDa5whSsnXDmHeGm8tsq4XPLvdfzekv/nWuH8fhDXBpAWSmNChKMojU37QSU+Totc4QtAFvF7x6L7T3ycuMKVqcEVrnDlhCvnkCyNw7H8SLRauJvPj669UvJ1J6uUAfoNpTEhwlGUxqb9oBIfp0Wu8AUgi/i9Y9H9Jz5OXOHK1OAKV7hywpVziJbGI2pTvMVEyf+z0/dHW1tQGoM0lMaECEdlUBp/9dW//pP4HGuzNo6B8t//x3/7R3qc/cjaOAYOvgBEEZ/oWjRZFh8nrnBlanCFK1w54co5pLenqJT8lXhP47H8SNr3hSP5fLnkffxcOHsfB3iJAG3RSlEaEyIZtV5cgRmI/3C07Men+Fgt8wXQT8TvHYvuP/Fx4gpXpgZXuMKVE66cQ7o0Lgf+z/Fq48B/Hxbzu9q9Z21bi5X193m/Z3GtAM2gNCZEOIrS2DTEfzha9uNTfKyW+QLoJ+L3jkX3n/g4cYUrU4MrXOHKCVfOIV0ah8XclnLgv48K4ErJ15XAexwWvTPhuH+gJsVvvi+X/HvRw/PirSkC77jEtQNEUBoTIhxFaWwa4j8cLfvxKT5Wy3wB9BPxe8ei+098nLjClanBFa5w5YQr55AujZVSKtw+tKe+CE4byesGiKA0JkQ4itLYNMR/OFr241N8rJb5Augn4veORfef+DhxhStTgytc4coJV85hQmms1FpxXPL/TFsWlwP/fbk49IPkNQNEUBoTIhxFaWwa4j8cLfvxKT5Wy3wB9A3P//qLeBDl2jgGCq7Sg6v04Co9uEoPrtKDK2iFKaVxRFjM7yoH3mwl8B5XAu9xtAK5HPjvK4H3uFzy/wyL3hnp6wRIopWiNCZEMmr9BwOYgXiBaVkJKj5Wy3wB9BPxe8ei+098nLjClanBFa5w5YQr5zCtNAawEUpjQoSjKI2N4quv/vUfZcCKg16zNo6BwwoPAFHEJ7oWTZbFx4krXJkaXOEKV064cg5KY4DeoTQmRDhqvbgCsBHxH9r8WAeHEb93LLr/xMeJK1yZGlzhCldOuHIOSmOA3hFf3UUIiQNgI+I/tPmxDg4jfu9YdP+JjxNXuDI1uMIVrpxw5RymlsZh4I2F4/6B8rj/77D4zffhuH8gHFGbpK8LoBHLSr4oI4Qo9UYB2In4D21+rIPDiN87Ft1/4uPEFa5MDa5whSsnXDmHSaVxOJYfKQfe75WSr5ulXPI+/jru3whH8nnp6wWImFXyZRkhRKlQAdiJ+A9tfqyDw4jfOxbdf+LjxBWuTA2ucIUrJ1w5hymlcTnwZsuB/6lVYVxTHgf++/K4/2/JawaIkC7KCCHrAbAR8R/a/FgHhxG/dyy6/8THiStcmRpc4QpXTrhyDhNK4/K4/++G5XDgLZcD/31cEq/938mExaEJqesGiNBK8SA8QiSjKI3BbsR/aPNjHRxG/N6x6P4THyeucGVqcIUrXDnhyjmkS+PPW1KsrzAuB97vYTG/K3q9HHjh2t9DpZQKi7kt5cD/ObniOCzmtkhcO0AEpTEhwlGUxmA34j+0+bEODiN+71h0/4mPE1e4MjW4whWunHDlHNKlcVQKrxXDs81ej0rjiLDonUnsc/xLdlcMsBFKY0KEoyiNwWL++//4b/8o+a1des7aOABsQ3yia9FkWXycuMKVqcEVrnDlhCvnkC6NKyV/Za0UroYjalP9681KY6WUKpf8e2vF8Uo2VwvQGEpjQoSj1osrABsR/6HNj3VwGPF7x6L7T3ycuMKVqcEVrnDlhCvnkC6No60pmq0WblUaR6uNy4H/afBXCtAcSmNChKMojcFuxH9o82MdXMXzv/4iVvqvjWOg4Co9uEoPrtKDq/TgKj24glZIlsZh4I3FW0wUh35odEzL0njcPxA/EG8sPzLwCwZoglaK0pgQyaj1HwwANiJe+FIag8OI3zsW3X/i48QVrkwNrnCFKydcOYdoaTyWH4lL36J3ptExLbenGPf/Hb+/wdYWAFlBaUyIcBSlMdiN+A9tfqyDw4jfOxbdf+LjxBWuTA2ucIUrJ1w5h2hpPJLP97LSuBx4v7OnMZgApTEhwlGUxmA34j+0+bEODiN+71h0/4mPE1e4MjW4whWunHDlHOJ7Gpe8j2v7Ev/c8PUmpXG5OPRDXDiX/HvZXC1AYyiNCRGOojQGuxH/oc2PdXAY8XvHovtPfJy4wpWpwRWucOWEK+eQL439P1utFo5L45L/ZzjuH1gri1fiwjjwP4WBN5b1dQMkoTQmRDiK0hjsRvyHNj/WwWHE7x2L7j/xceIKV6YGV7jClROunEO8NE6sGG5U/kalcbM02wsZIEsojQkRjqI0Bov56qt//UcN+InSWWRtHAC2IT7RtWiyLD5OXOHK1OAKV7hywpVzSJfGYTG3pRz4n9a2oJipf71ZaVwueW/C4jffS1wzQD2UxoQIR60XVwAAAJ0gPtG1aLIsPk5c4crU4ApXuHLClXNIl8ZKfS6Ow3H/QDiSz294bdw/UC55b8qB/74SeI/LJe8XVheDaVAaEyIcRWkMAADdIT7RtWiyLD5OXOHK1OAKV7hywpVzmFAaA9gOpTEhwlGUxgAA0B3iE12LJsvi48QVrkwNrnCFKydcOQelMUDvUBrXZWFxSS8sLunq6gfxayFuRFEaAwBAd4hPdC2aLIuPE1e4MjW4whWunHDlHJTGAL1DaZzIwuJSXODdvDUnfj3EjShKYwAA6A7xia5Fk2XxceIKV6YGV7jClROunIPSGKB3+lYa356b13v37d+Qg4cO66npGX17bl68nGsXidL40ZMXeuLIUb133349eeJkx++vrn7QP87+pI8dn9TffrdHK6V0LrdZ7923X589f1E/X3kt7pW0jqI0BgCA7hCf6Fo0WRYfJ65wZWpwhStcOeHKOaRL47CY3xWO+wd6SuCNSVw7QETfSuPh4a3J8qthhoe36jvzd8VLumbJujS+cvW6zuU2x585Orqto/eHlft6dHRbS+enTp8T90paJ/F9AQAApMbzv/5HtfntZUPWxjFQcJUeXKUHV+nBVXpwlR5cQSukS+NyyXtTKfm6l5QDrypx7QARWqn+lMbRuUZHt+mp6Rk9NT2jjx2f1Hv37a8pRpVS+tqNWfGirlGyKo0fPHwWrwpOppPS+M783fh90criqekZvbC4pMPKfT01PaNLO3frs+cvinslrZP4ZwAAAKATxFdHWbTCSnycuMKVqcEVrnDlhCvn+CJK45L3RuLaASL6Xhrv3bd/w2vV1Q/6wqXLNSWnidsmZFEaT03PxJ9RKBT0j7M/dVwaP3ryQhcKhdhlWLkv7o50H0VpDAAA3SE+0bVosiw+TlzhytTgCle4csKVcxhQGv9SCbzHqVLyV2rLYv/er+P+jTDwjktcO0BEJqVxlMkTJ+PjLly6LF7W1aefpfHC4pKeOHJ0w9+jbTwmT5yMi3PVYWl87Phk/J7f/viro+t6WX2rJ44c1QuLS+K+yd8137/EvwAAAMBqxCe6Fk2WxceJK1yZGlzhCldOuHIO6dK4U8Kid6Zc8j6urTD+GBaHJqSvCSDT0ji5pcLBQ4dbnu/Rkxf6zvxdffPWnF5YXNLV1Q8dX1On5+hHabywuKT37tuvm7k9e/7ihqJXdVAaP195HW/30aiUbpeny69qvivKY/koSmMAAOgO8YmuRZNl8XHiClemBle4wpUTrpzDttJYKaXCsfxItK1FOfA/heP+AelrArfJtDROFpZj23dseL26+kGfOn1uw16/yXO329ail3P0UhrXl8VKKf3td3s6cpemNL52YzY+vtuHCo5t37HBCeWxXBLfBQAAQCeIT3QtmiyLjxNXuDI1uMIVrpxw5Rw2lsZKKRUG3lg58D+tbVWxIn094DaZlsa//fFXfNyx45M1rz168mJDmTm2fYceHd1W87dCodB0D99ez9FNadyoLC7t3N1RoRu9L01pnNzio5vV11Fu3prb4IXyWCaJ7wAAAKATxCe6Fk2WxceJK1yZGlzhCldOuHIOW0tjpZSqBN5ytL9xOJYfkb4ecJdMS+MrV6/Hx127MVvzWmnn7vi1U6fP6ZfVt/Frz1de1zxIb3h4a8PCtNdzdFIa96MsrneXpjSOxjg8vDUe1+25eT01PRPnzvxd/ejJi1SffWf+bo236Dt88PCZeJnqShLuAQAAOkF8omvRZFl8nLjClanBFa5w5YQr57C6NE48GI/SGCTJrDR+uvwq3os3l9tcU2om9zo+e/5i089IbjtRXzr34xxpSuNGZfHeffubrn7uxF2a0jhaHTy2fUfNquNGuXL1eupraFQeTxw5SnmcQRLOAQAAOkF8omvRZFl8nLjClanBFa5w5YQr57C1NA5H8vmoMC6XvI/hiNokfU3gLgMvjRcWl/SVq9d1oVBoWmZGZWUut7nlnsXJh8CVdu7u+zlalcYPHj5rWBb3YzuH6HxpSuPo2pP59rs9evLEST154qT+9rs9Na+1KtAbpVEpPnHkqH66/Eq8XP1Sk3ANAADQCeITXYsmy+LjxBWuTA2ucIUrJ1w5RxalcVjMbQnH/QP9XA0cjqhN5XH/37+O+zd4EB5I0/fSuF1OnT7XtAg9eOhw28+JStFcbnPfz9GqNE6uUO733r/RedOUxtGxudxmfeHS5YYFeVi5X7Oqu93DAxulvjzutHwmnX//2dzyAADwBSE+0bVosiw+TlzhytTgCle4csKVc2RRGpdL3i+Vkq/LgVcd1GcASJJJaTw8vLXpVgfPV17Hx02eONn2c5JbMkRlaD/OERWl0d/rS+Op6ZmacvfmrbmeHkTXyF0npXG7Y8+evxgfW78NR7u8rL7VU9MzNavDKY0Hl8S9AgAA0AniE12LJsvi48QVrkwNrnCFKydcOUcmpXHghWvbSLwZ1GcASNL30ri0c7deWFyK0+59v/3xV/zeqemZtscnC9/f/virb+dYfde6NG5UpA4Pb9XXbsz2XB5H5+tkT+PoQXjNkhxL2sK30Rhzuc367PmLNQ8VJP1N5Dq72x4AAL4ENLiEcQAAHuhJREFUPP/rf1TK/6WXyVkbx0DBVXpwlR5cpQdX6cFVenAFraA0BugdrVQ2D8JrlkdPXsTvbbR1RX2OHZ+Mj4+KzH6cY/VdugfhNSpWC4WCnpqe6bpYjc6TpjQe275Dp/nekk7arb5uVRZ3s7UF6e77z+yuBwCALwXx1VEWrbASHyeucGVqcIUrXDnhyjkojQF6R7w0rq5+iN977Phk2+Oj/YgLhUJfz7H6Ll1pHOVl9a0+e/5izYPpCoVC032G07hLUxpPHDkaH9/qc5JjuXDpctMxUBbLJ3Kf4X0PAABfBuITXYsmy+LjxBWuTA2ucIUrJ1w5B6UxQO+Il8ar7/6OS8tcbnPLrR6eLr9q+jn9OEcnpXGU5yuvN5THnRav0fvSlMZXrl6Pj/9x9qdUx92em695jbLYrETfQYb3PQAAfBmIT3QtmiyLjxNXuDI1uMIVrpxw5RyUxgC9Y0RpnHxo25Wr15sed+r0ufi4O/N3+36ObkrjKI3K43b7Dte7S1MaP3j4LD7+2+/2NDymuvpBDw9vja8hWQRXVz9QFhuW6LvI7rYHAIAvBPGJrkWTZfFx4gpXpgZXuMKVE66cg9IYoHeMKI2fr7yOS061tp1CssR8WX1b8/C6g4cOD+QcvZTGyetIlseduEtTGq++W99eQymlJ44crVlZ/Xzldc3r127M1rw3WmlNWWxOou8qw/seAAC+DMQnuhZNlsXHiStcmRpc4QpXTrhyDkpjgN4xojReffe3vjN/t2YFrFJKj23foUdHt9X87dvv9uiny68Gco5+lMZRnq+8briXcLLQTZNGpe7T5VcbxlnauXvDOI8dn9ywVUd19YO+cvU6ZbFBSXxnAAAAnSA+0bVosiw+TlzhytTgCle4csKVc1AaA/RO30rjaGVtt6Xx6ru/9aMnL1qWqhcuXW65X3Gv5+hnadwspZ27ey6NV9993qZi7779Dd9TKBQGdv2k/0l8dwAAAJ0gPtG1aLIsPk5c4crU4ApXuHLClXNQGgP0Tt9K4wcPn+mFxaWmq4A7ycvqW72wuKSvXL2ub96a0w8ePsvsHAuLS3phcaltOd1tni6/ij+jXdJc84OHz3RYua+npmf0nfm7ffFPso2iNAYAgO4Qn+haNFkWHyeucGVqcIUrXDnhyjkojQF6p2+lMSGkuyhKYwAA6A7xia5Fk2XxceIKV6YGV7jClROunIPSGKB3KI0JEY6iNAYAgO4Qn+haNFkWHyeucGVqcIUrXDnhyjkojQF6h9KYEOEoSmMAAOgO8YmuRZNl8XHiClemBle4wpUTrpyD0higdyiNCRGOojQGAIDuEJ/oWjRZFh8nrnBlanCFK1w54co5KI0BeofSmBDhKEpjAADoAs//+h+1/p8h1mZtHAMFV+nBVXpwlR5cpQdX6cEVtILSGKB3tFKUxoRIRq3/YAAAAOgE8dVRFq2wEh8nrnBlanCFK1w54co5KI0BeofSmBDhKEpjAADoDvGJrkWTZfFx4gpXpgZXuMKVE66cg9IYoHcojQkRjqI0BgCA7hCf6Fo0WRYfJ65wZWpwhStcOeHKObIojcOid6YSeI/Lgf/zoD4DQBJKY0KEoyiNAQCgO8QnuhZNlsXHiStcmRpc4QpXTrhyjixKY4AvHUpjQoSjKI0BAKA7xCe6Fk2WxceJK1yZGlzhCldOuHIOE0vjcERtCsf9A2FxaOLXcf9GlLA4NCF9bQCNoDQmRDiK0hgAALpDfKJr0WRZfJy4wpWpwRWucOWEK+cwqTQOx/0DlcB7XCn5ulXKJe+XsJjbIn29ABGUxoQIR1EaAwBAd4hPdC2aLIuPE1e4MjW4whWunHDlHCaUxuFIPp+mLK4rjj+aUHQDKEVpTIh4FKUxAAB0h/hE16LJsvg4cYUrU4MrXOHKCVfOYUJpXA68sEk5vFIJvMefH6LnVRuWx4E3I3XdABGUxoQIR1EaAwBAd4hPdC2aLIuPE1e4MjW4whWunHDlHNKlcVj0ztSuIPbvtdq7OCwOTZRL/p/rpbH/KQy8sSyvGaAeSmNChKMojQEAoDvEJ7oWTZbFx4krXJkaXOEKV064cg7p0rgceL8nCuCfU7+v5P2SLJoHeY0A7dCEEGMCAADQCeITXYsmy+LjxBWuTA2ucIUrJ1w5h3xp7L9f26P4TTiiNnX23s9bVpQDrzqo6wNIg3RJRghZDwAAQGo8/+t/lPx/dvWctXEMFFylB1fpwVV6cJUeXKUHV9AKydI4LOa29LJaOLkXcqeFM0A/0UqxPQUhklHrPxgAAAA6QXx1lEUrrMTHiStcmRpc4QpXTrhyDtHSeCw/knig3Wyn74+uvVLydTiWHxnAJQKkgtKYEOEoSmMAAOgO8YmuRZNl8XHiClemBle4wpUTrpzDgO0pPq2Vxr93/N6Sf4+VxmAClMaECEdRGgMAQHeIT3QtmiyLjxNXuDI1uMIVrpxw5RzSpXEl8B6vPQTvfSfFbziiNkX7IVdK/sogrxGgHZTGhAhHURoDAEB3iE90LZosi48TV7gyNbjCFa6ccOUc0qVxuTj0w/oWFf7Pqd8XeDPx+4pDPwzyGgHaQWlMiHAUpTEAAHSH+ETXosmy+DhxhStTgytc4coJV84hXRp/XjHsVeNtJor5XW3fU8zvire1KHlv2JoCpKE0JkQ4itIYAAC6Q3yia9FkWXycuMKVqcEVrnDlhCvnkC6NlVIqDLyxcsn7pRx4v4fFoYm2xxdzW34d92/8Ou7f4AF4YAKUxoQIR1EaAwBAd4hPdC2aLIuPE1e4MjW4whWunHDlHCaUxgC2Q2lMiHAUpTEAAHSH+ETXosmy+DhxhStTgytc4coJV85BaQzQO5TGhAhHURoDAEB3iE90LZosi48TV7gyNbjCFa6ccOUclMYAvUNpTIhwFKUxAAB0h/hE16LJsvg4cYUrU4MrXOHKCVfOIV0ah8X8rnDcPzDQpHi4HkAvUBoTIhxFaQwAAN0hPtG1aLIsPk5c4crU4ApXuHLClXNIl8blkvemUvL1IFMO/E8SYwN3oDQmRDiK0hgAALpDfKJr0WRZfJy4wpWpwRWucOWEK+dwoTSulHz+2YGBQmlMiHAUpTEAAHSB53/9j1r/zxBrszaOgYKr9OAqPbhKD67Sg6v04ApaYUBp/Esl8B6nTbJkLpe8N6neE3ihxNjAHbRSlMaESEat/2AAAADoBPHVURatsBIfJ65wZWpwhStcOeHKOaRL404JR/L5SuA9Xtt24n04lh+RviYASmNChKMojQEAoDvEJ7oWTZbFx4krXJkaXOEKV064cg7bSmOllApH1KZKyV+plHxdCbzlcERtkr4mcBtK40SeLr/Se/ft13v37de//fGX+PUQN6IojQEAoDvEJ7oWTZbFx4krXJkaXOEKV064cg4bS2OllArH8iPlwP9k47XDl0dfS+Pf/vhLLywuxXn05IV4IddJFhaX/v/27ic0ijz94/gXlgWhUXpSRZiDA028JHaqIjIMQgKJCOIcRnIJDjgMg4MwiuAqCBEEAx4Cgi4ewngIFFMtCjKDDC4M6xyie4l4iXhp8JCAIJKTh9/Bk9TvYKqtTjqd6j/p5/vt5/2C52I6bX0/vbL7fLaorhV4N28v7Prf9+Tpi+T+w8fJjflbyd3Fe8n9h4+T6uq6eA5Mb8dQGgMA2iO+6Dq0LIufk6zIytYhK7IiKxVZqeNqaWyMMXHoP9h4vvGK9LVAt66VxuMTk00f7n702PGeFLGdTK9K46jyexKOHW6YU6GwNzlz9nzyfOW1eB5Mb8ZQGgMA2iO+6Dq0LIufk6zIytYhK7IiKxVZqeN0aRx48+mX4kWlYlH6eqBX10pj06Qwzs74xGTysvpGvKhrNL0oja/NzdflMTR0IBmfmNxSIodjh7nrWMlkPncAAFohvug6tCyLn5OsyMrWISuyIisVWanjdGkc+n/VSuNy4Uvp64FeXS+Nxycma3+WPn7h3IVLyf79X9Ve8/U3R8SLukaz26Xxk6cvkkJhb60s/s9//1f382fLr5KvvzlSu4aLl2fFM2F2fwylMQCgPeKLrkPLsvg5yYqsbB2yIiuyUpGVOq6WxtGoP5U+0zgO/HfS1wPddrU0zs6z5VfJ4OBg7XV3F++Jl3Wbp9ul8eZSOHuX8Z2FxYa/83zldd0jPTb/3LXnRDM7j6E0BgC0R3zRdWhZFj8nWZGVrUNWZEVWKrJSx6XSOCoXvoxG/ak49H6NQ+99epdxHHiPpK8NuvWsNF59W1+a/vDjz+Jl3ebpVml8/+Hj2jOes38+c+p07f2fLb/a9veHhg4kxphkeORg3Z8/W36VGGOSE99+t6WQZtwdQ2kMAGiP+KLr0LIsfk6yIitbh6zIiqxUZKWOdGlcCf2VtPxtZ+LA/xAF3rDEtQOpnpbG2VI2HDvc8DXPV14n1+bmk5lTp5Nw7HAyNHQgOXrseHLx8mzyx59/57qWdt+j09I4WxY3yvaHH3+u/fn9h48bvkd1db32CIsT335X97OX1Td170153B+T+UwBAGiF+KLr0LIsfk6yIitbh6zIiqxUZKWOdGkch95ah4XxtMR1A1k9LY3TO2XNNs81vrt4r+4RFo3mytXrTa+jk/dotzRuVBYPDR3Y8giKm7cX6grfRu915er1po/wuDF/q+750Ol7UR67O5nPEgCAVogvug4ty+LnJCuysnXIiqzISkVW6oiXxoFXbbEoflcJvKU48GajUrEocc3AZj0tje8u3qu97szZ83U/u3h5tvazQmFvcnJ6Jrk2N1+7YzhblG7+3W69R6ulcaOyeHjkYNPfzX7R3Ylvv0teVt/UfnbuwqXazxo9zzid6up6cmP+Vu0xFtn3ozx2bzKfIQAAuXn+vo+myf9J7spsnGNXkVV+ZJUfWeVHVvmRVX5khWakS2OgHyTG9K40PvHtd7XXZYvV5yuva49kGB452LD4fLb8qq4k3fyabrxH3tK4UVkcjh3O9eV+L6tvknDscO339u//Krk2N7+lTK6urufK/ebtBcpjxyfz2QEA0Arxu6McusNK/JxkRVa2DlmRFVmpyEodSmOgcz0pjaur63V30YZjh+tK0TNnz9d+1qx4zd6pfHJ6pu5n3XiPnUrjTsriZnlkp90v4Lt5e6GujDaUx85M5jMDAKAV4ouuQ8uy+DnJiqxsHbIiK7JSkZU6lMZA57peGg8NHUguXp6tzdFjx+vuhC0U9m4pMtPHRgyPHNzx70lfu3//V11/j2al8bW5+bpCdnxiMokqv7ed15Wr1xs+e3l45GDLJXR27i7e21Iet1tEM72ZzGcFAEArxBddh5Zl8XOSFVnZOmRFVmSlIit1KI2BznW9NG42R48dT548fVH3e9XV9W3v/G002UdcpHcrd+M9Vt82L41/+PHn2s9mTp1uO6cnT18kwyMH6643qvyeHD12vC6r7Z7bnGeqq+t179fJ9TK7P5nPHQCAVogvug4ty+LnJCuysnXIiqzISkVW6thWGkcjA0eiUX8qKn/x/W+j/lyeiQJvWvq6oVvXS+PBwcFkfGKyNucuXEouXp5N/vjz74a/9+Tpi5aK0plTp2uvT+9Y7sZ7rL5tXhrfXbxXe2ay2bij+sb8rdzPHk6vM727eHBwMLn/8HHdz6PK77m+8G+7qa6uJ9fm5uveo1DY29Gdy8zuT/pZ9fIfPgCgL4gvug4ty+LnJCuysnXIiqzISkVW6thQGkclsyce9X+JQ2+tEvpJqxMHXlXq2gFjdqE0bvZFeI3mjz//rv3uuQuXdnx9tvBN71ruxnusvt35mcbPV14nZ86eryuP0y+yy1Mep89DLhT2bluiP1t+VVf65nkm8XZl8Zmz55PnK6/FS1Gm+aSfWS//4QMA+oL4ouvQsix+TrIiK1uHrMiKrFRkpY4NpXEceFE7ZXGtNA69NalrB4yxoDR+vvK6pccoZB+70M33WH27c2mc/fsalcdXrl5PXlbfNPyd7N3QP/z4c9Pryz4/+crV69u+7mX1TXLx8mzds5Epi92b9LPr4b97AEB/EF90HVqWxc9JVmRl65AVWZGViqzUkS6N41H/lwZF8Eol8Jbi0H+Q6/EUZe8niWsHUuKlcfZ3w7HDO742/VK9zV941433yFsap9OoPB4cHEwuXp7dUh7fWVisvebG/K2m75u9jkYFM2Vxf036Gfb0Xz4AoB+IL7oOLcvi5yQrsrJ1yIqsyEpFVupIl8aVwFuulcWBtxQF3rDEdQCdsKI0/vqbI7kex3B38V7tdZuf99uN92i1NE5nu/I4e5dw9u/d6REa2YL52tx83c82l8Vm4+7qZ8uvxMtPpr3JfJYAALRCfNF1aFkWPydZkZWtQ1ZkRVYqslJHujSOA/9D+oiJqFQsSlwD0CkrSuNsoRqOHW54t+yz5Ve1O4QLhb1bXtON92i3NE6nUXmc/uxl9U3doyy2K3mrq+t1BXj22cfZx3AYyuK+mcxnCgBAK8QXXYeWZfFzkhVZ2TpkRVZkpSIrdSRL42i4WMp8mV3U678f6BYrSuPVt5+/JM5slKrnLlxK7iwsJncWFrfcXbvdnbqdvkenpXE62fI4++dnzp7f8hiL+w8f1+bm7YVaqW0aPJoiLY0pi/tr0s+7t//0AQB9QHzRdWhZFj8nWZGVrUNWZEVWKrJSR/xO49B7v1Eaz0v8/UA3WFMav6y+SU5Oz9TdSbt5CoW9TcvcTt+jW6Vx9no2/9lO15fOyemZpLq6vuX3eWZx/03mcwcAoBXii65Dy7L4OcmKrGwdsiIrslKRlTripXHgPUq//E7i7we6oWul8cnpmWR8YnLH5/XuNHcWFpOZU6drdw0PDR1Ixicmk4uXZ5MnT1/s6ns8efoiGZ+YTMYnJuseC9Ht+c9//1fLK737Ob1G7iLWN4bSGADQBs/f99Hk+D+ibZ+Nc+wqssqPrPIjq/zIKj+yyo+s0Ix0aRyVv/g+fURFVP7ie4lrADqVGNOd0phhmPbGfP4fDAAAtEL87iiH7rASPydZkZWtQ1ZkRVYqslJHujQ2xpg49P/69IgK/0NUHjghdR1AuyiNGUZ4DKUxAKA94ouuQ8uy+DnJiqxsHbIiK7JSkZU6NpTGUalYrIT+yufi2PspGvWnck+pWJS6dsAYSmOGER9DaQwAaI/4ouvQsix+TrIiK1uHrMiKrFRkpY50aRwHXlQJvKW0NG5zeB4yRFEaM4zwGEpjAEB7xBddh5Zl8XOSFVnZOmRFVmSlIit1xEvj0FvroCxOKqGfxKG3JnHtQIrSmGGEx1AaAwDaI77oOrQsi5+TrMjK1iErsiIrFVmpI10ad3iH8acJvCWJawdSlMYMIzyG0hgA0B7xRdehZVn8nGRFVrYOWZEVWanISh3p0hjoB5TGDCM8htIYANAe8UXXoWVZ/JxkRVa2DlmRFVmpyEodSmOgc5TGDCM8htIYANAe8UXXoWVZ/JxkRVa2DlmRFVmpyEodSmOgc5TGDCM8htIYANAe8UXXoWVZ/JxkRVa2DlmRFVmpyEodSmOgc5TGDCM8htIYANAe8UXXoWVZ/JxkRVa2DlmRFVmpyEodSmOgc5TGDCM8htIYANAe8UXXoWVZ/JxkRVa2DlmRFVmpyEod6dI4KhcPRaP+VEcTeMMS1w6kKI0ZRngMpTEAoA2ev++j+fzfIc7Oxjl2FVnlR1b5kVV+ZJUfWeVHVmhGujSOQ2+tEvpJJxMHXlXi2oFUYgylMcNIjvn8PxgAAGiF+N1RDt1hJX5OsiIrW4esyIqsVGSlTl+UxqG3JnHtQIrSmGGEx1AaAwDaI77oOrQsi5+TrMjK1iErsiIrFVmpY0Fp/Gsl8JbyTrZkjgPv0W+j/lwUeNMS1w6kKI0ZRngMpTEAoD3ii65Dy7L4OcmKrGwdsiIrslKRlTrSpXGrolKxWAm8pY07jN9H5eIh6WsCKI0ZRngMpTEAoD3ii65Dy7L4OcmKrGwdsiIrslKRlTqulcbGGBOVzJ5K6K+kj6aISmaP9DVBN/GHvjMMUxsAAFohvug6tCyLn5OsyMrWISuyIisVWanjYmlsjDHRcLEUB/4HF68d/WfZyBdlDMMYs2YAAGiN+KLr0LIsfk6yIitbh6zIiqxUZKWOq6WxMcbEof+gEvpJJfCWpK8FAAAAgHvEF12HlmXxc5IVWdk6ZEVWZKUiK3WcLo0Db/7TF+L5H6JSsSh9PQAAAADcIr7oOrQsi5+TrMjK1iErsiIrFVmp43RpHPp/VUI/qYR+EpULX0pfDwAAAAC3iC+6Di3L4uckK7KydciKrMhKRVbquFoaR6P+VPpM4zjw30lfDwAAAAD3iC+6Di3L4uckK7KydciKrMhKRVbquFQaR+XCl9GoPxWH3q9x6L1P7zKOA++R9LUBAAAAcI/4ouvQsix+TrIiK1uHrMiKrFRkpY50aVwJ/ZW0/G1n4sD/EAXesMS1AwAAAHCb+KLr0LIsfk6yIitbh6zIiqxUZKWOdGkch95ah4XxtMR1AwAAAHCc5+/7aD4tmk7Pxjl2FVnlR1b5kVV+ZJUfWeVHVmhGvDQOvGqLRfG7SuAtxYE3G5WKRYlrBgAAANAfxO+OcugOK/FzkhVZ2TpkRVZkpSIrdaRLYwAAAACQIr7oOrQsi5+TrMjK1iErsiIrFVmpQ2kMAAAAQCvxRdehZVn8nGRFVrYOWZEVWanISh1KYwAAAABaiS+6Di3L4uckK7KydciKrMhKRVbqUBoDAAAA0Ep80XVoWRY/J1mRla1DVmRFViqyUofSGAAAAIBW4ouuQ8uy+DnJiqxsHbIiK7JSkZU60qVxVC4eikb9qV2dcvGQxNkAAAAA2E180XVoWRY/J1mRla1DVmRFViqyUke6NI5Db60S+sluThz4HyTOBgAAAMBu4ouuQ8uy+DnJiqxsHbIiK7JSkZU6GkrjSujznx0AAAAAW4gvug4ty+LnJCuysnXIiqzISkVW6lhQGv9aCbylphP6K3Hore34um0mDrxI4mwAAAAA7Ca+6Dq0LIufk6zIytYhK7IiKxVZqSNdGu8kGhk4Egf+uzj03vNsYgAAAADdJL7oOrQsi5+TrMjK1iErsiIrFVmpY3NpHJcH/hUH/ofss4mj8sAJ6esCAAAA0Ac8f99H82nRdHo2zrGryCo/ssqPrPIjq/zIKj+yQjM2lsZRqViMA+/Rdl9qF5W9n6SvEQAAAID7xO+OcugOK/FzkhVZ2TpkRVZkpSIrdWwrjaNy8VAceNW6sjjwlqOy91PdXcflgX9JXysAAAAAt4kvug4ty+LnJCuysnXIiqzISkVW6thUGsej/i/ZYnjjzuJ/RyWzxxhjovLAifrHVXjz0tcMAAAAwF3ii65Dy7L4OcmKrGwdsiIrslKRlTo2lMZRyeyJAy/a+hiKL77f8tqtxXEkcc0AAAAA3Ce+6Dq0LIufk6zIytYhK7IiKxVZqSNdGkeBN7z5cRRx4FWjwBve9ne44xgAAABAF4gvug4ty+LnJCuysnXIiqzISkVW6kiXxlsK49B/EJWKxZ1+L1scx6G31otrBQAAANBfxBddh5Zl8XOSFVnZOmRFVmSlIit1xEvj0FtLH0fR6pfbpcUxpTEAAACAdogvug4ty+LnJCuysnXIiqzISkVW6thQGseB/y4aGTjSzu9Ho/4Uj6cAAAAA0A7xRdehZVn8nGRFVrYOWZEVWanISh3p0jgqFw/leRwFAAAAAHSb+KLr0LIsfk6yIitbh6zIiqxUZKWOdGkMAAAAAFLEF12HlmXxc5IVWdk6ZEVWZKUiK3UojQEAAABoJb7oOrQsi5+TrMjK1iErsiIrFVmpQ2kMAAAAQCvxRdehZVn8nGRFVrYOWZEVWanISh1KYwAAAAAqef6+j+bToun0bJxjV5FVfmSVH1nlR1b5kVV+ZIVmKI0BAAAAaCV+d5RDd1iJn5OsyMrWISuyIisVWalDaQwAAABAK/FF16FlWfycZEVWtg5ZkRVZqchKHUpjAAAAAFqJL7oOLcvi5yQrsrJ1yIqsyEpFVupQGgMAAADQSnzRdWhZFj8nWZGVrUNWZEVWKrJSh9IYAAAAgFbii65Dy7L4OcmKrGwdsiIrslKRlTqUxgAAAAC0El90HVqWxc9JVmRl65AVWZGViqzUoTQGAAAAoJX4ouvQsix+TrIiK1uHrMiKrFRkpQ6lMQAAAACtxBddh5Zl8XOSFVnZOmRFVmSlIit1KI0BAAAAaCW+6Dq0LIufk6zIytYhK7IiKxVZqRMH3jylMQAAAACNxBddh5Zl8XOSFVnZOmRFVmSlIqu+Fg0XS9GoPxUF3nQcePNx4FUroZ9UQj+JR/1fpK8PAAAAAHpJfNF1aFkWPydZkZWtQ1ZkRVYqsuoLceC/S8vgnSYO/A9x4P87Kpk90tcNAAAAAD3zz3/+4//Mp0XT6dk4x64iq/zIKj+yyo+s8iOr/MhKnzj01rYpiVcqgbcUh/6D30b9uag8cIKyGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAx5v8BiiLGKuTnkr4AAAAASUVORK5CYII=" width="100%">
        
      
    </figure>
  </cxx-figure>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

      <p para_num="2" id="memory.resource.pool.overview.2">
        A <code>synchronized_pool_resource</code> may be accessed from multiple threads without external synchronization
        and may have thread-specific pools to reduce synchronization costs.
        An <code>unsynchronized_pool_resource</code> class may not be accessed from multiple threads simultaneously
        and thus avoids the cost of synchronization entirely in single-threaded applications.
      </p>

<pre><code>struct pool_options {
  size_t max_blocks_per_chunk = 0;
  size_t largest_required_pool_block = 0;
};

class synchronized_pool_resource : public memory_resource {
public:
  synchronized_pool_resource(const pool_options&amp; opts, memory_resource* upstream);

  synchronized_pool_resource()
      : synchronized_pool_resource(pool_options(), get_default_resource()) { }
  explicit synchronized_pool_resource(memory_resource* upstream)
      : synchronized_pool_resource(pool_options(), upstream) { }
  explicit synchronized_pool_resource(const pool_options&amp; opts)
      : synchronized_pool_resource(opts, get_default_resource()) { }

  synchronized_pool_resource(
      const synchronized_pool_resource&amp;) = delete;
  virtual ~synchronized_pool_resource();

  synchronized_pool_resource&amp; operator=(
      const synchronized_pool_resource&amp;) = delete;

  void release();
  memory_resource* upstream_resource() const;
  pool_options options() const;

protected:
  virtual void* do_allocate(size_t bytes, size_t alignment);
  virtual void do_deallocate(void* p, size_t bytes, size_t alignment);

  virtual bool do_is_equal(const memory_resource&amp; other) const noexcept;
};

class unsynchronized_pool_resource : public memory_resource {
public:
  unsynchronized_pool_resource(const pool_options&amp; opts, memory_resource* upstream);

  unsynchronized_pool_resource()
      : unsynchronized_pool_resource(pool_options(), get_default_resource()) { }
  explicit unsynchronized_pool_resource(memory_resource* upstream)
      : unsynchronized_pool_resource(pool_options(), upstream) { }
  explicit unsynchronized_pool_resource(const pool_options&amp; opts)
      : unsynchronized_pool_resource(opts, get_default_resource()) { }

  unsynchronized_pool_resource(
      const unsynchronized_pool_resource&amp;) = delete;
  virtual ~unsynchronized_pool_resource();

  unsynchronized_pool_resource&amp; operator=(
      const unsynchronized_pool_resource&amp;) = delete;

  void release();
  memory_resource* upstream_resource() const;
  pool_options options() const;

protected:
  virtual void* do_allocate(size_t bytes, size_t alignment);
  virtual void do_deallocate(void* p, size_t bytes, size_t alignment);

  virtual bool do_is_equal(const memory_resource&amp; other) const noexcept;
};</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.resource.pool.options">
    

    <section>
      <header><span class="section-number">8.9.2</span> <h1 data-bookmark-label="8.9.2 pool_options data members"><code>pool_options</code> data members</h1> <span style="float:right"><a href="#memory.resource.pool.options">[memory.resource.pool.options]</a></span></header>
      
      

      <p para_num="1" id="memory.resource.pool.options.1">
        The members of <code>pool_options</code> comprise a set of constructor options for pool resources.
        The effect of each option on the pool resource behavior is described below:
      </p>

      <cxx-function para_num="2" id="memory.resource.pool.options.2">
    
    <pre><code><cxx-signature>size_t max_blocks_per_chunk;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="3" id="memory.resource.pool.options.3">
          The maximum number of blocks that will be allocated at once from the upstream memory resource to replenish a pool.
          If the value of <code>max_blocks_per_chunk</code> is zero or 
is greater than an implementation-defined limit, that limit is used 
instead.
          The implementation may choose to use a smaller value than is 
specified in this field and may use different values for different 
pools.
        </p>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="memory.resource.pool.options.4">
    
    <pre><code><cxx-signature>size_t largest_required_pool_block;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="5" id="memory.resource.pool.options.5">
          The largest allocation size that is required to be fulfilled 
using the pooling mechanism.
          Attempts to allocate a single block larger than this threshold
 will be allocated directly from the upstream memory resource.
          If <code>largest_required_pool_block</code> is zero or is greater than an implementation-defined limit, that limit is used instead.
          The implementation may choose a pass-through threshold larger than specified in this field.
        </p>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.resource.pool.ctor">
    

    <section>
      <header><span class="section-number">8.9.3</span> <h1 data-bookmark-label="8.9.3 pool resource constructors and destructors">pool resource constructors and destructors</h1> <span style="float:right"><a href="#memory.resource.pool.ctor">[memory.resource.pool.ctor]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.resource.pool.ctor.1">
    
    <pre><code><cxx-signature>synchronized_pool_resource(const pool_options&amp; opts, memory_resource* upstream);</cxx-signature><cxx-signature>unsynchronized_pool_resource(const pool_options&amp; opts, memory_resource* upstream);</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-requires para_num="2" id="memory.resource.pool.ctor.2">
    
    <dt>Requires:</dt><dd><code>upstream</code> is the address of a valid memory resource.</dd>
  </cxx-requires>
        <cxx-effects para_num="3" id="memory.resource.pool.ctor.3">
    
    <dt>Effects:</dt><dd>
          Constructs a pool resource object that will obtain memory from <code>upstream</code> whenever the pool resource is unable to satisfy a memory request from its own internal data structures.
          The resulting object will hold a copy of <code>upstream</code>, but will not own the resource to which <code>upstream</code> points.
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The intention is that calls to <code>upstream-&gt;allocate()</code> will be substantially fewer than calls to <code>this-&gt;allocate()</code> in most cases.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
          The behavior of the pooling mechanism is tuned according to the value of the opts argument.
        </dd>
  </cxx-effects>
        <cxx-throws para_num="4" id="memory.resource.pool.ctor.4">
    
    <dt>Throws:</dt><dd>Nothing unless <code>upstream-&gt;allocate()</code> throws.
        It is unspecified if or under what conditions this constructor calls <code>upstream-&gt;allocate()</code>.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="memory.resource.pool.ctor.5">
    
    <pre><code><cxx-signature>virtual ~synchronized_pool_resource();</cxx-signature><cxx-signature>virtual ~unsynchronized_pool_resource();</cxx-signature></code></pre>

    <dl>
      
        
        
        <cxx-effects para_num="6" id="memory.resource.pool.ctor.6">
    
    <dt>Effects:</dt><dd>Calls <code>this-&gt;release()</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.resource.pool.mem">
    

    <section>
      <header><span class="section-number">8.9.4</span> <h1 data-bookmark-label="8.9.4 pool resource members">pool resource members</h1> <span style="float:right"><a href="#memory.resource.pool.mem">[memory.resource.pool.mem]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.resource.pool.mem.1">
    
    <pre><code><cxx-signature>void release();</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="2" id="memory.resource.pool.mem.2">
    
    <dt>Effects:</dt><dd>
          Calls <code>upstream_resource()-&gt;deallocate()</code> as necessary to release all allocated memory.
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    memory is released back to <code>upstream_resource()</code> even if <code>deallocate</code> has not been called for some of the allocated blocks.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.resource.pool.mem.3">
    
    <pre><code><cxx-signature>memory_resource* upstream_resource() const;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="4" id="memory.resource.pool.mem.4">
    
    <dt>Returns:</dt><dd>The value of the <code>upstream</code> argument provided to the constructor of this object.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="memory.resource.pool.mem.5">
    
    <pre><code><cxx-signature>pool_options options() const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="6" id="memory.resource.pool.mem.6">
    
    <dt>Returns:</dt><dd>
          The options that control the pooling behavior of this 
resource.
          The values in the returned struct may differ from those 
supplied to the pool resource constructor
          in that values of zero will be replaced with 
implementation-defined defaults and sizes may be rounded to unspecified 
granularity.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="memory.resource.pool.mem.7">
    
    <pre><code><cxx-signature>virtual void* do_allocate(size_t bytes, size_t alignment);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="8" id="memory.resource.pool.mem.8">
    
    <dt>Returns:</dt><dd>A pointer to allocated storage (<cxx-ref in="cxx" to="basic.stc.dynamic.deallocation">C++14 <span title="basic.stc.dynamic.deallocation">§3.7.4.2</span></cxx-ref>) with a size of at least <code>bytes</code>.
        The size and alignment of the allocated memory shall meet the requirements for a class derived from <code>memory_resource</code> (<cxx-ref to="memory.resource"><a title="memory.resource" href="#memory.resource">8.5</a></cxx-ref>).</dd>
  </cxx-returns>
        <cxx-effects para_num="9" id="memory.resource.pool.mem.9">
    
    <dt>Effects:</dt><dd>
          If the pool selected for a block of size <code>bytes</code> is unable to satisfy the memory request from its own internal data structures,
          it will call <code>upstream_resource()-&gt;allocate()</code> to obtain more memory.
          If <code>bytes</code> is larger than that which the largest pool can handle,
          then memory will be allocated using <code>upstream_resource()-&gt;allocate()</code>.
        </dd>
  </cxx-effects>
        <cxx-throws para_num="10" id="memory.resource.pool.mem.10">
    
    <dt>Throws:</dt><dd>Nothing unless <code>upstream_resource()-&gt;allocate()</code> throws.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="11" id="memory.resource.pool.mem.11">
    
    <pre><code><cxx-signature>virtual void do_deallocate(void* p, size_t bytes, size_t alignment);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="12" id="memory.resource.pool.mem.12">
    
    <dt>Effects:</dt><dd>Return the memory at <code>p</code> to the pool.
        It is unspecified if or under what circumstances this operation will result in a call to <code>upstream_resource()-&gt;deallocate()</code>.</dd>
  </cxx-effects>
        <cxx-throws para_num="13" id="memory.resource.pool.mem.13">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="14" id="memory.resource.pool.mem.14">
    
    <pre><code><cxx-signature>virtual bool unsynchronized_pool_resource::do_is_equal(<w-br><wbr></w-br>const memory_resource&amp; other) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="15" id="memory.resource.pool.mem.15">
    
    <dt>Returns:</dt><dd><code>this == dynamic_cast&lt;const unsynchronized_pool_resource*&gt;(&amp;other)</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="16" id="memory.resource.pool.mem.16">
    
    <pre><code><cxx-signature>virtual bool synchronized_pool_resource::do_is_equal(<w-br><wbr></w-br>const memory_resource&amp; other) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="17" id="memory.resource.pool.mem.17">
    
    <dt>Returns:</dt><dd><code>this == dynamic_cast&lt;const synchronized_pool_resource*&gt;(&amp;other)</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.resource.monotonic.buffer">
    

    <section>
      <header><span class="section-number">8.10</span> <h1 data-bookmark-label="8.10 Class monotonic_buffer_resource">Class <code>monotonic_buffer_resource</code></h1> <span style="float:right"><a href="#memory.resource.monotonic.buffer">[memory.resource.monotonic.buffer]</a></span></header>
      
    

    <cxx-section id="memory.resource.monotonic.buffer.overview">
    

    <section>
      <header><span class="section-number">8.10.1</span> <h1 data-bookmark-label="8.10.1 Class monotonic_buffer_resource overview">Class <code>monotonic_buffer_resource</code> overview</h1> <span style="float:right"><a href="#memory.resource.monotonic.buffer.overview">[memory.resource.monotonic.buffer.overview]</a></span></header>
      
      

      <p para_num="1" id="memory.resource.monotonic.buffer.overview.1">
        A <code>monotonic_buffer_resource</code> is a special-purpose memory resource
        intended for very fast memory allocations in situations where memory is used to build up a few objects
        and then is released all at once when the memory resource object is destroyed.
        It has the following qualities:
      </p>
      <ul>
        <li>A call to <code>deallocate</code> has no effect,
        thus the amount of memory consumed increases monotonically until the resource is destroyed.</li>
        <li>The program can supply an initial buffer, which the allocator uses to satisfy memory requests.</li>
        <li>When the initial buffer (if any) is exhausted,
        it obtains additional buffers from an <dfn>upstream</dfn> memory resource supplied at construction.
        Each additional buffer is larger than the previous one, following a geometric progression.</li>
        <li>It is intended for access from one thread of control at a time.
        Specifically, calls to <code>allocate</code> and <code>deallocate</code> do not synchronize with one another.</li>
        <li>It <cxx-term><i>owns</i></cxx-term> the allocated memory and frees it on destruction,
        even if <code>deallocate</code> has not been called for some of the allocated blocks.</li>
      </ul>
<pre><code>class monotonic_buffer_resource : public memory_resource {
  memory_resource* upstream_rsrc; // exposition only
  void* current_buffer; // exposition only
  size_t next_buffer_size; // exposition only

public:
  explicit monotonic_buffer_resource(memory_resource* upstream);
  monotonic_buffer_resource(size_t initial_size,
                            memory_resource* upstream);
  monotonic_buffer_resource(void* buffer, size_t buffer_size,
                            memory_resource* upstream);

  monotonic_buffer_resource()
      : monotonic_buffer_resource(get_default_resource()) { }
  explicit monotonic_buffer_resource(size_t initial_size)
      : monotonic_buffer_resource(initial_size,
                                  get_default_resource()) { }
  monotonic_buffer_resource(void* buffer, size_t buffer_size)
      : monotonic_buffer_resource(buffer, buffer_size,
                                  get_default_resource()) { }

  monotonic_buffer_resource(const monotonic_buffer_resource&amp;) = delete;

  virtual ~monotonic_buffer_resource();

  monotonic_buffer_resource operator=(
      const monotonic_buffer_resource&amp;) = delete;

  void release();
  memory_resource* upstream_resource() const;

protected:
  virtual void* do_allocate(size_t bytes, size_t alignment);
  virtual void do_deallocate(void* p, size_t bytes,
                             size_t alignment);

  virtual bool do_is_equal(const memory_resource&amp; other) const noexcept;
};</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.resource.monotonic.buffer.ctor">
    

    <section>
      <header><span class="section-number">8.10.2</span> <h1 data-bookmark-label="8.10.2 monotonic_buffer_resource constructor and destructor"><code>monotonic_buffer_resource</code> constructor and destructor</h1> <span style="float:right"><a href="#memory.resource.monotonic.buffer.ctor">[memory.resource.monotonic.buffer.ctor]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.resource.monotonic.buffer.ctor.1">
    
    <pre><code><cxx-signature>explicit monotonic_buffer_resource(memory_resource* upstream);</cxx-signature><cxx-signature>monotonic_buffer_resource(size_t initial_size, memory_resource* upstream);</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-requires para_num="2" id="memory.resource.monotonic.buffer.ctor.2">
    
    <dt>Requires:</dt><dd><code>upstream</code> shall be the address of a valid memory resource.
        <code>initial_size</code>, if specified, shall be greater than zero.</dd>
  </cxx-requires>
        <cxx-effects para_num="3" id="memory.resource.monotonic.buffer.ctor.3">
    
    <dt>Effects:</dt><dd>Sets <code>upstream_rsrc</code> to <code>upstream</code> and <code>current_buffer</code> to <code>nullptr</code>.
        If <code>initial_size</code> is specified, sets <code>next_buffer_size</code> to at least <code>initial_size</code>;
        otherwise sets <code>next_buffer_size</code> to an implementation-defined size.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="memory.resource.monotonic.buffer.ctor.4">
    
    <pre><code><cxx-signature>monotonic_buffer_resource(void* buffer, size_t buffer_size, memory_resource* upstream);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="5" id="memory.resource.monotonic.buffer.ctor.5">
    
    <dt>Requires:</dt><dd><code>upstream</code> shall be the address of a valid memory resource.
        <code>buffer_size</code> shall be no larger than the number of bytes in <code>buffer</code>.</dd>
  </cxx-requires>
        <cxx-effects para_num="6" id="memory.resource.monotonic.buffer.ctor.6">
    
    <dt>Effects:</dt><dd>Sets <code>upstream_rsrc</code> to <code>upstream</code>, <code>current_buffer</code> to <code>buffer</code>, and <code>next_buffer_size</code> to <code>initial_size</code> (but not less than 1),
        then increases <code>next_buffer_size</code> by an implementation-defined growth factor (which need not be integral).</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="memory.resource.monotonic.buffer.ctor.7">
    
    <pre><code><cxx-signature>~monotonic_buffer_resource();</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="8" id="memory.resource.monotonic.buffer.ctor.8">
    
    <dt>Effects:</dt><dd>Calls <code>this-&gt;release()</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.resource.monotonic.buffer.mem">
    

    <section>
      <header><span class="section-number">8.10.3</span> <h1 data-bookmark-label="8.10.3 monotonic_buffer_resource members">monotonic_buffer_resource members</h1> <span style="float:right"><a href="#memory.resource.monotonic.buffer.mem">[memory.resource.monotonic.buffer.mem]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.resource.monotonic.buffer.mem.1">
    
    <pre><code><cxx-signature>void release();</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="2" id="memory.resource.monotonic.buffer.mem.2">
    
    <dt>Effects:</dt><dd>Calls <code>upstream_rsrc-&gt;deallocate()</code> as necessary to release all allocated memory.</dd>
  </cxx-effects>
        <p para_num="3" id="memory.resource.monotonic.buffer.mem.3"><cxx-note><span class="nowrap">[ <em>Note:</em></span>
    memory is released back to <code>upstream_rsrc</code> even if some blocks that were allocated from <code>this</code> have not been deallocated from <code>this</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="memory.resource.monotonic.buffer.mem.4">
    
    <pre><code><cxx-signature>memory_resource* upstream_resource() const;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="5" id="memory.resource.monotonic.buffer.mem.5">
    
    <dt>Returns:</dt><dd>The value of <code>upstream_rsrc</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="memory.resource.monotonic.buffer.mem.6">
    
    <pre><code><cxx-signature>void* do_allocate(size_t bytes, size_t alignment);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="7" id="memory.resource.monotonic.buffer.mem.7">
    
    <dt>Returns:</dt><dd>A pointer to allocated storage (<cxx-ref in="cxx" to="basic.stc.dynamic.deallocation">C++14 <span title="basic.stc.dynamic.deallocation">§3.7.4.2</span></cxx-ref>) with a size of at least <code>bytes</code>.
        The size and alignment of the allocated memory shall meet the requirements for a class derived from <code>memory_resource</code> (<cxx-ref to="memory.resource"><a title="memory.resource" href="#memory.resource">8.5</a></cxx-ref>).</dd>
  </cxx-returns>
        <cxx-effects para_num="8" id="memory.resource.monotonic.buffer.mem.8">
    
    <dt>Effects:</dt><dd>
          If the unused space in <code>current_buffer</code> can fit a block with the specified <code>bytes</code> and <code>alignment</code>,
          then allocate the return block from <code>current_buffer</code>;
          otherwise set <code>current_buffer</code> to <code>upstream_rsrc-&gt;allocate(n, m)</code>,
          where <code>n</code> is not less than <code>max(bytes, next_buffer_size)</code> and <code>m</code> is not less than <code>alignment</code>,
          and increase <code>next_buffer_size</code> by an implementation-defined growth factor (which need not be integral),
          then allocate the return block from the newly-allocated <code>current_buffer</code>.
        </dd>
  </cxx-effects>
        <cxx-throws para_num="9" id="memory.resource.monotonic.buffer.mem.9">
    
    <dt>Throws:</dt><dd>Nothing unless <code>upstream_rsrc-&gt;allocate()</code> throws.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="10" id="memory.resource.monotonic.buffer.mem.10">
    
    <pre><code><cxx-signature>void do_deallocate(void* p, size_t bytes, size_t alignment);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-effects para_num="11" id="memory.resource.monotonic.buffer.mem.11">
    
    <dt>Effects:</dt><dd>None.</dd>
  </cxx-effects>
        <cxx-throws para_num="12" id="memory.resource.monotonic.buffer.mem.12">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
        <cxx-remarks para_num="13" id="memory.resource.monotonic.buffer.mem.13">
    
    <dt>Remarks:</dt><dd>Memory used by this resource increases monotonically until its destruction.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="14" id="memory.resource.monotonic.buffer.mem.14">
    
    <pre><code><cxx-signature>bool do_is_equal(const memory_resource&amp; other) const noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="15" id="memory.resource.monotonic.buffer.mem.15">
    
    <dt>Returns:</dt><dd><code>this == dynamic_cast&lt;const monotonic_buffer_resource*&gt;(&amp;other)</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.resource.aliases">
    

    <section>
      <header><span class="section-number">8.11</span> <h1 data-bookmark-label="8.11 Alias templates using polymorphic memory resources">Alias templates using polymorphic memory resources</h1> <span style="float:right"><a href="#memory.resource.aliases">[memory.resource.aliases]</a></span></header>
      
    

    <cxx-section id="header.string.synop">
    

    <section>
      <header><span class="section-number">8.11.1</span> <h1 data-bookmark-label="8.11.1 Header &lt;experimental/string&gt; synopsis">Header &lt;experimental/string&gt; synopsis</h1> <span style="float:right"><a href="#header.string.synop">[header.string.synop]</a></span></header>
      
      
<pre><code>#include &lt;string&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  // basic_string using polymorphic allocator in namespace pmr
  template &lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
   using basic_string =
     std::basic_string&lt;charT, traits, polymorphic_allocator&lt;charT&gt;&gt;;

  // basic_string typedef names using polymorphic allocator in namespace
  // std::experimental::pmr
  typedef basic_string&lt;char&gt; string;
  typedef basic_string&lt;char16_t&gt; u16string;
  typedef basic_string&lt;char32_t&gt; u32string;
  typedef basic_string&lt;wchar_t&gt; wstring;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="header.deque.synop">
    

    <section>
      <header><span class="section-number">8.11.2</span> <h1 data-bookmark-label="8.11.2 Header &lt;experimental/deque&gt; synopsis">Header &lt;experimental/deque&gt; synopsis</h1> <span style="float:right"><a href="#header.deque.synop">[header.deque.synop]</a></span></header>
      
      
<pre><code>#include &lt;deque&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  template &lt;class T&gt;
  using deque = std::deque&lt;T,polymorphic_allocator&lt;T&gt;&gt;;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="header.forward_list.synop">
    

    <section>
      <header><span class="section-number">8.11.3</span> <h1 data-bookmark-label="8.11.3 Header &lt;experimental/forward_list&gt; synopsis">Header &lt;experimental/forward_list&gt; synopsis</h1> <span style="float:right"><a href="#header.forward_list.synop">[header.forward_list.synop]</a></span></header>
      
      
<pre><code>#include &lt;forward_list&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  template &lt;class T&gt;
  using forward_list =
    std::forward_list&lt;T,polymorphic_allocator&lt;T&gt;&gt;;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="header.list.synop">
    

    <section>
      <header><span class="section-number">8.11.4</span> <h1 data-bookmark-label="8.11.4 Header &lt;experimental/list&gt; synopsis">Header &lt;experimental/list&gt; synopsis</h1> <span style="float:right"><a href="#header.list.synop">[header.list.synop]</a></span></header>
      
      
<pre><code>#include &lt;list&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  template &lt;class T&gt;
  using list = std::list&lt;T,polymorphic_allocator&lt;T&gt;&gt;;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="header.vector.synop">
    

    <section>
      <header><span class="section-number">8.11.5</span> <h1 data-bookmark-label="8.11.5 Header &lt;experimental/vector&gt; synopsis">Header &lt;experimental/vector&gt; synopsis</h1> <span style="float:right"><a href="#header.vector.synop">[header.vector.synop]</a></span></header>
      
      
<pre><code>#include &lt;vector&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  template &lt;class T&gt;
  using vector = std::vector&lt;T,polymorphic_allocator&lt;T&gt;&gt;;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="header.map.synop">
    

    <section>
      <header><span class="section-number">8.11.6</span> <h1 data-bookmark-label="8.11.6 Header &lt;experimental/map&gt; synopsis">Header &lt;experimental/map&gt; synopsis</h1> <span style="float:right"><a href="#header.map.synop">[header.map.synop]</a></span></header>
      
      
<pre><code>#include &lt;map&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  template &lt;class Key, class T, class Compare = less&lt;Key&gt;&gt;
  using map = std::map&lt;Key, T, Compare,
                       polymorphic_allocator&lt;pair&lt;const Key,T&gt;&gt;&gt;;

  template &lt;class Key, class T, class Compare = less&lt;Key&gt;&gt;
  using multimap = std::multimap&lt;Key, T, Compare,
                                 polymorphic_allocator&lt;pair&lt;const Key,T&gt;&gt;&gt;;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="header.set.synop">
    

    <section>
      <header><span class="section-number">8.11.7</span> <h1 data-bookmark-label="8.11.7 Header &lt;experimental/set&gt; synopsis">Header &lt;experimental/set&gt; synopsis</h1> <span style="float:right"><a href="#header.set.synop">[header.set.synop]</a></span></header>
      
      
<pre><code>#include &lt;set&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  template &lt;class Key, class Compare = less&lt;Key&gt;&gt;
  using set = std::set&lt;Key, Compare,
                       polymorphic_allocator&lt;Key&gt;&gt;;

  template &lt;class Key, class Compare = less&lt;Key&gt;&gt;
  using multiset = std::multiset&lt;Key, Compare,
                                 polymorphic_allocator&lt;Key&gt;&gt;;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="header.unordered_map.synop">
    

    <section>
      <header><span class="section-number">8.11.8</span> <h1 data-bookmark-label="8.11.8 Header &lt;experimental/unordered_map&gt; synopsis">Header &lt;experimental/unordered_map&gt; synopsis</h1> <span style="float:right"><a href="#header.unordered_map.synop">[header.unordered_map.synop]</a></span></header>
      
      
<pre><code>#include &lt;unordered_map&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  template &lt;class Key, class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = equal_to&lt;Key&gt;&gt;
  using unordered_map =
    std::unordered_map&lt;Key, T, Hash, Pred,
                       polymorphic_allocator&lt;pair&lt;const Key,T&gt;&gt;&gt;;

  template &lt;class Key, class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = equal_to&lt;Key&gt;&gt;
  using unordered_multimap =
    std::unordered_multimap&lt;Key, T, Hash, Pred,
                            polymorphic_allocator&lt;pair&lt;const Key,T&gt;&gt;&gt;;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="header.unordered_set.synop">
    

    <section>
      <header><span class="section-number">8.11.9</span> <h1 data-bookmark-label="8.11.9 Header &lt;experimental/unordered_set&gt; synopsis">Header &lt;experimental/unordered_set&gt; synopsis</h1> <span style="float:right"><a href="#header.unordered_set.synop">[header.unordered_set.synop]</a></span></header>
      
      
<pre><code>#include &lt;unordered_set&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  template &lt;class Key,
            class Hash = hash&lt;Key&gt;,
            class Pred = equal_to&lt;Key&gt;&gt;
  using unordered_set = std::unordered_set&lt;Key, Hash, Pred,
                                           polymorphic_allocator&lt;Key&gt;&gt;;

  template &lt;class Key,
            class Hash = hash&lt;Key&gt;,
            class Pred = equal_to&lt;Key&gt;&gt;
  using unordered_multiset =
    std::unordered_multiset&lt;Key, Hash, Pred,
                            polymorphic_allocator&lt;Key&gt;&gt;;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="header.regex.synop">
    

    <section>
      <header><span class="section-number">8.11.10</span> <h1 data-bookmark-label="8.11.10 Header &lt;experimental/regex&gt; synopsis">Header &lt;experimental/regex&gt; synopsis</h1> <span style="float:right"><a href="#header.regex.synop">[header.regex.synop]</a></span></header>
      
      
<pre><code>#include &lt;regex&gt;
#include &lt;experimental/string&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace pmr {

  template &lt;class BidirectionalIterator&gt;
  using match_results =
    std::match_results&lt;BidirectionalIterator,
                       polymorphic_allocator&lt;sub_match&lt;BidirectionalIterator&gt;&gt;&gt;;

  typedef match_results&lt;const char*&gt; cmatch;
  typedef match_results&lt;const wchar_t*&gt; wcmatch;
  typedef match_results&lt;string::const_iterator&gt; smatch;
  typedef match_results&lt;wstring::const_iterator&gt; wsmatch;

} // namespace pmr
} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.observer.ptr">
    

    <section>
      <header><span class="section-number">8.12</span> <h1 data-bookmark-label="8.12 Non-owning pointers">Non-owning pointers</h1> <span style="float:right"><a href="#memory.observer.ptr">[memory.observer.ptr]</a></span></header>
      
    

    <p para_num="1" id="memory.observer.ptr.1">
      A non-owning pointer, known as an <dfn>observer</dfn>, is an object <code>o</code> that stores a pointer to a second object, <code>w</code>.
      In this context, <code>w</code> is known as a <dfn>watched</dfn> object.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    There is no watched object when the stored pointer is <code>nullptr</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      An observer takes no responsibility or ownership of any kind for its watched object, if any;
      in particular, there is no inherent relationship between the lifetimes of <code>o</code> and <code>w</code>.
    </p>

    <p para_num="2" id="memory.observer.ptr.2">
      Specializations of <code>observer_ptr</code> shall meet the requirements of a <code>CopyConstructible</code> and <code>CopyAssignable</code> type.
      The template parameter <code>W</code> of an <code>observer_ptr</code> shall not be a reference type, but may be an incomplete type.
    </p>

    <p para_num="3" id="memory.observer.ptr.3">
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The uses of <code>observer_ptr</code> include clarity of interface specification in new code,
      and interoperability with pointer-based legacy code.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <cxx-section id="memory.observer.ptr.overview">
    

    <section>
      <header><span class="section-number">8.12.1</span> <h1 data-bookmark-label="8.12.1 Class template observer_ptr overview">Class template <code>observer_ptr</code> overview</h1> <span style="float:right"><a href="#memory.observer.ptr.overview">[memory.observer.ptr.overview]</a></span></header>
      
      

<pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  template &lt;class W&gt; class observer_ptr {
  public:
    // publish our template parameter and variations thereof
    using element_type = W;
    using pointer = add_pointer_t&lt;W&gt;;            <i>// exposition-only</i>
    using reference = add_lvalue_reference_t&lt;W&gt;; <i>// exposition-only</i>

    <cxx-ref insynopsis="" to="memory.observer.ptr.ctor">// <i><a title="memory.observer.ptr.ctor" href="#memory.observer.ptr.ctor">8.12.2</a>, observer_ptr constructors</i></cxx-ref>
    // default c’tor
    constexpr observer_ptr() noexcept;

    // pointer-accepting c’tors
    constexpr observer_ptr(nullptr_t) noexcept;
    constexpr explicit observer_ptr(pointer) noexcept;

    // copying c’tors (in addition to compiler-generated copy c’tor)
    template &lt;class W2&gt; constexpr observer_ptr(observer_ptr&lt;W2&gt;) noexcept;

    <cxx-ref insynopsis="" to="memory.observer.ptr.obs">// <i><a title="memory.observer.ptr.obs" href="#memory.observer.ptr.obs">8.12.3</a>, observer_ptr observers</i></cxx-ref>
    constexpr pointer get() const noexcept;
    constexpr reference operator*() const;
    constexpr pointer operator-&gt;() const noexcept;
    constexpr explicit operator bool() const noexcept;

    <cxx-ref insynopsis="" to="memory.observer.ptr.conv">// <i><a title="memory.observer.ptr.conv" href="#memory.observer.ptr.conv">8.12.4</a>, observer_ptr conversions</i></cxx-ref>
    constexpr explicit operator pointer() const noexcept;

    <cxx-ref insynopsis="" to="memory.observer.ptr.mod">// <i><a title="memory.observer.ptr.mod" href="#memory.observer.ptr.mod">8.12.5</a>, observer_ptr modifiers</i></cxx-ref>
    constexpr pointer release() noexcept;
    constexpr void reset(pointer = nullptr) noexcept;
    constexpr void swap(observer_ptr&amp;) noexcept;
  }; // observer_ptr&lt;&gt;

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.ctor">
    

    <section>
      <header><span class="section-number">8.12.2</span> <h1 data-bookmark-label="8.12.2 observer_ptr constructors"><code>observer_ptr</code> constructors</h1> <span style="float:right"><a href="#memory.observer.ptr.ctor">[memory.observer.ptr.ctor]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.ctor.1">
    
    <pre><code><cxx-signature>constexpr observer_ptr() noexcept;</cxx-signature><cxx-signature>constexpr observer_ptr(nullptr_t) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-effects para_num="2" id="memory.observer.ptr.ctor.2">
    
    <dt>Effects:</dt><dd>Constructs an observer_ptr object that has no corresponding watched object.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="3" id="memory.observer.ptr.ctor.3">
    
    <dt>Postconditions:</dt><dd><code>get() == nullptr</code>.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="memory.observer.ptr.ctor.4">
    
    <pre><code><cxx-signature>constexpr explicit observer_ptr(pointer other) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-postconditions para_num="5" id="memory.observer.ptr.ctor.5">
    
    <dt>Postconditions:</dt><dd><code>get() == other</code>.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="memory.observer.ptr.ctor.6">
    
    <pre><code><cxx-signature>template &lt;class W2&gt; constexpr observer_ptr(observer_ptr&lt;W2&gt; other) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-postconditions para_num="7" id="memory.observer.ptr.ctor.7">
    
    <dt>Postconditions:</dt><dd><code>get() == other.get()</code>.</dd>
  </cxx-postconditions>
        <cxx-remarks para_num="8" id="memory.observer.ptr.ctor.8">
    
    <dt>Remarks:</dt><dd>This constructor shall not participate in overload resolution unless <code>W2*</code> is convertible to <code>W*</code>.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.obs">
    

    <section>
      <header><span class="section-number">8.12.3</span> <h1 data-bookmark-label="8.12.3 observer_ptr observers"><code>observer_ptr</code> observers</h1> <span style="float:right"><a href="#memory.observer.ptr.obs">[memory.observer.ptr.obs]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.obs.1">
    
    <pre><code><cxx-signature>constexpr pointer get() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="memory.observer.ptr.obs.2">
    
    <dt>Returns:</dt><dd>The stored pointer.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.observer.ptr.obs.3">
    
    <pre><code><cxx-signature>constexpr reference operator*() const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="4" id="memory.observer.ptr.obs.4">
    
    <dt>Requires:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-requires>
        <cxx-returns para_num="5" id="memory.observer.ptr.obs.5">
    
    <dt>Returns:</dt><dd><code>*get()</code>.</dd>
  </cxx-returns>
        <cxx-throws para_num="6" id="memory.observer.ptr.obs.6">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="memory.observer.ptr.obs.7">
    
    <pre><code><cxx-signature>constexpr pointer operator-&gt;() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="8" id="memory.observer.ptr.obs.8">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="memory.observer.ptr.obs.9">
    
    <pre><code><cxx-signature>constexpr explicit operator bool() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="10" id="memory.observer.ptr.obs.10">
    
    <dt>Returns:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.conv">
    

    <section>
      <header><span class="section-number">8.12.4</span> <h1 data-bookmark-label="8.12.4 observer_ptr conversions"><code>observer_ptr</code> conversions</h1> <span style="float:right"><a href="#memory.observer.ptr.conv">[memory.observer.ptr.conv]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.conv.1">
    
    <pre><code><cxx-signature>constexpr explicit operator pointer() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="memory.observer.ptr.conv.2">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.mod">
    

    <section>
      <header><span class="section-number">8.12.5</span> <h1 data-bookmark-label="8.12.5 observer_ptr modifiers"><code>observer_ptr</code> modifiers</h1> <span style="float:right"><a href="#memory.observer.ptr.mod">[memory.observer.ptr.mod]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.mod.1">
    
    <pre><code><cxx-signature>constexpr pointer release() noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-postconditions para_num="2" id="memory.observer.ptr.mod.2">
    
    <dt>Postconditions:</dt><dd><code>get() == nullptr</code>.</dd>
  </cxx-postconditions>
        <cxx-returns para_num="3" id="memory.observer.ptr.mod.3">
    
    <dt>Returns:</dt><dd>The value <code>get()</code> had at the start of the call to <code>release</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="memory.observer.ptr.mod.4">
    
    <pre><code><cxx-signature>constexpr void reset(pointer p = nullptr) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-postconditions para_num="5" id="memory.observer.ptr.mod.5">
    
    <dt>Postconditions:</dt><dd><code>get() == p</code>.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="memory.observer.ptr.mod.6">
    
    <pre><code><cxx-signature>constexpr void swap(observer_ptr&amp; other) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="7" id="memory.observer.ptr.mod.7">
    
    <dt>Effects:</dt><dd>Invokes <code>swap</code> on the stored pointers of <code>*this</code> and <code>other</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.special">
    

    <section>
      <header><span class="section-number">8.12.6</span> <h1 data-bookmark-label="8.12.6 observer_ptr specialized algorithms"><code>observer_ptr</code> specialized algorithms</h1> <span style="float:right"><a href="#memory.observer.ptr.special">[memory.observer.ptr.special]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.special.1">
    
    <pre><code><cxx-signature>template &lt;class W&gt;
void swap(observer_ptr&lt;W&gt;&amp; p1, observer_ptr&lt;W&gt;&amp; p2) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="memory.observer.ptr.special.2">
    
    <dt>Effects:</dt><dd><code>p1.swap(p2)</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.observer.ptr.special.3">
    
    <pre><code><cxx-signature>template &lt;class W&gt; observer_ptr&lt;W&gt; make_observer(W* p) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="4" id="memory.observer.ptr.special.4">
    
    <dt>Returns:</dt><dd><code>observer_ptr&lt;W&gt;{p}</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="memory.observer.ptr.special.5">
    
    <pre><code><cxx-signature>template &lt;class W1, class W2&gt;
bool operator==(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="6" id="memory.observer.ptr.special.6">
    
    <dt>Returns:</dt><dd><code>p1.get() == p2.get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="memory.observer.ptr.special.7">
    
    <pre><code><cxx-signature>template &lt;class W1, class W2&gt;
bool operator!=(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="8" id="memory.observer.ptr.special.8">
    
    <dt>Returns:</dt><dd><code>not (p1 == p2)</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="memory.observer.ptr.special.9">
    
    <pre><code><cxx-signature>template &lt;class W&gt;
bool operator==(observer_ptr&lt;W&gt; p, nullptr_t) noexcept;</cxx-signature><cxx-signature>template &lt;class W&gt;
bool operator==(nullptr_t, observer_ptr&lt;W&gt; p) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-returns para_num="10" id="memory.observer.ptr.special.10">
    
    <dt>Returns:</dt><dd><code>not p</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="11" id="memory.observer.ptr.special.11">
    
    <pre><code><cxx-signature>template &lt;class W&gt;
bool operator!=(observer_ptr&lt;W&gt; p, nullptr_t) noexcept;</cxx-signature><cxx-signature>template &lt;class W&gt;
bool operator!=(nullptr_t, observer_ptr&lt;W&gt; p) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-returns para_num="12" id="memory.observer.ptr.special.12">
    
    <dt>Returns:</dt><dd><code>(bool)p</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="13" id="memory.observer.ptr.special.13">
    
    <pre><code><cxx-signature>template &lt;class W1, class W2&gt;
bool operator&lt;(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="14" id="memory.observer.ptr.special.14">
    
    <dt>Returns:</dt><dd>
          <code>less&lt;W3&gt;()(p1.get(), p2.get())</code>,
          where <code>W3</code> is the composite pointer type (<cxx-ref in="cxx" to="expr">C++14 <span title="expr">§5</span></cxx-ref>) of <code>W1*</code> and <code>W2*</code>.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="15" id="memory.observer.ptr.special.15">
    
    <pre><code><cxx-signature>template &lt;class W1, class W2&gt;
bool operator&gt;(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="16" id="memory.observer.ptr.special.16">
    
    <dt>Returns:</dt><dd><code>p2 &lt; p1</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="17" id="memory.observer.ptr.special.17">
    
    <pre><code><cxx-signature>template &lt;class W1, class W2&gt;
bool operator&lt;=(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

         <cxx-returns para_num="18" id="memory.observer.ptr.special.18">
    
    <dt>Returns:</dt><dd><code>not (p2 &lt; p1)</code>.</dd>
  </cxx-returns>
        
    </dl>
  </cxx-function>

      <cxx-function para_num="19" id="memory.observer.ptr.special.19">
    
    <pre><code><cxx-signature>template &lt;class W1, class W2&gt;
bool operator&gt;=(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="20" id="memory.observer.ptr.special.20">
    
    <dt>Returns:</dt><dd><code>not (p1 &lt; p2)</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.hash">
    

    <section>
      <header><span class="section-number">8.12.7</span> <h1 data-bookmark-label="8.12.7 observer_ptr hash support"><code>observer_ptr</code> hash support</h1> <span style="float:right"><a href="#memory.observer.ptr.hash">[memory.observer.ptr.hash]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.hash.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; struct hash&lt;experimental::observer_ptr&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="memory.observer.ptr.hash.2">
          The template specialization shall meet the requirements of class template <code>hash</code> (<cxx-ref in="cxx" to="unord.hash">C++14 <span title="unord.hash">§20.9.12</span></cxx-ref>).
          For an object <code>p</code> of type <code>observer_ptr&lt;T&gt;</code>,
          <code>hash&lt;observer_ptr&lt;T&gt;&gt;()(p)</code> shall evaluate to the same value as <code>hash&lt;T*&gt;()(p.get())</code>.
        </p>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="container">
    

    <section>
      <header><span class="section-number">9</span> <h1 data-bookmark-label="9 Containers">Containers</h1> <span style="float:right"><a href="#container">[container]</a></span></header>
      
  

  <cxx-section id="container.erasure">
    

    <section>
      <header><span class="section-number">9.1</span> <h1 data-bookmark-label="9.1 Uniform container erasure">Uniform container erasure</h1> <span style="float:right"><a href="#container.erasure">[container.erasure]</a></span></header>
      
    

    <cxx-section id="container.erasure.syn">
    

    <section>
      <header><span class="section-number">9.1.1</span> <h1 data-bookmark-label="9.1.1 Header synopsis">Header synopsis</h1> <span style="float:right"><a href="#container.erasure.syn">[container.erasure.syn]</a></span></header>
      
      

      <p para_num="1" id="container.erasure.syn.1">
        For brevity, this section specifies the contents of 9 headers,
        each of which behaves as described by <cxx-ref to="general.namespaces"><a title="general.namespaces" href="#general.namespaces">1.3</a></cxx-ref>.
      </p>

<pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="container.erasure.erase_if">// <i><a title="container.erasure.erase_if" href="#container.erasure.erase_if">9.1.2</a>, Function template erase_if</i></cxx-ref>
  <cxx-ref insynopsis="" to="container.erasure.erase">// <i><a title="container.erasure.erase" href="#container.erasure.erase">9.1.3</a>, Function template erase</i></cxx-ref>

  // &lt;experimental/string&gt;
  template &lt;class charT, class traits, class A, class Predicate&gt;
    void erase_if(basic_string&lt;charT, traits, A&gt;&amp; c, Predicate pred);
  template &lt;class charT, class traits, class A, class U&gt;
    void erase(basic_string&lt;charT, traits, A&gt;&amp; c, const U&amp; value);

  // &lt;experimental/deque&gt;
  template &lt;class T, class A, class Predicate&gt;
    void erase_if(deque&lt;T, A&gt;&amp; c, Predicate pred);
  template &lt;class T, class A, class U&gt;
    void erase(deque&lt;T, A&gt;&amp; c, const U&amp; value);

  // &lt;experimental/vector&gt;
  template &lt;class T, class A, class Predicate&gt;
    void erase_if(vector&lt;T, A&gt;&amp; c, Predicate pred);
  template &lt;class T, class A, class U&gt;
    void erase(vector&lt;T, A&gt;&amp; c, const U&amp; value);

  // &lt;experimental/forward_list&gt;
  template &lt;class T, class A, class Predicate&gt;
    void erase_if(forward_list&lt;T, A&gt;&amp; c, Predicate pred);
  template &lt;class T, class A, class U&gt;
    void erase(forward_list&lt;T, A&gt;&amp; c, const U&amp; value);

  // &lt;experimental/list&gt;
  template &lt;class T, class A, class Predicate&gt;
    void erase_if(list&lt;T, A&gt;&amp; c, Predicate pred);
  template &lt;class T, class A, class U&gt;
    void erase(list&lt;T, A&gt;&amp; c, const U&amp; value);

  // &lt;experimental/map&gt;
  template &lt;class K, class T, class C, class A, class Predicate&gt;
    void erase_if(map&lt;K, T, C, A&gt;&amp; c, Predicate pred);
  template &lt;class K, class T, class C, class A, class Predicate&gt;
    void erase_if(multimap&lt;K, T, C, A&gt;&amp; c, Predicate pred);

  // &lt;experimental/set&gt;
  template &lt;class K, class C, class A, class Predicate&gt;
    void erase_if(set&lt;K, C, A&gt;&amp; c, Predicate pred);
  template &lt;class K, class C, class A, class Predicate&gt;
    void erase_if(multiset&lt;K, C, A&gt;&amp; c, Predicate pred);

  // &lt;experimental/unordered_map&gt;
  template &lt;class K, class T, class H, class P, class A, class Predicate&gt;
    void erase_if(unordered_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
  template &lt;class K, class T, class H, class P, class A, class Predicate&gt;
    void erase_if(unordered_multimap&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);

  // &lt;experimental/unordered_set&gt;
  template &lt;class K, class H, class P, class A, class Predicate&gt;
    void erase_if(unordered_set&lt;K, H, P, A&gt;&amp; c, Predicate pred);
  template &lt;class K, class H, class P, class A, class Predicate&gt;
    void erase_if(unordered_multiset&lt;K, H, P, A&gt;&amp; c, Predicate pred);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="container.erasure.erase_if">
    

    <section>
      <header><span class="section-number">9.1.2</span> <h1 data-bookmark-label="9.1.2 Function template erase_if">Function template <code>erase_if</code></h1> <span style="float:right"><a href="#container.erasure.erase_if">[container.erasure.erase_if]</a></span></header>
      
      

      <cxx-function para_num="1" id="container.erasure.erase_if.1">
    
    <pre><code><cxx-signature>template &lt;class charT, class traits, class A, class Predicate&gt;
void erase_if(basic_string&lt;charT, traits, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class T, class A, class Predicate&gt;
void erase_if(deque&lt;T, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class T, class A, class Predicate&gt;
void erase_if(vector&lt;T, A&gt;&amp; c, Predicate pred);</cxx-signature></code></pre>

    <dl>
      
        
        
        
        <cxx-effects para_num="2" id="container.erasure.erase_if.2">
    
    <dt>Effects:</dt><dd>Equivalent to: <code>c.erase(remove_if(c.begin(), c.end(), pred), c.end());</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="container.erasure.erase_if.3">
    
    <pre><code><cxx-signature>template &lt;class T, class A, class Predicate&gt;
void erase_if(forward_list&lt;T, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class T, class A, class Predicate&gt;
void erase_if(list&lt;T, A&gt;&amp; c, Predicate pred);</cxx-signature></code></pre>

    <dl>
      
        
        
        <cxx-effects para_num="4" id="container.erasure.erase_if.4">
    
    <dt>Effects:</dt><dd>Equivalent to: <code>c.remove_if(pred);</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="container.erasure.erase_if.5">
    
    <pre><code><cxx-signature>template &lt;class K, class T, class C, class A, class Predicate&gt;
void erase_if(map&lt;K, T, C, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class T, class C, class A, class Predicate&gt;
void erase_if(multimap&lt;K, T, C, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class C, class A, class Predicate&gt;
void erase_if(set&lt;K, C, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class C, class A, class Predicate&gt;
void erase_if(multiset&lt;K, C, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class T, class H, class P, class A, class Predicate&gt;
void erase_if(unordered_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class T, class H, class P, class A, class Predicate&gt;
void erase_if(unordered_multimap&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class H, class P, class A, class Predicate&gt;
void erase_if(unordered_set&lt;K, H, P, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class H, class P, class A, class Predicate&gt;
void erase_if(unordered_multiset&lt;K, H, P, A&gt;&amp; c, Predicate pred);</cxx-signature></code></pre>

    <dl>
      
        
        
        
        
        
        
        
        
        <cxx-effects para_num="6" id="container.erasure.erase_if.6">
    
    <dt>Effects:</dt><dd>Equivalent to:
<pre><code>for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}</code></pre></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="container.erasure.erase">
    

    <section>
      <header><span class="section-number">9.1.3</span> <h1 data-bookmark-label="9.1.3 Function template erase">Function template erase</h1> <span style="float:right"><a href="#container.erasure.erase">[container.erasure.erase]</a></span></header>
      
      

      <cxx-function para_num="1" id="container.erasure.erase.1">
    
    <pre><code><cxx-signature>template &lt;class charT, class traits, class A, class U&gt;
void erase(basic_string&lt;charT, traits, A&gt;&amp; c, const U&amp; value);</cxx-signature><cxx-signature>template &lt;class T, class A, class U&gt;
void erase(deque&lt;T, A&gt;&amp; c, const U&amp; value);</cxx-signature><cxx-signature>template &lt;class T, class A, class U&gt;
void erase(vector&lt;T, A&gt;&amp; c, const U&amp; value);</cxx-signature></code></pre>

    <dl>
      
        
        
        
        <cxx-effects para_num="2" id="container.erasure.erase.2">
    
    <dt>Effects:</dt><dd>Equivalent to: <code>c.erase(remove(c.begin(), c.end(), value), c.end());</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="container.erasure.erase.3">
    
    <pre><code><cxx-signature>template &lt;class T, class A, class U&gt;
void erase(forward_list&lt;T, A&gt;&amp; c, const U&amp; value);</cxx-signature><cxx-signature>template &lt;class T, class A, class U&gt;
void erase(list&lt;T, A&gt;&amp; c, const U&amp; value);</cxx-signature></code></pre>

    <dl>
      
        
        
        <cxx-effects para_num="4" id="container.erasure.erase.4">
    
    <dt>Effects:</dt><dd>Equivalent to: <code>erase_if(c, [&amp;](auto&amp; elem) { return elem == value; });</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        Overloads of <code>erase()</code> for associative containers and unordered associative containers are intentionally not provided.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="container.array">
    

    <section>
      <header><span class="section-number">9.2</span> <h1 data-bookmark-label="9.2 Class template array">Class template <code>array</code></h1> <span style="float:right"><a href="#container.array">[container.array]</a></span></header>
      
    

    <cxx-section id="header.array.synop">
    

    <section>
      <header><span class="section-number">9.2.1</span> <h1 data-bookmark-label="9.2.1 Header &lt;experimental/array&gt; synopsis">Header &lt;experimental/array&gt; synopsis</h1> <span style="float:right"><a href="#header.array.synop">[header.array.synop]</a></span></header>
      
      

      <pre><code>#include &lt;array&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="container.array.creation">// <i><a title="container.array.creation" href="#container.array.creation">9.2.2</a>, Array creation functions</i></cxx-ref>
  template &lt;class D = void, class... Types&gt;
    constexpr array&lt;<i>VT</i>, sizeof...(Types)&gt; make_array(Types&amp;&amp;... t);
  template &lt;class T, size_t N&gt;
    constexpr array&lt;remove_cv_t&lt;T&gt;, N&gt; to_array(T (&amp;a)[N]);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="container.array.creation">
    

    <section>
      <header><span class="section-number">9.2.2</span> <h1 data-bookmark-label="9.2.2 Array creation functions">Array creation functions</h1> <span style="float:right"><a href="#container.array.creation">[container.array.creation]</a></span></header>
      
      

      <cxx-function para_num="1" id="container.array.creation.1">
    
    <pre><code><cxx-signature>template &lt;class D = void, class... Types&gt;
&nbsp;&nbsp;constexpr array&lt;<i>VT</i>, sizeof...(Types)&gt; make_array(Types&amp;&amp;... t);</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="container.array.creation.2">
          Let <em>Ui</em> be <code>decay_t&lt;</code><em>Ti</em><code>&gt;</code> for each <em>Ti</em> in <code>Types</code>.
        </p>
        <cxx-remarks para_num="3" id="container.array.creation.3">
    
    <dt>Remarks:</dt><dd>
          The program is ill-formed if <code>D</code> is <code>void</code> and at least one <em>Ui</em> is a specialization of <code>reference_wrapper</code>.
        </dd>
  </cxx-remarks>
        <cxx-returns para_num="4" id="container.array.creation.4">
    
    <dt>Returns:</dt><dd>
          <code>array&lt;<var>VT</var>, sizeof...(Types)&gt;{ std::forward&lt;Types&gt;(t)... }</code>, where <code><var>VT</var></code> is <code>common_type_t&lt;Types...&gt;</code> if <code>D</code> is <code>void</code>, otherwise <code><var>VT</var></code> is <code>D</code>.
        </dd>
  </cxx-returns>

        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
<pre><code>int i = 1; int&amp; ri = i;
auto a1 = make_array(i, ri);         // a1<i> is of type </i>array&lt;int, 2&gt;
auto a2 = make_array(i, ri, 42L);    // a2<i> is of type </i>array&lt;long, 3&gt;
auto a3 = make_array&lt;long&gt;(i, ri);   // a3<i> is of type </i>array&lt;long, 2&gt;
auto a4 = make_array&lt;long&gt;();        // a4<i> is of type </i>array&lt;long, 0&gt;
auto a5 = make_array();              // <i>ill-formed</i></code></pre>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="container.array.creation.5">
    
    <pre><code><cxx-signature>template &lt;class T, size_t N&gt;
constexpr array&lt;remove_cv_t&lt;T&gt;, N&gt; to_array(T (&amp;a)[N]);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="6" id="container.array.creation.6">
    
    <dt>Returns:</dt><dd>
          An <code>array&lt;remove_cv_t&lt;T&gt;, N&gt;</code> such that each element is copy-initialized with the corresponding element of <code>a</code>.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="iterator">
    

    <section>
      <header><span class="section-number">10</span> <h1 data-bookmark-label="10 Iterators library">Iterators library</h1> <span style="float:right"><a href="#iterator">[iterator]</a></span></header>
      
  

  <cxx-section id="iterator.synopsis">
    

    <section>
      <header><span class="section-number">10.1</span> <h1 data-bookmark-label="10.1 Header &lt;experimental/iterator&gt; synopsis">Header <code>&lt;experimental/iterator&gt;</code> synopsis</h1> <span style="float:right"><a href="#iterator.synopsis">[iterator.synopsis]</a></span></header>
      
    

<pre><code>#include &lt;iterator&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="iterator.ostream.joiner">// <i><a title="iterator.ostream.joiner" href="#iterator.ostream.joiner">10.2</a>, Class template ostream_joiner</i></cxx-ref>
  template &lt;class DelimT, class charT = char, class traits = char_traits&lt;charT&gt; &gt;
      class ostream_joiner;
  template &lt;class charT, class traits, class DelimT&gt;
    ostream_joiner&lt;decay_t&lt;DelimT&gt;, charT, traits&gt;
    make_ostream_joiner(basic_ostream&lt;charT, traits&gt;&amp; os, DelimT&amp;&amp; delimiter);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
  
    </section>
  </cxx-section>

  <cxx-section id="iterator.ostream.joiner">
    

    <section>
      <header><span class="section-number">10.2</span> <h1 data-bookmark-label="10.2 Class template ostream_joiner">Class template <code>ostream_joiner</code></h1> <span style="float:right"><a href="#iterator.ostream.joiner">[iterator.ostream.joiner]</a></span></header>
      
    

    <p para_num="1" id="iterator.ostream.joiner.1">
      <code>ostream_joiner</code> writes (using <code>operator&lt;&lt;</code>) successive elements onto the output stream from which it was constructed.
      The delimiter that it was constructed with is written to the stream between every two <code>T</code>s that are written.
      It is not possible to get a value out of the output iterator.
      Its only use is as an output iterator in situations like
    </p>
    <pre><code>while (first != last)
  *result++ = *first++;</code></pre>

  <p para_num="2" id="iterator.ostream.joiner.2">
    <code>ostream_joiner</code> is defined as
  </p>
<pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  template &lt;class DelimT, class charT = char, class traits = char_traits&lt;charT&gt; &gt;
  class ostream_joiner {
  public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_ostream&lt;charT, traits&gt; ostream_type;
    typedef output_iterator_tag iterator_category;
    typedef void value_type;
    typedef void difference_type;
    typedef void pointer;
    typedef void reference;

    ostream_joiner(ostream_type&amp; s, const DelimT&amp; delimiter);
    ostream_joiner(ostream_type&amp; s, DelimT&amp;&amp; delimiter);
    template&lt;typename T&gt;
    ostream_joiner&amp; operator=(const T&amp; value);
    ostream_joiner&amp; operator*() noexcept;
    ostream_joiner&amp; operator++() noexcept;
    ostream_joiner&amp; operator++(int) noexcept;
  private:
    ostream_type* out_stream; <i>// exposition only</i>
    DelimT delim;             <i>// exposition only</i>
    bool first_element;       <i>// exposition only</i>
  };
} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>

    <cxx-section id="iterator.ostream.joiner.cons">
    

    <section>
      <header><span class="section-number">10.2.1</span> <h1 data-bookmark-label="10.2.1 ostream_joiner constructor"><code>ostream_joiner</code> constructor</h1> <span style="float:right"><a href="#iterator.ostream.joiner.cons">[iterator.ostream.joiner.cons]</a></span></header>
      
      

      <cxx-function para_num="1" id="iterator.ostream.joiner.cons.1">
    
    <pre><code><cxx-signature>ostream_joiner(ostream_type&amp; s, const DelimT&amp; delimiter);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="iterator.ostream.joiner.cons.2">
    
    <dt>Effects:</dt><dd>
          Initializes <code>out_stream</code> with <code>std::addressof(s)</code>,
          <code>delim</code> with <code>delimiter</code>,
          and <code>first_element</code> with <code>true</code>.
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="iterator.ostream.joiner.cons.3">
    
    <pre><code><cxx-signature>ostream_joiner(ostream_type&amp; s, DelimT&amp;&amp; delimiter);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="4" id="iterator.ostream.joiner.cons.4">
    
    <dt>Effects:</dt><dd>
          Initializes <code>out_stream</code> with <code>std::addressof(s)</code>,
          <code>delim</code> with <code>move(delimiter)</code>,
          and <code>first_element</code> with <code>true</code>.
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="iterator.ostream.joiner.ops">
    

    <section>
      <header><span class="section-number">10.2.2</span> <h1 data-bookmark-label="10.2.2 ostream_joiner operations"><code>ostream_joiner</code> operations</h1> <span style="float:right"><a href="#iterator.ostream.joiner.ops">[iterator.ostream.joiner.ops]</a></span></header>
      
      

      <cxx-function para_num="1" id="iterator.ostream.joiner.ops.1">
    
    <pre><code><cxx-signature>template&lt;typename T&gt;
ostream_joiner&amp; operator=(const T&amp; value);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="iterator.ostream.joiner.ops.2">
    
    <dt>Effects:</dt><dd>
          <pre style="clear:left"><code>if (!first_element)
  *out_stream &lt;&lt; delim;
first_element = false;
*out_stream &lt;&lt; value;
return *this;</code></pre>
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="iterator.ostream.joiner.ops.3">
    
    <pre><code><cxx-signature>ostream_joiner&amp; operator*() noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="4" id="iterator.ostream.joiner.ops.4">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="iterator.ostream.joiner.ops.5">
    
    <pre><code><cxx-signature>ostream_joiner&amp; operator++() noexcept;</cxx-signature><cxx-signature>ostream_joiner&amp; operator++(int) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-returns para_num="6" id="iterator.ostream.joiner.ops.6">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="iterator.ostream.joiner.creation">
    

    <section>
      <header><span class="section-number">10.2.3</span> <h1 data-bookmark-label="10.2.3 ostream_joiner creation function"><code>ostream_joiner</code> creation function</h1> <span style="float:right"><a href="#iterator.ostream.joiner.creation">[iterator.ostream.joiner.creation]</a></span></header>
      
      

      <cxx-function para_num="1" id="iterator.ostream.joiner.creation.1">
    
    <pre><code><cxx-signature>template &lt;class charT, class traits, class DelimT&gt;
ostream_joiner&lt;decay_t&lt;DelimT&gt;, charT, traits&gt;
make_ostream_joiner(basic_ostream&lt;charT, traits&gt;&amp; os, DelimT&amp;&amp; delimiter);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="iterator.ostream.joiner.creation.2">
    
    <dt>Returns:</dt><dd><code>ostream_joiner&lt;decay_t&lt;DelimT&gt;, charT, traits&gt;(os, forward&lt;DelimT&gt;(delimiter));</code></dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="futures">
    

    <section>
      <header><span class="section-number">11</span> <h1 data-bookmark-label="11 Futures">Futures</h1> <span style="float:right"><a href="#futures">[futures]</a></span></header>
      
  

  <cxx-section id="header.future.synop">
    

    <section>
      <header><span class="section-number">11.1</span> <h1 data-bookmark-label="11.1 Header &lt;experimental/future&gt; synopsis">Header &lt;experimental/future&gt; synopsis</h1> <span style="float:right"><a href="#header.future.synop">[header.future.synop]</a></span></header>
      
    

    

    <pre><code>#include &lt;future&gt;

namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    template &lt;class R&gt; class promise;
    template &lt;class R&gt; class promise&lt;R&amp;&gt;;
    template &lt;&gt; class promise&lt;void&gt;;

    template &lt;class R&gt;
    void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y) noexcept;

    template &lt;class&gt; class packaged_task; // undefined
    template &lt;class R, class... ArgTypes&gt;
    class packaged_task&lt;R(ArgTypes...)&gt;;

    template &lt;class R, class... ArgTypes&gt;
    void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp;, packaged_task&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  } // namespace fundamentals_v2
  } // namespace experimental

  template &lt;class R, class Alloc&gt;
  struct uses_allocator&lt;experimental::promise&lt;R&gt;, Alloc&gt;;

  template &lt;class R, class Alloc&gt;
  struct uses_allocator&lt;experimental::packaged_task&lt;R&gt;, Alloc&gt;;

} // namespace std</code></pre>
  
    </section>
  </cxx-section>
  <cxx-section id="futures.promise">
    

    <section>
      <header><span class="section-number">11.2</span> <h1 data-bookmark-label="11.2 Class template promise">Class template <code>promise</code></h1> <span style="float:right"><a href="#futures.promise">[futures.promise]</a></span></header>
      
    

    <p para_num="1" id="futures.promise.1">
      The specification of all declarations within this sub-clause <cxx-ref to="futures.promise"><a title="futures.promise" href="#futures.promise">11.2</a></cxx-ref>
      and its sub-clauses are the same as the corresponding declarations,
      as specified in <cxx-ref in="cxx" to="futures.promise">C++14 <span title="futures.promise">§30.6.5</span></cxx-ref>,
      unless explicitly specified otherwise.
    </p>

    <pre><code>namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    template &lt;class R&gt;
    class promise {
    public:
      typedef erased_type allocator_type;

      promise();
      template &lt;class Allocator&gt;
      promise(allocator_arg_t, const Allocator&amp; a);
      promise(promise&amp;&amp; rhs) noexcept;
      promise(const promise&amp; rhs) = delete;
      ~promise();

      promise&amp; operator=(promise&amp;&amp; rhs) noexcept;
      promise&amp; operator=(const promise&amp; rhs) = delete;
      void swap(promise&amp; other) noexcept;

      future&lt;R&gt; get_future();

      void set_value(<em>see below</em>);
      void set_exception(exception_ptr p);

      void set_value_at_thread_exit(const R&amp; r);
      void set_value_at_thread_exit(<em>see below</em>);
      void set_exception_at_thread_exit(exception_ptr p);

      pmr::memory_resource* get_memory_resource();
    };

    template &lt;class R&gt;
    void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y) noexcept;

  } // namespace fundamentals_v2
  } // namespace experimental

  template &lt;class R, class Alloc&gt;
  struct uses_allocator&lt;experimental::promise&lt;R&gt;, Alloc&gt;;

} // namespace std</code></pre>

    <p para_num="2" id="futures.promise.2">
      When a <code>promise</code> constructor that takes a first argument of type <code>allocator_arg_t</code> is invoked,
      the second argument is treated as a type-erased allocator (<cxx-ref to="memory.type.erased.allocator"><a title="memory.type.erased.allocator" href="#memory.type.erased.allocator">8.3</a></cxx-ref>).
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="futures.task">
    

    <section>
      <header><span class="section-number">11.3</span> <h1 data-bookmark-label="11.3 Class template packaged_task">Class template <code>packaged_task</code></h1> <span style="float:right"><a href="#futures.task">[futures.task]</a></span></header>
      
    

    <p para_num="1" id="futures.task.1">
      The specification of all declarations within this sub-clause <cxx-ref to="futures.task"><a title="futures.task" href="#futures.task">11.3</a></cxx-ref>
      and its sub-clauses are the same as the corresponding declarations,
      as specified in <cxx-ref in="cxx" to="futures.task">C++14 <span title="futures.task">§30.6.9</span></cxx-ref>,
      unless explicitly specified otherwise.
    </p>

    <pre><code>namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    template &lt;class R, class... ArgTypes&gt;
    class packaged_task&lt;R(ArgTypes...)&gt; {
    public:
      typedef erased_type allocator_type;

      packaged_task() noexcept;
      template &lt;class F&gt;
      explicit packaged_task(F&amp;&amp; f);
      template &lt;class F, class Allocator&gt;
      explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
      ~packaged_task();

      packaged_task(const packaged_task&amp;) = delete;
      packaged_task&amp; operator=(const packaged_task&amp;) = delete;

      packaged_task(packaged_task&amp;&amp; rhs) noexcept;
      packaged_task&amp; operator=(packaged_task&amp;&amp; rhs) noexcept;
      void swap(packaged_task&amp; other) noexcept;

      bool valid() const noexcept;

      future&lt;R&gt; get_future();

      void operator()(ArgTypes... );
      void make_ready_at_thread_exit(ArgTypes...);

      void reset();

      pmr::memory_resource* get_memory_resource();
    };

    template &lt;class R, class... ArgTypes&gt;
    void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp;, packaged_task&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  } // namespace fundamentals_v2
  } // namespace experimental

  template &lt;class R, class Alloc&gt;
  struct uses_allocator&lt;experimental::packaged_task&lt;R&gt;, Alloc&gt;;

} // namespace std</code></pre>

    <p para_num="2" id="futures.task.2">
      When a <code>packaged_task</code> constructor that takes a first argument of type <code>allocator_arg_t</code> is invoked,
      the second argument is treated as a type-erased allocator (<cxx-ref to="memory.type.erased.allocator"><a title="memory.type.erased.allocator" href="#memory.type.erased.allocator">8.3</a></cxx-ref>).
    </p>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="algorithms">
    

    <section>
      <header><span class="section-number">12</span> <h1 data-bookmark-label="12 Algorithms library">Algorithms library</h1> <span style="float:right"><a href="#algorithms">[algorithms]</a></span></header>
      
  

  <cxx-section id="header.algorithm.synop">
    

    <section>
      <header><span class="section-number">12.1</span> <h1 data-bookmark-label="12.1 Header &lt;experimental/algorithm&gt; synopsis">Header <code>&lt;experimental/algorithm&gt;</code> synopsis</h1> <span style="float:right"><a href="#header.algorithm.synop">[header.algorithm.synop]</a></span></header>
      
    

<pre><code>#include &lt;algorithm&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="alg.search">// <i><a title="alg.search" href="#alg.search">12.2</a>, Search</i></cxx-ref>
  template&lt;class ForwardIterator, class Searcher&gt;
  ForwardIterator search(ForwardIterator first, ForwardIterator last,
                         const Searcher&amp; searcher);

  <cxx-ref insynopsis="" to="alg.random.sample">// <i><a title="alg.random.sample" href="#alg.random.sample">12.3</a>, Sampling</i></cxx-ref>
  template&lt;class PopulationIterator, class SampleIterator, class Distance&gt;
  SampleIterator sample(PopulationIterator first, PopulationIterator last,
                        SampleIterator out, Distance n);

  template&lt;class PopulationIterator, class SampleIterator,
           class Distance, class UniformRandomNumberGenerator&gt;
  SampleIterator sample(PopulationIterator first, PopulationIterator last,
                        SampleIterator out, Distance n,
                        UniformRandomNumberGenerator&amp;&amp; g);

  <cxx-ref insynopsis="" to="alg.random.shuffle">// <i><a title="alg.random.shuffle" href="#alg.random.shuffle">12.4</a>, Shuffle</i></cxx-ref>
  template&lt;class RandomAccessIterator&gt;
  void shuffle(RandomAccessIterator first, RandomAccessIterator last);

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>

  
    </section>
  </cxx-section>

  <cxx-section id="alg.search">
    

    <section>
      <header><span class="section-number">12.2</span> <h1 data-bookmark-label="12.2 Search">Search</h1> <span style="float:right"><a href="#alg.search">[alg.search]</a></span></header>
      
    

    <cxx-function para_num="1" id="alg.search.1">
    
    <pre><code><cxx-signature>template&lt;class ForwardIterator, class Searcher&gt;
ForwardIterator search(ForwardIterator first, ForwardIterator last,
                       const Searcher&amp; searcher);</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="2" id="alg.search.2">
    
    <dt>Effects:</dt><dd>Equivalent to <code>return searcher(first, last);</code></dd>
  </cxx-effects>
      <cxx-remarks para_num="3" id="alg.search.3">
    
    <dt>Remarks:</dt><dd><code>Searcher</code> need not meet the <code>CopyConstructible</code> requirements.</dd>
  </cxx-remarks>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="alg.random.sample">
    

    <section>
      <header><span class="section-number">12.3</span> <h1 data-bookmark-label="12.3 Sampling">Sampling</h1> <span style="float:right"><a href="#alg.random.sample">[alg.random.sample]</a></span></header>
      
    

    <cxx-function para_num="1" id="alg.random.sample.1">
    
    <pre><code><cxx-signature class="formatted">template&lt;class PopulationIterator, class SampleIterator, class Distance&gt;
SampleIterator sample(PopulationIterator first, PopulationIterator last,
                      SampleIterator out, Distance n);

template&lt;class PopulationIterator, class SampleIterator,
         class Distance, class UniformRandomNumberGenerator&gt;
SampleIterator sample(PopulationIterator first, PopulationIterator last,
                      SampleIterator out, Distance n,
                      UniformRandomNumberGenerator&amp;&amp; g);</cxx-signature></code></pre>

    <dl>
      
      


      <cxx-requires para_num="2" id="alg.random.sample.2">
    
    <dt>Requires:</dt><dd>
        <ul>
          <li><code>PopulationIterator</code> shall meet the requirements of an <code>InputIterator</code> type.</li>
          <li><code>SampleIterator</code> shall meet the requirements of an <code>OutputIterator</code> type.</li>
          <li><code>SampleIterator</code> shall meet the additional requirements of a <code>RandomAccessIterator</code> type
          unless <code>PopulationIterator</code> meets the additional requirements of a <code>ForwardIterator</code> type.</li>
          <li><code>PopulationIterator</code>'s value type shall be writable to <code>out</code>.</li>
          <li><code>Distance</code> shall be an integer type.</li>
          <li><code>UniformRandomNumberGenerator</code> shall meet the requirements of a uniform random number generator type (<cxx-ref in="cxx" to="rand.req.urng">C++14 <span title="rand.req.urng">§26.5.1.3</span></cxx-ref>)
          whose return type is convertible to <code>Distance</code>.</li>
          <li><code>out</code> shall not be in the range <cxx-range begin="first" end="last">[<code>first</code>, <code>last</code>)</cxx-range>.</li>
        </ul>
      </dd>
  </cxx-requires>
      <cxx-effects para_num="3" id="alg.random.sample.3">
    
    <dt>Effects:</dt><dd>Copies <code>min(last−first, n)</code> elements (the <dfn>sample</dfn>)
      from <cxx-range begin="first" end="last">[<code>first</code>, <code>last</code>)</cxx-range> (the <dfn>population</dfn>) to <code>out</code>
      such that each possible sample has equal probability of appearance.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Algorithms that obtain such effects include <cxx-term><i>selection sampling</i></cxx-term> and <cxx-term><i>reservoir sampling</i></cxx-term>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></dd>
  </cxx-effects>
      <cxx-returns para_num="4" id="alg.random.sample.4">
    
    <dt>Returns:</dt><dd>The end of the resulting sample range.</dd>
  </cxx-returns>
      <cxx-complexity para_num="5" id="alg.random.sample.5">
    
    <dt>Complexity:</dt><dd>O(<code>last - first</code>).</dd>
  </cxx-complexity>
      <cxx-remarks para_num="6" id="alg.random.sample.6">
    
    <dt>Remarks:</dt><dd>
        <ul>
          <li>Stable if and only if <code>PopulationIterator</code> meets the
            requirements of a <code>ForwardIterator</code> type.</li>
          <li>If <code>g</code> is not given in the argument list, it denotes
            the per-thread engine (<cxx-ref to="rand.util.randint"><a title="rand.util.randint" href="#rand.util.randint">13.2.2.1</a></cxx-ref>).
            To the extent that the implementation of this function makes use of
            random numbers, the object <code>g</code> shall serve as the
            implementation’s source of randomness.</li>
        </ul>
      </dd>
  </cxx-remarks>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>
  <cxx-section id="alg.random.shuffle">
    

    <section>
      <header><span class="section-number">12.4</span> <h1 data-bookmark-label="12.4 Shuffle">Shuffle</h1> <span style="float:right"><a href="#alg.random.shuffle">[alg.random.shuffle]</a></span></header>
      
    
    <cxx-function para_num="1" id="alg.random.shuffle.1">
    
    <pre><code><cxx-signature>template&lt;class RandomAccessIterator&gt;
  void shuffle(RandomAccessIterator first, RandomAccessIterator last);</cxx-signature></code></pre>

    <dl>
      
      
      <cxx-effects para_num="2" id="alg.random.shuffle.2">
    
    <dt>Effects:</dt><dd>Permutes the elements in the range <code>[first,last)</code>
        such that each possible permutation of those elements has equal
        probability of appearance.</dd>
  </cxx-effects>
      <cxx-requires para_num="3" id="alg.random.shuffle.3">
    
    <dt>Requires:</dt><dd><code>RandomAccessIterator</code> shall satisfy the
        requirements of <code>ValueSwappable</code> (<cxx-ref in="cxx" to="swappable.requirements">C++14 <span title="swappable.requirements">§17.6.3.2</span></cxx-ref>).</dd>
  </cxx-requires>
      <cxx-complexity para_num="4" id="alg.random.shuffle.4">
    
    <dt>Complexity:</dt><dd>Exactly <code>(last - first) - 1</code> swaps.</dd>
  </cxx-complexity>
      <cxx-remarks para_num="5" id="alg.random.shuffle.5">
    
    <dt>Remarks:</dt><dd>To the extent that the implementation of this function
        makes use of random numbers, the per-thread engine (<cxx-ref to="rand.util.randint"><a title="rand.util.randint" href="#rand.util.randint">13.2.2.1</a></cxx-ref>)
        shall serve as the implementation's source of randomness.</dd>
  </cxx-remarks>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="numeric">
    

    <section>
      <header><span class="section-number">13</span> <h1 data-bookmark-label="13 Numerics library">Numerics library</h1> <span style="float:right"><a href="#numeric">[numeric]</a></span></header>
      
  

  <cxx-section id="numeric.ops">
    

    <section>
      <header><span class="section-number">13.1</span> <h1 data-bookmark-label="13.1 Generalized numeric operations">Generalized numeric operations</h1> <span style="float:right"><a href="#numeric.ops">[numeric.ops]</a></span></header>
      
    

    <cxx-section id="numeric.ops.overview">
    

    <section>
      <header><span class="section-number">13.1.1</span> <h1 data-bookmark-label="13.1.1 Header &lt;experimental/numeric&gt; synopsis">Header &lt;experimental/numeric&gt; synopsis</h1> <span style="float:right"><a href="#numeric.ops.overview">[numeric.ops.overview]</a></span></header>
      
      

<pre><code>#include &lt;numeric&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="numeric.ops.gcd">// <i><a title="numeric.ops.gcd" href="#numeric.ops.gcd">13.1.2</a>, Greatest common divisor</i></cxx-ref>
  template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M,N&gt; gcd(M m, N n);

  <cxx-ref insynopsis="" to="numeric.ops.lcm">// <i><a title="numeric.ops.lcm" href="#numeric.ops.lcm">13.1.3</a>, Least common multiple</i></cxx-ref>
  template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M,N&gt; lcm(M m, N n);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="numeric.ops.gcd">
    

    <section>
      <header><span class="section-number">13.1.2</span> <h1 data-bookmark-label="13.1.2 Greatest common divisor">Greatest common divisor</h1> <span style="float:right"><a href="#numeric.ops.gcd">[numeric.ops.gcd]</a></span></header>
      
      

      <cxx-function para_num="1" id="numeric.ops.gcd.1">
    
    <pre><code><cxx-signature>template&lt;class M, class N&gt;
constexpr common_type_t&lt;M,N&gt; gcd(M m, N n);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="numeric.ops.gcd.2">
    
    <dt>Requires:</dt><dd>
          <code>|m|</code> shall be representable as a value of type <code>M</code> and
          <code>|n|</code> shall be representable as a value of type <code>N</code>.
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    These requirements ensure, for example, that <code>gcd(m, m) = |m|</code> is representable as a value of type <code>M</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </dd>
  </cxx-requires>
        <cxx-remarks para_num="3" id="numeric.ops.gcd.3">
    
    <dt>Remarks:</dt><dd>If either <code>M</code> or <code>N</code> is not an integer type, the program is ill-formed.</dd>
  </cxx-remarks>
        <cxx-returns para_num="4" id="numeric.ops.gcd.4">
    
    <dt>Returns:</dt><dd>
          zero when <code>m</code> and <code>n</code> are both zero.
          Otherwise, returns the greatest common divisor of <code>|m|</code> and <code>|n|</code>.</dd>
  </cxx-returns>
        <cxx-throws para_num="5" id="numeric.ops.gcd.5">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="numeric.ops.lcm">
    

    <section>
      <header><span class="section-number">13.1.3</span> <h1 data-bookmark-label="13.1.3 Least common multiple">Least common multiple</h1> <span style="float:right"><a href="#numeric.ops.lcm">[numeric.ops.lcm]</a></span></header>
      
      
      <cxx-function para_num="1" id="numeric.ops.lcm.1">
    
    <pre><code><cxx-signature>template&lt;class M, class N&gt;
constexpr common_type_t&lt;M,N&gt; lcm(M m, N n);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-requires para_num="2" id="numeric.ops.lcm.2">
    
    <dt>Requires:</dt><dd>
          <code>|m|</code> shall be representable as a value of type <code>M</code> and
          <code>|n|</code> shall be representable as a value of type <code>N</code>.
          The least common multiple of <code>|m|</code> and <code>|n|</code>
          shall be representable as a value of type <code>common_type_t&lt;M,N&gt;</code>.
        </dd>
  </cxx-requires>
        <cxx-remarks para_num="3" id="numeric.ops.lcm.3">
    
    <dt>Remarks:</dt><dd>If either <code>M</code> or <code>N</code> is not an integer type, the program is ill-formed.</dd>
  </cxx-remarks>
        <cxx-returns para_num="4" id="numeric.ops.lcm.4">
    
    <dt>Returns:</dt><dd>
          zero when either <code>m</code> or <code>n</code> is zero.
          Otherwise, returns the least common multiple of <code>|m|</code> and <code>|n|</code>.
        </dd>
  </cxx-returns>
        <cxx-throws para_num="5" id="numeric.ops.lcm.5">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>
  <cxx-section id="rand">
    

    <section>
      <header><span class="section-number">13.2</span> <h1 data-bookmark-label="13.2 Random number generation">Random number generation</h1> <span style="float:right"><a href="#rand">[rand]</a></span></header>
      
    
    <cxx-section id="rand.synopsis">
    

    <section>
      <header><span class="section-number">13.2.1</span> <h1 data-bookmark-label="13.2.1 Header &lt;experimental/random&gt; synopsis">Header <code>&lt;experimental/random&gt;</code> synopsis</h1> <span style="float:right"><a href="#rand.synopsis">[rand.synopsis]</a></span></header>
      
      
<pre><code>#include &lt;random&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="rand.util.randint">// <i><a title="rand.util.randint" href="#rand.util.randint">13.2.2.1</a>, Function template randint</i></cxx-ref>
  template &lt;class IntType&gt;
  IntType randint(IntType a, IntType b);
  void reseed();
  void reseed(default_random_engine::result_type value);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>
  <cxx-section id="rand.util">
    

    <section>
      <header><span class="section-number">13.2.2</span> <h1 data-bookmark-label="13.2.2 Utilities">Utilities</h1> <span style="float:right"><a href="#rand.util">[rand.util]</a></span></header>
      
    
    <cxx-section id="rand.util.randint">
    

    <section>
      <header><span class="section-number">13.2.2.1</span> <h1 data-bookmark-label="13.2.2.1 Function template randint">Function template <code>randint</code></h1> <span style="float:right"><a href="#rand.util.randint">[rand.util.randint]</a></span></header>
      
      
      <p para_num="1" id="rand.util.randint.1">A separate <dfn>per-thread engine</dfn> of type <code>default_random_engine</code>
      (<cxx-ref in="cxx" to="rand.predef">C++14 <span title="rand.predef">§26.5.5</span></cxx-ref>), initialized to an
      unpredictable state, shall be maintained for each thread.</p>
      <cxx-function para_num="2" id="rand.util.randint.2">
    
    <pre><code><cxx-signature>template&lt;class IntType&gt;
IntType randint(IntType a, IntType b);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-requires para_num="3" id="rand.util.randint.3">
    
    <dt>Requires:</dt><dd><code>a</code> ≤ <code>b</code>.</dd>
  </cxx-requires>
        <cxx-remarks para_num="4" id="rand.util.randint.4">
    
    <dt>Remarks:</dt><dd>If the template argument does not meet the requirements
          for <code>IntType</code> (<cxx-ref in="cxx" to="rand.req.genl">C++14 <span title="rand.req.genl">§26.5.1.1</span></cxx-ref>),
          the program is ill-formed.</dd>
  </cxx-remarks>
        <cxx-returns para_num="5" id="rand.util.randint.5">
    
    <dt>Returns:</dt><dd>A random integer <var>i</var>, <code>a</code> ≤ <var>i</var> ≤ <code>b</code>,
          produced from a thread-local instance of <code>uniform_int_distribution&lt;IntType&gt;</code>
          (<cxx-ref in="cxx" to="rand.dist.uni.int">C++14 <span title="rand.dist.uni.int">§26.5.8.2.1</span></cxx-ref>) invoked with the
          per-thread engine.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
      <cxx-function para_num="6" id="rand.util.randint.6">
    
    <pre><code><cxx-signature>void reseed();</cxx-signature><cxx-signature>void reseed(default_random_engine::result_type value);</cxx-signature></code></pre>

    <dl>
      
        <cxx-effects para_num="7" id="rand.util.randint.7">
    
    <dt>Effects:</dt><dd>Let <code>g</code> be the per-thread engine. The first
          form sets <code>g</code> to an unpredictable state. The second form
          invokes <code>g.seed(value)</code>.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="8" id="rand.util.randint.8">
    
    <dt>Postconditions:</dt><dd>Subsequent calls to <code>randint</code> do not
          depend on values produced by <code>g</code> before calling <code>reseed</code>.
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    <code>reseed</code> also resets any instances of <code>uniform_int_distribution</code>
          used by <code>randint</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></dd>
  </cxx-postconditions>
        
        
    
    </dl>
  </cxx-function>
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-section>
    </section>
  </cxx-clause>

<cxx-clause id="reflection">
    

    <section>
      <header><span class="section-number">14</span> <h1 data-bookmark-label="14 Reflection library">Reflection library</h1> <span style="float:right"><a href="#reflection">[reflection]</a></span></header>
      
  

  <cxx-section id="reflection.src_loc">
    

    <section>
      <header><span class="section-number">14.1</span> <h1 data-bookmark-label="14.1 Class source_location">Class <code>source_location</code></h1> <span style="float:right"><a href="#reflection.src_loc">[reflection.src_loc]</a></span></header>
      
    

    <cxx-section id="reflection.src_loc.synop">
    

    <section>
      <header><span class="section-number">14.1.1</span> <h1 data-bookmark-label="14.1.1 Header &lt;experimental/source_location&gt; synopsis">Header <code>&lt;experimental/source_location&gt;</code> synopsis</h1> <span style="float:right"><a href="#reflection.src_loc.synop">[reflection.src_loc.synop]</a></span></header>
      
      

<pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  struct source_location {
    <cxx-ref insynopsis="" to="reflection.src_loc.creation">// <i><a title="reflection.src_loc.creation" href="#reflection.src_loc.creation">14.1.2</a>, source_location creation</i></cxx-ref>
    static constexpr source_location current() noexcept;

    constexpr source_location() noexcept;

    <cxx-ref insynopsis="" to="reflection.src_loc.fields">// <i><a title="reflection.src_loc.fields" href="#reflection.src_loc.fields">14.1.3</a>, source_location field access</i></cxx-ref>
    constexpr uint_least32_t line() const noexcept;
    constexpr uint_least32_t column() const noexcept;
    constexpr const char* file_name() const noexcept;
    constexpr const char* function_name() const noexcept;
  };

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>

      <p para_num="1" id="reflection.src_loc.synop.1">
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The intent of <code>source_location</code> is to have a small size and efficient copying.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>
    
    </section>
  </cxx-section>

    <cxx-section id="reflection.src_loc.creation">
    

    <section>
      <header><span class="section-number">14.1.2</span> <h1 data-bookmark-label="14.1.2 source_location creation"><code>source_location</code> creation</h1> <span style="float:right"><a href="#reflection.src_loc.creation">[reflection.src_loc.creation]</a></span></header>
      
      

      <cxx-function para_num="1" id="reflection.src_loc.creation.1">
    
    <pre><code><cxx-signature>static constexpr source_location current() noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="reflection.src_loc.creation.2">
    
    <dt>Returns:</dt><dd>
          When invoked by a function call (<cxx-ref in="cxx" to="expr.call">C++14 <span title="expr.call">§5.2.2</span></cxx-ref>)
          whose <cxx-grammarterm><i>postfix-expression</i></cxx-grammarterm> is
          a (possibly parenthesized) <cxx-grammarterm><i>id-expression</i></cxx-grammarterm> naming <code>current</code>,
          returns a <code>source_location</code> with an implementation-defined value.
          The value should be affected by <code>#line</code>
          (<cxx-ref in="cxx" to="cpp.line">C++14 <span title="cpp.line">§16.4</span></cxx-ref>) in the same manner as for <code>__LINE__</code> and <code>__FILE__</code>.
          If invoked in some other way, the value returned is unspecified.
        </dd>
  </cxx-returns>
        <cxx-remarks para_num="3" id="reflection.src_loc.creation.3">
    
    <dt>Remarks:</dt><dd>
          When a <cxx-grammarterm><i>brace-or-equal-initializer</i></cxx-grammarterm> is used to initialize a non-static data member,
          any calls to <code>current</code> should correspond to the location of
          the constructor or aggregate initialization that initializes the member.
        </dd>
  </cxx-remarks>
        <p para_num="4" id="reflection.src_loc.creation.4">
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    When used as a default argument (<cxx-ref in="cxx" to="dcl.fct.default">C++14 <span title="dcl.fct.default">§8.3.6</span></cxx-ref>),
            the value of the <code>source_location</code> will be the location of the call to <code>current</code> at the call site.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </p>
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          <pre><code>struct s {
  source_location member = source_location::current();
  int other_member;
  s(source_location loc = source_location::current())
    : member(loc) // <i>values of</i> member <i>will be from call-site</i>
  {}
  s(int blather) : // <i>values of</i> member <i>should be hereabouts</i>
    other_member(blather) {}
  s(double) // <i>values of</i> member <i>should be hereabouts</i>
  {}
};

void f(source_location a = source_location::current()) {
  source_location b = source_location::current(); // <i>values in</i> b <i>represent this line</i>
}

void g() {
  f(); // f<i>’s first argument corresponds to this line of code</i>

  source_location c = source_location::current();
  f(c); // f<i>’s first argument gets the same values as </i>c<i>, above</i>
}</code></pre>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="reflection.src_loc.creation.5">
    
    <pre><code><cxx-signature>constexpr source_location() noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="6" id="reflection.src_loc.creation.6">
    
    <dt>Effects:</dt><dd>Constructs an object of class <code>source_location</code>.</dd>
  </cxx-effects>
        <cxx-remarks para_num="7" id="reflection.src_loc.creation.7">
    
    <dt>Remarks:</dt><dd>The values are implementation-defined.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="reflection.src_loc.fields">
    

    <section>
      <header><span class="section-number">14.1.3</span> <h1 data-bookmark-label="14.1.3 source_location field access"><code>source_location</code> field access</h1> <span style="float:right"><a href="#reflection.src_loc.fields">[reflection.src_loc.fields]</a></span></header>
      
      

      <cxx-function para_num="1" id="reflection.src_loc.fields.1">
    
    <pre><code><cxx-signature>constexpr uint_least32_t line() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="reflection.src_loc.fields.2">
    
    <dt>Returns:</dt><dd>The presumed line number (<cxx-ref in="cxx" to="cpp.predefined">C++14 <span title="cpp.predefined">§16.8</span></cxx-ref>) represented by this object.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="reflection.src_loc.fields.3">
    
    <pre><code><cxx-signature>constexpr uint_least32_t column() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="4" id="reflection.src_loc.fields.4">
    
    <dt>Returns:</dt><dd>
          An implementation-defined value representing
          some offset from the start of the line represented by this object.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="reflection.src_loc.fields.5">
    
    <pre><code><cxx-signature>constexpr const char* file_name() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="6" id="reflection.src_loc.fields.6">
    
    <dt>Returns:</dt><dd>
          The presumed name of the current source file (<cxx-ref in="cxx" to="cpp.predefined">C++14 <span title="cpp.predefined">§16.8</span></cxx-ref>)
          represented by this object as an NTBS.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="reflection.src_loc.fields.7">
    
    <pre><code><cxx-signature>constexpr const char* function_name() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="8" id="reflection.src_loc.fields.8">
    
    <dt>Returns:</dt><dd>
          If this object represents a position in the body of a function,
          returns an implementation-defined NTBS that should correspond to the function name.
          Otherwise, returns an empty string.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>





</body></html>