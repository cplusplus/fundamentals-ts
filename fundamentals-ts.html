<!DOCTYPE html>
<!-- Sources at https://github.com/cplusplus/fundamentals-ts -->
<html><head><!--[if lte IE 8]><script>document.createElement("nav");document.createElement("section");document.createElement("time");document.createElement("CXX-TITLEPAGE");document.createElement("CXX-DOCNUM");document.createElement("CXX-REVISES");document.createElement("CXX-EDITOR");document.createElement("CXX-EMAIL");document.createElement("CXX-TOC");document.createElement("CXX-CLAUSE");document.createElement("CXX-SECTION");document.createElement("CXX-REF");document.createElement("CXX-FOREIGN-INDEX");document.createElement("CXX-EDNOTE");document.createElement("CXX-NOTE");document.createElement("CXX-FUNCTION");document.createElement("CXX-SIGNATURE");document.createElement("CXX-POSTCONDITIONS");document.createElement("CXX-REMARKS");document.createElement("CXX-REQUIRES");document.createElement("CXX-EFFECTS");document.createElement("CXX-THROWS");document.createElement("CXX-RETURNS");document.createElement("CXX-EXCEPTION-SAFETY");document.createElement("CXX-NOTES");document.createElement("CXX-POSTCONDITION");document.createElement("CXX-FOOTNOTE");document.createElement("CXX-RANGE");document.createElement("CXX-COMPLEXITY");document.createElement("CXX-EXAMPLE");document.createElement("CXX-PUBLISH-BUTTON");</script><![endif]--><style>template {display: none !important;} /* injected by platform.js */</style><style>element {display: none !important;} /* injected by platform.js */</style><style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; } 
</style><style shim-shadowdom-css="">style { display: none !important; }
cxx-function {
	display: block;
}

cxx-function:not(:last-child) {
	margin-bottom: 3ex;
}

cxx-function > dl {
	margin: 0px 0px 0px 2em;
}

cxx-function > pre {
	margin: 0px;
}cxx-signature {
	padding-left: 2em; display: block; text-indent: -2em;
}cxx-attribute {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-attribute dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-attribute dd {
	margin-left: 0em;
}

cxx-attribute dd > ul, cxx-attribute dd > ol {
	clear: left;
}cxx-requires {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-requires dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-requires dd {
	margin-left: 0em;
}

cxx-requires dd > ul, cxx-requires dd > ol {
	clear: left;
}cxx-effects {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-effects dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-effects dd {
	margin-left: 0em;
}

cxx-effects dd > ul, cxx-effects dd > ol {
	clear: left;
}cxx-synchronization {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-synchronization dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-synchronization dd {
	margin-left: 0em;
}

cxx-synchronization dd > ul, cxx-synchronization dd > ol {
	clear: left;
}cxx-postconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-postconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-postconditions dd {
	margin-left: 0em;
}

cxx-postconditions dd > ul, cxx-postconditions dd > ol {
	clear: left;
}cxx-returns {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-returns dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-returns dd {
	margin-left: 0em;
}

cxx-returns dd > ul, cxx-returns dd > ol {
	clear: left;
}cxx-throws {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-throws dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-throws dd {
	margin-left: 0em;
}

cxx-throws dd > ul, cxx-throws dd > ol {
	clear: left;
}cxx-exception-safety {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-exception-safety dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-exception-safety dd {
	margin-left: 0em;
}

cxx-exception-safety dd > ul, cxx-exception-safety dd > ol {
	clear: left;
}cxx-remarks {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-remarks dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-remarks dd {
	margin-left: 0em;
}

cxx-remarks dd > ul, cxx-remarks dd > ol {
	clear: left;
}cxx-error-conditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-error-conditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-error-conditions dd {
	margin-left: 0em;
}

cxx-error-conditions dd > ul, cxx-error-conditions dd > ol {
	clear: left;
}cxx-notes {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-notes dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-notes dd {
	margin-left: 0em;
}

cxx-notes dd > ul, cxx-notes dd > ol {
	clear: left;
}cxx-section {
	display: block;
}

cxx-section:target {
	background-color: inherit;
}

cxx-section:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-section header > h1 {
	display: inline; font-size: 100%;
}

cxx-section header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px;
}

cxx-section header:after {
	clear: both; display: block; content: " "; height: 0px;
}cxx-clause {
	display: block;
}

cxx-clause:target {
	background-color: inherit;
}

cxx-clause:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-clause header > h1 {
	display: inline; font-size: 100%;
}

cxx-clause header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px;
}

cxx-clause header:after {
	clear: both; display: block; content: " "; height: 0px;
}[is=cxx-table] {
	margin-left: auto; margin-right: auto; border-collapse: collapse; border: thin solid black;
}

[is=cxx-table] caption {
	white-space: nowrap;
}

[is=cxx-table] caption caption {
	display: inline;
}

[is=cxx-table] th, [is=cxx-table] td {
	border-style: solid none; border-color: black; border-width: thin;
}

[is=cxx-table] th {
	border-bottom: medium double;
}

[is=cxx-table].center td {
	text-align: center;
}

[is=cxx-table].list td {
	border: medium none;
}[is=cxx-definition-section] dt {
	font-weight: bold;
}

[is=cxx-definition-section] dd {
	margin-left: 0px;
}cxx-toc {
	display: block;
}

cxx-toc nav > ol {
	font-weight: bold;
}

cxx-toc ol {
	font-weight: normal; padding-left: 0px; margin-left: 0px;
}

cxx-toc li {
	list-style-type: none;
}

cxx-toc .marker {
	display: inline-block;
}

cxx-toc li .marker {
	width: 2em; text-align: left;
}

cxx-toc ol ol {
	margin-left: 2em;
}

cxx-toc li li .marker {
	width: 3em;
}

cxx-toc ol ol ol {
	margin-left: 3em;
}

cxx-toc li li li .marker {
	width: 3.5em;
}

cxx-toc ol ol ol ol {
	margin-left: 3.5em;
}

cxx-toc li li li li .marker {
	width: 4.5em;
}polymer-xhr {
	display: none;
}cxx-titlepage {
	display: block; min-height: 100%;
}

cxx-titlepage {
	position: relative;
}

cxx-titlepage table {
	position: absolute; right: 0px; top: 0px;
}

cxx-titlepage h1 {
	position: absolute; top: 40%;
}

cxx-titlepage p.warning {
	position: absolute; bottom: 5%;
}

cxx-titlepage h1 {
	text-align: center;
}

cxx-titlepage th {
	text-align: left; vertical-align: top;
}cxx-ednote {
	display: block;
}

cxx-ednote aside {
	float: right; max-width: 40%; margin: 1ex; border: 1px dashed rgb(136, 136, 136); padding: 1ex; background-color: rgb(238, 238, 238);
}cxx-footnote {
	font-family: serif; white-space: normal; text-indent: initial;
}

@media screen {
cxx-footnote aside {
	float: right; max-width: 30%; margin-left: 1em;
}


}

@media print {
cxx-footnote sup, cxx-footnote .marker {
	display: none;
}

aside {  }


}cxx-example {
	display: block;
}cxx-publish-button {
	display: block;
}</style>
  <meta charset="utf-8">
  <preloader style="display: none;"></preloader><style>[touch-action="none"]{ -ms-touch-action: none; touch-action: none; touch-action-delay: none; }
body ^^ [touch-action="none"]{ -ms-touch-action: none; touch-action: none; touch-action-delay: none; }
[touch-action="auto"]{ -ms-touch-action: auto; touch-action: auto; touch-action-delay: none; }
body ^^ [touch-action="auto"]{ -ms-touch-action: auto; touch-action: auto; touch-action-delay: none; }
[touch-action="pan-x"]{ -ms-touch-action: pan-x; touch-action: pan-x; touch-action-delay: none; }
body ^^ [touch-action="pan-x"]{ -ms-touch-action: pan-x; touch-action: pan-x; touch-action-delay: none; }
[touch-action="pan-y"]{ -ms-touch-action: pan-y; touch-action: pan-y; touch-action-delay: none; }
body ^^ [touch-action="pan-y"]{ -ms-touch-action: pan-y; touch-action: pan-y; touch-action-delay: none; }
[touch-action="pan-x pan-y"],[touch-action="pan-y pan-x"]{ -ms-touch-action: pan-x pan-y; touch-action: pan-x pan-y; touch-action-delay: none; }
body ^^ [touch-action="pan-x pan-y"],body ^^ [touch-action="pan-y pan-x"]{ -ms-touch-action: pan-x pan-y; touch-action: pan-x pan-y; touch-action-delay: none; }
</style>
  <link rel="import" href="bower_components/cxx-html-doc-framework/framework.html">
<style>/* Copyright 2014 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@page {
    margin: 10%;
    @top-left { content: "© ISO/IEC"; font-size: 10pt; }
    @top-right { content: string(docnum); font-weight: bold; font-size: 10pt; }
    @bottom-left { content: string(current-section, last); font-size: 10pt; }
    @bottom-right { content: counter(page); font-size: 10pt; }
}
cxx-titlepage { page: title; page-break-after: always; }
@page title {
    @top-left { content: "© ISO 2014 — All rights reserved"; }
    @top-right { content: normal; }
    @bottom-left { content: normal; }
    @bottom-right { content: normal; }
}

@media screen {
    body { max-width: 7in;
           /* Make room for paragraph numbers. */
           margin-left: 2em }
}

@media print {
    html { font-size: 10pt; }
    pre,code { font-size: 8pt; }
    /* Note that only Prince generates clickable links. */
    a[href] { text-decoration:none; }
}

/* Needed to make the <cxx-titlepage>'s vertical spacing work. */
html, body {height: 100%}

cxx-docnum { string-set: docnum content(); }

cxx-clause { page-break-before: always; }
@media screen {
    cxx-clause, cxx-toc { margin-top: 3em; }
}

/* Rule pairs where the first has a '^' and the second doesn't, are intended
 * to work both with and without the Shadow DOM polyfill.  TODO(jyasskin):
 * Figure out what the Polymer folks recommend instead of this. */

cxx-clause ^ header { font-size: 150%; }
cxx-clause header { font-size: 150%; }
cxx-toc ^ h1 { font-size: 150%; }
cxx-toc h1 { font-size: 150%; }
cxx-clause cxx-section ^ header { font-size: 117%; }
cxx-clause cxx-section header { font-size: 117%; }
cxx-clause cxx-section cxx-section ^ header { font-size: 100%; }
cxx-clause cxx-section cxx-section header { font-size: 100%; }

[data-bookmark-label] { bookmark-label: attr(data-bookmark-label); }
h1 { bookmark-level: 1; }
cxx-toc ^ h1 { bookmark-level: 2; }
cxx-toc h1 { bookmark-level: 2; }
cxx-clause h1 { bookmark-level: 2; }
cxx-clause cxx-section h1 { bookmark-level: 3; }
cxx-clause cxx-section cxx-section h1 { bookmark-level: 4; }

* ^ .section-number { string-set: current-section "§ " content(); }
* .section-number { string-set: current-section "§ " content(); }

p {margin-top: .5em; margin-bottom: .5em}
p:first-child, ul, ol {margin-top: 0}

[para_num]::before { content: attr(para_num); float: left;
                     font-size: 70%; margin-left: -2.5em; width: 1.5em; text-align: right; }

del {text-decoration: line-through; color: #8B0040;}
ins {text-decoration: underline; color: #005100;}

pre { margin-left: 1em; }
pre > code { display: inline-block; }

/* This is here rather than inside elements/toc.html because browsers
   don't understand leader() or target-counter(), so they drop them
   inside the CSSOM. */
@media print {
    /* Generate page numbers in the table of contents. */
    cxx-toc ^ a[href]::after { content: leader(" . ") target-counter(attr(href), page); }
    cxx-toc a[href]::after { content: leader(" . ") target-counter(attr(href), page); }

    cxx-footnote ^ aside { float: footnote; footnote-policy: line; }
    cxx-footnote aside { float: footnote; footnote-policy: line; }
}
</style><title>Working Draft, Technical Specification on C++ Extensions for Library Fundamentals</title></head>
<body>
<cxx-titlepage stage="draft">
    
    <table>
      
        <tr><th>Document Number:</th><td><cxx-docnum>D3908</cxx-docnum></td></tr>
      
      
        <tr><th>Date:</th><td><time pubdate="">2014-02-??</time></td></tr>
      
      
        <tr><th>Revises:</th><td><cxx-revises><a href="http://isocpp.org/files/papers/N3848.html">N3848</a></cxx-revises></td></tr>
      
      
        <tr><th>Editor:</th><td><cxx-editor>
    Jeffrey Yasskin<br>
    Google, Inc.<br>
    <cxx-email><a href="mailto:jyasskin@google.com">jyasskin@google.com</a></cxx-email>
  </cxx-editor></td></tr>
      
    </table>
    <h1>Working Draft, Technical Specification on C++ Extensions for Library Fundamentals</h1>
    
      <p class="warning"><strong>Note: this is an early draft. It’s known to be
      incomplet and incorrekt, and it has lots of b<span style="margin-left: -1.2pt; margin-right: 1pt">a</span>d<span style="width:1.5em"> </span>for<span style="margin-left:-3pt; margin-right:0.6pt">mat</span>ti<span style="position:relative; top:-0.15ex">n</span>g.</strong></p>
    
  </cxx-titlepage>

<cxx-toc>
    
    <nav>
      <h1>Contents</h1>
      
        
          <ol>
            
              <li><span class="marker">1</span><a href="#general">General</a>
        
          <ol>
            
              <li><span class="marker">1.1</span><a href="#general.scope">Scope</a>
        
      </li>
            
              <li><span class="marker">1.2</span><a href="#general.references">Normative references</a>
        
      </li>
            
              <li><span class="marker">1.3</span><a href="#general.namespaces">Namespaces and headers</a>
        
      </li>
            
              <li><span class="marker">1.4</span><a href="#general.defns">Terms and definitions</a>
        
      </li>
            
              <li><span class="marker">1.5</span><a href="#general.plans">Future plans (Informative)</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2</span><a href="#optional">Optional objects</a>
        
          <ol>
            
              <li><span class="marker">2.1</span><a href="#optional.general">In general</a>
        
      </li>
            
              <li><span class="marker">2.2</span><a href="#optional.synop">Header &lt;experimental/optional&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">2.3</span><a href="#optional.defs">Definitions</a>
        
      </li>
            
              <li><span class="marker">2.4</span><a href="#optional.object">optional for object types</a>
        
          <ol>
            
              <li><span class="marker">2.4.1</span><a href="#optional.object.ctor">Constructors</a>
        
      </li>
            
              <li><span class="marker">2.4.2</span><a href="#optional.object.dtor">Destructor</a>
        
      </li>
            
              <li><span class="marker">2.4.3</span><a href="#optional.object.assign">Assignment</a>
        
      </li>
            
              <li><span class="marker">2.4.4</span><a href="#optional.object.swap">Swap</a>
        
      </li>
            
              <li><span class="marker">2.4.5</span><a href="#optional.object.observe">Observers</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2.5</span><a href="#optional.inplace">In-place construction</a>
        
      </li>
            
              <li><span class="marker">2.6</span><a href="#optional.nullopt">Disengaged state indicator</a>
        
      </li>
            
              <li><span class="marker">2.7</span><a href="#optional.bad_optional_access">Class bad_optional_access</a>
        
      </li>
            
              <li><span class="marker">2.8</span><a href="#optional.relops">Relational operators</a>
        
      </li>
            
              <li><span class="marker">2.9</span><a href="#optional.nullops">Comparison with nullopt</a>
        
      </li>
            
              <li><span class="marker">2.10</span><a href="#optional.comp_with_t">Comparison with T</a>
        
      </li>
            
              <li><span class="marker">2.11</span><a href="#optional.specalg">Specialized algorithms</a>
        
      </li>
            
              <li><span class="marker">2.12</span><a href="#optional.hash">Hash support</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3</span><a href="#string.view">string_view</a>
        
          <ol>
            
              <li><span class="marker">3.1</span><a href="#string.view.synop">Header &lt;experimental/string_view&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">3.2</span><a href="#string.view.template">Class template basic_string_view</a>
        
      </li>
            
              <li><span class="marker">3.3</span><a href="#string.view.cons">basic_string_view constructors and assignment operators</a>
        
      </li>
            
              <li><span class="marker">3.4</span><a href="#string.view.iterators">basic_string_view iterator support</a>
        
      </li>
            
              <li><span class="marker">3.5</span><a href="#string.view.capacity">basic_string_view capacity</a>
        
      </li>
            
              <li><span class="marker">3.6</span><a href="#string.view.access">basic_string_view element access</a>
        
      </li>
            
              <li><span class="marker">3.7</span><a href="#string.view.modifiers">basic_string_view modifiers</a>
        
      </li>
            
              <li><span class="marker">3.8</span><a href="#string.view.ops">basic_string_view string operations</a>
        
          <ol>
            
              <li><span class="marker">3.8.1</span><a href="#string.view.find">Searching basic_string_view</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3.9</span><a href="#string.view.comparison">basic_string_view non-member comparison functions</a>
        
      </li>
            
              <li><span class="marker">3.10</span><a href="#string.view.io">Inserters and extractors</a>
        
      </li>
            
              <li><span class="marker">3.11</span><a href="#string.view.hash">Hash support</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      
    </nav>
  </cxx-toc>

<cxx-clause id="general">
    

    <section>
      <header><span class="section-number">1</span> <h1 data-bookmark-label="1 General">General</h1> <span style="float:right"><a href="#general">[general]</a></span></header>
      
  
  <cxx-section id="general.scope">
    

    <section>
      <header><span class="section-number">1.1</span> <h1 data-bookmark-label="1.1 Scope">Scope</h1> <span style="float:right"><a href="#general.scope">[general.scope]</a></span></header>
      
    
    <p para_num="1" id="general.scope.1">This technical specification describes extensions to the C++
    Standard Library (<cxx-ref to="general.references"><a href="#general.references">1.2</a></cxx-ref>). These extensions are classes
    and functions that are likely to be used widely within a program
    and/or on the interface boundaries between libraries written by
    different organizations.</p>

    <p para_num="2" id="general.scope.2">This technical specification is non-normative. Some of the
    library components in this technical specification may be
    considered for standardization in a future version of C++, but
    they are not currently part of any C++ standard. Some of the
    components in this technical specification may never be
    standardized, and others may be standardized in a substantially
    changed form.</p>

    <p para_num="3" id="general.scope.3">The goal of this technical specification is to build more
    widespread existing practice for an expanded C++ standard
    library. It gives advice on extensions to those vendors who wish
    to provide them.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.references">
    

    <section>
      <header><span class="section-number">1.2</span> <h1 data-bookmark-label="1.2 Normative references">Normative references</h1> <span style="float:right"><a href="#general.references">[general.references]</a></span></header>
      
    

    <p para_num="1" id="general.references.1">The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>

    <ul>
      <li>ISO/IEC 14882:2011, <cite>Programming Languages — C++</cite>
      <cxx-foreign-index id="cxx" src="cxx11_index.json" name="C++11">
    <polymer-ajax auto="" url="cxx11_index.json" handleas="json" on-polymer-response="{{ attachIndex }}">
    </polymer-ajax>
  </cxx-foreign-index></li>
    </ul>

    <p para_num="2" id="general.references.2">ISO/IEC 14882:2011 is herein called the <dfn>C++ Standard</dfn>.
    References to clauses within the C++ Standard are written as "C++11
    §3.2". The library described in ISO/IEC 14882:2011 clauses 17–30 is
    herein called the <dfn>C++ Standard Library</dfn>.</p>

    <p para_num="3" id="general.references.3">Unless otherwise specified, the whole of the C++ Standard's Library
    introduction (<cxx-ref in="cxx" to="library">C++11 §17</cxx-ref>) is included into this
    Technical Specification by reference.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.namespaces">
    

    <section>
      <header><span class="section-number">1.3</span> <h1 data-bookmark-label="1.3 Namespaces and headers">Namespaces and headers</h1> <span style="float:right"><a href="#general.namespaces">[general.namespaces]</a></span></header>
      
    

    <cxx-ednote>
    
    <aside><strong>Editor's note:</strong> This section reflects the <a href="http://wiki.edg.com/twiki/bin/view/Wg21chicago2013/FundamentalsTS#What_can_go_into_a_TS">consensus
    between the LWG and LEWG at the Chicago 2013
    meeting</a>.</aside>
  </cxx-ednote>

    <p para_num="1" id="general.namespaces.1">Since the extensions described in this technical specification
    are experimental and not part of the C++ standard library, they
    should not be declared directly within namespace
    <code>std</code>. Unless otherwise specifed, all components
    described in this technical specification are declared in
    namespace <code>std::experimental::fundamentals_v1</code> or a
    subnamespace thereof.  Each header described in this technical
    specification shall import the contents of
    <code>std::experimental::fundamentals_v1</code> into
    <code>std::experimental</code> as if by</p>

    <pre><code>namespace std {
  namespace experimental {
    inline namespace fundamentals_v1 {}
  }
}</code></pre>

    <p para_num="2" id="general.namespaces.2">Unless otherwise specified, references to other entities
    described in this technical specification are assumed to be
    qualified with <code>std::experimental::fundamentals_v1::</code>,
    and references to entities described in the standard are assumed
    to be qualified with <code>std::</code>.</p>

    <p para_num="3" id="general.namespaces.3">Extensions that are expected to eventually be added to an
    existing header <code>&lt;meow&gt;</code> are provided inside the
    <code>&lt;experimental/meow&gt;</code> header, which shall include
    the standard contents of <code>&lt;meow&gt;</code> as if by</p>
    <pre><code>#include &lt;meow&gt;</code></pre>

    <p para_num="4" id="general.namespaces.4"><cxx-note>[ <em>Note:</em> This implies that this technical specification cannot
    remove an existing overload of a function. — <em>end note</em> ]</cxx-note></p>

    <p para_num="5" id="general.namespaces.5">New headers are also provided in the
    <code>&lt;experimental/&gt;</code> directory, but without such an
    <code>#include</code>.</p>

    <table is="cxx-table" id="tab.cxx.headers" class="list">
    

    <caption>Table 1 — <wbr><caption>C++ library headers</caption></caption>
    
      
      <tbody><tr><td><code>&lt;experimental/optional&gt;</code></td></tr>
      <tr><td><code>&lt;experimental/string_view&gt;</code></td></tr>
    </tbody>
  </table>
  
    </section>
  </cxx-section>

  <cxx-section id="general.defns">
    

    <section>
      <header><span class="section-number">1.4</span> <h1 data-bookmark-label="1.4 Terms and definitions">Terms and definitions</h1> <span style="float:right"><a href="#general.defns">[general.defns]</a></span></header>
      
    

    <p para_num="1" id="general.defns.1">For the purposes of this document, the terms and definitions
    given in the C++ Standard and the folowing apply.</p>

    <dl is="cxx-definition-section">
    

    
      <dt id="general.defns.direct-non-list-init">
    1.4.1
    <span style="float:right"><a href="#general.defns.direct-non-list-init">[general.defns.direct-non-list-init]</a></span>
    <br clear="all">
    direct-non-list-initialization
  </dt>
      <dd>A direct-initialization that is not list-initialization.</dd>
    
  </dl>
  
    </section>
  </cxx-section>

  <cxx-section id="general.plans">
    

    <section>
      <header><span class="section-number">1.5</span> <h1 data-bookmark-label="1.5 Future plans (Informative)">Future plans (Informative)</h1> <span style="float:right"><a href="#general.plans">[general.plans]</a></span></header>
      
    

    <p para_num="1" id="general.plans.1">This section describes tentative plans for future versions of
    this technical specification and plans for moving content into
    future versions of the C++ Standard.</p>

    <p para_num="2" id="general.plans.2">The C++ committee intends to release a new version of this
    technical specification approximately every year, containing the
    library extensions we hope to add to a near-future version of the
    C++ Standard.  Future versions will define their contents in
    <code>std::experimental::fundamentals_v2</code>,
    <code>std::experimental::fundamentals_v3</code>, etc., with the
    most recent implemented version inlined into
    <code>std::experimental</code>.</p>

    <p para_num="3" id="general.plans.3">When an extension defined in this or a future version of this
    technical specification represents enough existing practice, it
    will be moved into the next version of the C++ Standard by
    removing the <code>experimental::fundamentals_v<var>N</var></code>
    segment of its namespace and by removing the
    <code>experimental/</code> prefix from its header's path.</p>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="optional">
    

    <section>
      <header><span class="section-number">2</span> <h1 data-bookmark-label="2 Optional objects">Optional objects</h1> <span style="float:right"><a href="#optional">[optional]</a></span></header>
      
  

  <cxx-section id="optional.general">
    

    <section>
      <header><span class="section-number">2.1</span> <h1 data-bookmark-label="2.1 In general">In general</h1> <span style="float:right"><a href="#optional.general">[optional.general]</a></span></header>
      
    

    <p para_num="1" id="optional.general.1">This subclause describes class template <code>optional</code> that represents <em>optional objects</em>. An <dfn>optional object for object types</dfn> is an object that contains the storage for another object and manages the lifetime of this contained object, if any. The contained object may be initialized after the optional object has been initialized, and may be destroyed before the optional object has been destroyed. The initialization state of the contained object is tracked by the optional object.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.synop">
    

    <section>
      <header><span class="section-number">2.2</span> <h1 data-bookmark-label="2.2 Header <experimental/optional> synopsis">Header <code>&lt;experimental/optional&gt;</code> synopsis</h1> <span style="float:right"><a href="#optional.synop">[optional.synop]</a></span></header>
      
    

<pre>namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
  <cxx-ref insynopsis="" to="optional.object">// <i><a href="#optional.object">2.4</a>, optional for object types</i></cxx-ref>
  template &lt;class T&gt; class optional;

  <cxx-ref insynopsis="" to="optional.inplace">// <i><a href="#optional.inplace">2.5</a>, In-place construction</i></cxx-ref>
  struct in_place_t{};
  constexpr in_place_t in_place{};

  <cxx-ref insynopsis="" to="optional.nullopt">// <i><a href="#optional.nullopt">2.6</a>, Disengaged state indicator</i></cxx-ref>
  struct nullopt_t{<em>see below</em>};
  constexpr nullopt_t nullopt(<em>unspecified</em>);

  <cxx-ref insynopsis="" to="optional.bad_optional_access">// <i><a href="#optional.bad_optional_access">2.7</a>, Class bad_optional_access</i></cxx-ref>
  class bad_optional_access;

  <cxx-ref insynopsis="" to="optional.relops">// <i><a href="#optional.relops">2.8</a>, Relational operators</i></cxx-ref>
  template &lt;class T&gt;
    constexpr bool operator==(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt;
    constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);

  <cxx-ref insynopsis="" to="optional.nullops">// <i><a href="#optional.nullops">2.9</a>, Comparison with nullopt</i></cxx-ref>
  template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
  template &lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
  template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
  template &lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;

  <cxx-ref insynopsis="" to="optional.comp_with_t">// <i><a href="#optional.comp_with_t">2.10</a>, Comparison with T</i></cxx-ref>
  template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, const T&amp;);
  template &lt;class T&gt; constexpr bool operator==(const T&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const T&amp;);
  template &lt;class T&gt; constexpr bool operator&lt;(const T&amp;, const optional&lt;T&gt;&amp;);

  <cxx-ref insynopsis="" to="optional.specalg">// <i><a href="#optional.specalg">2.11</a>, Specialized algorithms</i></cxx-ref>
  template &lt;class T&gt; void swap(optional&lt;T&gt;&amp;, optional&lt;T&gt;&amp;) noexcept(<em>see below</em>);
  template &lt;class T&gt; constexpr optional&lt;<em>see below</em>&gt; make_optional(T&amp;&amp;);

} // <i>namespace fundamentals_v1</i>
} // <i>namespace experimental</i>

  <cxx-ref insynopsis="" to="optional.hash">// <i><a href="#optional.hash">2.12</a>, Hash support</i></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt; struct hash&lt;experimental::optional&lt;T&gt;&gt;;
} // <i>namespace std</i>
</pre>

    <p para_num="1" id="optional.synop.1">A program that necessitates the instantiation of template <code>optional</code> for a reference type, or for possibly cv-qualified types <code>in_place_t</code> or <code>nullopt_t</code> is ill-formed.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.defs">
    

    <section>
      <header><span class="section-number">2.3</span> <h1 data-bookmark-label="2.3 Definitions">Definitions</h1> <span style="float:right"><a href="#optional.defs">[optional.defs]</a></span></header>
      
    

    <p para_num="1" id="optional.defs.1">An instance of <code>optional&lt;T&gt;</code> is said to be <dfn>disengaged</dfn> if it has been default constructed, constructed with or assigned with a value of type <code>nullopt_t</code>, constructed with or assigned with a disengaged optional object of type <code>optional&lt;T&gt;</code>.
    </p>

    <p para_num="2" id="optional.defs.2">An instance of <code>optional&lt;T&gt;</code> is said to be <dfn>engaged</dfn> if it is not disengaged.
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.object">
    

    <section>
      <header><span class="section-number">2.4</span> <h1 data-bookmark-label="2.4 optional for object types"><code>optional</code> for object types</h1> <span style="float:right"><a href="#optional.object">[optional.object]</a></span></header>
      
    

<pre>template &lt;class T&gt;
class optional
{
public:
  typedef T value_type;

  <cxx-ref insynopsis="" to="optional.object.ctor">// <i><a href="#optional.object.ctor">2.4.1</a>, Constructors</i></cxx-ref>
  constexpr optional() noexcept;
  constexpr optional(nullopt_t) noexcept;
  optional(const optional&amp;);
  optional(optional&amp;&amp;) noexcept(<em>see below</em>);
  constexpr optional(const T&amp;);
  constexpr optional(T&amp;&amp;);
  template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;...);
  template &lt;class U, class... Args&gt;
    constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args&amp;&amp;...);

  <cxx-ref insynopsis="" to="optional.object.dtor">// <i><a href="#optional.object.dtor">2.4.2</a>, Destructor</i></cxx-ref>
  ~optional();

  <cxx-ref insynopsis="" to="optional.object.assign">// <i><a href="#optional.object.assign">2.4.3</a>, Assignment</i></cxx-ref>
  optional&amp; operator=(nullopt_t) noexcept;
  optional&amp; operator=(const optional&amp;);
  optional&amp; operator=(optional&amp;&amp;) noexcept(<em>see below</em>);
  template &lt;class U&gt; optional&amp; operator=(U&amp;&amp;);
  template &lt;class... Args&gt; void emplace(Args&amp;&amp;...);
  template &lt;class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);

  <cxx-ref insynopsis="" to="optional.object.swap">// <i><a href="#optional.object.swap">2.4.4</a>, Swap</i></cxx-ref>
  void swap(optional&amp;) noexcept(<em>see below</em>);

  <cxx-ref insynopsis="" to="optional.object.observe">// <i><a href="#optional.object.observe">2.4.5</a>, Observers</i></cxx-ref>
  constexpr T const* operator -&gt;() const;
  T* operator -&gt;();
  constexpr T const&amp; operator *() const;
  T&amp; operator *();
  constexpr explicit operator bool() const noexcept;
  constexpr T const&amp; value() const;
  T&amp; value();
  template &lt;class U&gt; constexpr T value_or(U&amp;&amp;) const&amp;;
  template &lt;class U&gt; T value_or(U&amp;&amp;) &amp;&amp;;

private:
  bool init; // <i>exposition only</i>
  T*   val;  // <i>exposition only</i>
};</pre>

    <p para_num="1" id="optional.object.1">Engaged instances of <code>optional&lt;T&gt;</code> where <code>T</code> is of object type shall contain a value of type <code>T</code> within its own storage. This value is referred to as the <dfn>contained value</dfn> of the optional object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value.  The contained value shall be allocated in a region of the <code>optional&lt;T&gt;</code> storage suitably aligned for the type <code>T</code>.</p>

    <p para_num="2" id="optional.object.2">Members <code><var>init</var></code> and <code><var>val</var></code> are provided for exposition only. Implementations need not provide those members. <code><var>init</var></code> indicates whether the <code>optional</code> object's contained value has been initialized (and not yet destroyed); <code><var>val</var></code> points to (a possibly uninitialized) contained value.
    </p>

    <p para_num="3" id="optional.object.3"><code>T</code> shall be an object type and shall satisfy the requirements of <code>Destructible</code> (Table 24).</p>

    <cxx-section id="optional.object.ctor">
    

    <section>
      <header><span class="section-number">2.4.1</span> <h1 data-bookmark-label="2.4.1 Constructors">Constructors</h1> <span style="float:right"><a href="#optional.object.ctor">[optional.object.ctor]</a></span></header>
      
      

      <cxx-function para_num="1" id="optional.object.ctor.1">
    
    <pre><code><cxx-signature>constexpr optional() noexcept;</cxx-signature><cxx-signature>constexpr optional(nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-postconditions para_num="2" id="optional.object.ctor.2">
    
    <dt>Postconditions:</dt><dd><code>*this</code> is disengaged.</dd>
  </cxx-postconditions><cxx-remarks para_num="3" id="optional.object.ctor.3">
    
    <dt>Remarks:</dt><dd>No <code>T</code> object referenced is initialized. For every object type <code>T</code> these constructors shall be <code>constexpr</code> constructors (<cxx-ref in="cxx" to="dcl.constexpr">C++11 §7.1.5</cxx-ref>).</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="4" id="optional.object.ctor.4">
    
    <pre><code><cxx-signature>optional(const optional&lt;T&gt;&amp; <var>rhs</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="5" id="optional.object.ctor.5">
    
    <dt>Requires:</dt><dd><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="6" id="optional.object.ctor.6">
    
    <dt>Effects:</dt><dd>If <code><var>rhs</var></code> is engaged initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>*<var>rhs</var></code>.</dd>
  </cxx-effects><cxx-postconditions para_num="7" id="optional.object.ctor.7">
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions><cxx-throws para_num="8" id="optional.object.ctor.8">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws></dl>
  </cxx-function>

      <cxx-function para_num="9" id="optional.object.ctor.9">
    
    <pre><code><cxx-signature>optional(optional&lt;T&gt;&amp;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="10" id="optional.object.ctor.10">
    
    <dt>Requires:</dt><dd><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="11" id="optional.object.ctor.11">
    
    <dt>Effects:</dt><dd>If <code><var>rhs</var></code> is engaged initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(*<var>rhs</var>)</code>. <code>bool(<var>rhs</var>)</code> is unchanged.</dd>
  </cxx-effects><cxx-postconditions para_num="12" id="optional.object.ctor.12">
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions><cxx-throws para_num="13" id="optional.object.ctor.13">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks para_num="14" id="optional.object.ctor.14">
    
    <dt>Remarks:</dt><dd>The expression inside <code>noexcept</code> is equivalent to:<pre>is_nothrow_move_constructible&lt;T&gt;::value</pre></dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="15" id="optional.object.ctor.15">
    
    <pre><code><cxx-signature>optional(const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="16" id="optional.object.ctor.16">
    
    <dt>Requires:</dt><dd><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="17" id="optional.object.ctor.17">
    
    <dt>Effects:</dt><dd>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code><var>v</var></code>.</dd>
  </cxx-effects><cxx-postconditions para_num="18" id="optional.object.ctor.18">
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws para_num="19" id="optional.object.ctor.19">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks para_num="20" id="optional.object.ctor.20">
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="21" id="optional.object.ctor.21">
    
    <pre><code><cxx-signature>optional(T&amp;&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="22" id="optional.object.ctor.22">
    
    <dt>Requires:</dt><dd><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="23" id="optional.object.ctor.23">
    
    <dt>Effects:</dt><dd>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(<var>v</var>)</code>.</dd>
  </cxx-effects><cxx-postconditions para_num="24" id="optional.object.ctor.24">
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws para_num="25" id="optional.object.ctor.25">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks para_num="26" id="optional.object.ctor.26">
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="27" id="optional.object.ctor.27">
    
    <pre><code><cxx-signature>template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="28" id="optional.object.ctor.28">
    
    <dt>Requires:</dt><dd><code>is_constructible&lt;T, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="29" id="optional.object.ctor.29">
    
    <dt>Effects:</dt><dd>Initializes the contained value as if constructing an object of type <code>T</code> with the arguments <code>std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects><cxx-postconditions para_num="30" id="optional.object.ctor.30">
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws para_num="31" id="optional.object.ctor.31">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks para_num="32" id="optional.object.ctor.32">
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s constructor selected for the initialization is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="33" id="optional.object.ctor.33">
    
    <pre><code><cxx-signature>template &lt;class U, class... Args&gt; <wbr>explicit optional(in_place_t, initializer_list&lt;U&gt; <var>il</var>, Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="34" id="optional.object.ctor.34">
    
    <dt>Requires:</dt><dd><code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="35" id="optional.object.ctor.35">
    
    <dt>Effects:</dt><dd>Initializes the contained value as if constructing an object of type <code>T</code> with the arguments <code><var>il</var>, std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects><cxx-postconditions para_num="36" id="optional.object.ctor.36">
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws para_num="37" id="optional.object.ctor.37">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks para_num="38" id="optional.object.ctor.38">
    
    <dt>Remarks:</dt><dd>The function shall not participate in overload resolution unless <code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-remarks><cxx-remarks para_num="39" id="optional.object.ctor.39">
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s constructor selected for the initialization is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks></dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.dtor">
    

    <section>
      <header><span class="section-number">2.4.2</span> <h1 data-bookmark-label="2.4.2 Destructor">Destructor</h1> <span style="float:right"><a href="#optional.object.dtor">[optional.object.dtor]</a></span></header>
      
      

      <cxx-function para_num="1" id="optional.object.dtor.1">
    
    <pre><code><cxx-signature>~optional();</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="2" id="optional.object.dtor.2">
    
    <dt>Effects:</dt><dd>If <code>is_trivially_destructible&lt;T&gt;::value != true</code> and <code>*this</code> is engaged, calls <code><var>val</var>-&gt;T::~T()</code>.</dd>
  </cxx-effects><cxx-remarks para_num="3" id="optional.object.dtor.3">
    
    <dt>Remarks:</dt><dd>If <code>is_trivially_destructible&lt;T&gt;::value == true</code> then this destructor shall be a trivial destructor.</dd>
  </cxx-remarks></dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.assign">
    

    <section>
      <header><span class="section-number">2.4.3</span> <h1 data-bookmark-label="2.4.3 Assignment">Assignment</h1> <span style="float:right"><a href="#optional.object.assign">[optional.object.assign]</a></span></header>
      
      

      <cxx-function para_num="1" id="optional.object.assign.1">
    
    <pre><code><cxx-signature>optional&lt;T&gt;&amp; operator=(nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="2" id="optional.object.assign.2">
    
    <dt>Effects:</dt><dd>If <code>*this</code> is engaged calls <code><var>val</var>-&gt;T::~T()</code> to destroy the contained value; otherwise no effect.</dd>
  </cxx-effects><cxx-returns para_num="3" id="optional.object.assign.3">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns><cxx-postconditions para_num="4" id="optional.object.assign.4">
    
    <dt>Postconditions:</dt><dd><code>*this</code> is disengaged.</dd>
  </cxx-postconditions></dl>
  </cxx-function>

      <cxx-function para_num="5" id="optional.object.assign.5">
    
    <pre><code><cxx-signature>optional&lt;T&gt;&amp; operator=(const optional&lt;T&gt;&amp; <var>rhs</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="6" id="optional.object.assign.6">
    
    <dt>Requires:</dt><dd><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_copy_assignable&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="7" id="optional.object.assign.7">
    
    <dt>Effects:</dt><dd>
          <ul>
            <li>If <code>*this</code> is disengaged and <code><var>rhs</var></code> is disengaged, no effect, otherwise</li>
            <li>if <code>*this</code> is engaged and <code><var>rhs</var></code> is disengaged, destroys the contained value by calling <code><var>val</var>-&gt;T::~T()</code>, otherwise</li>
            <li>if <code>*this</code> is disengaged and <code><var>rhs</var></code> is engaged, initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with <code>*<var>rhs</var></code>, otherwise</li>
            <li>(if both <code>*this</code> and <code><var>rhs</var></code> are engaged) assigns <code>*<var>rhs</var></code> to the contained value.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-returns para_num="8" id="optional.object.assign.8">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns><cxx-postconditions para_num="9" id="optional.object.assign.9">
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions><cxx-exception-safety para_num="10" id="optional.object.assign.10">
    
    <dt>Exception safety:</dt><dd>If any exception is thrown, values of <code><var>init</var></code> and <code><var>rhs.init</var></code> remain unchanged. If an exception is thrown during the call to <code>T</code>'s copy constructor, no effect. If an exception is thrown during the call to <code>T</code>'s copy assignment, the state of its contained value is as defined by the exception safety guarantee of <code>T</code>'s copy constructor.</dd>
  </cxx-exception-safety></dl>
  </cxx-function>

      <cxx-function para_num="11" id="optional.object.assign.11">
    
    <pre><code><cxx-signature>optional&lt;T&gt;&amp; operator=(optional&lt;T&gt;&amp;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="12" id="optional.object.assign.12">
    
    <dt>Requires:</dt><dd><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_move_assignable&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="13" id="optional.object.assign.13">
    
    <dt>Effects:</dt><dd>
          <ul>
            <li>If <code>*this</code> is disengaged and <code><var>rhs</var></code> is disengaged, no effect, otherwise</li>
            <li>if <code>*this</code> is engaged and <code><var>rhs</var></code> is disengaged, destroys the contained value by calling <code><var>val</var>-&gt;T::~T()</code>, otherwise</li>
            <li>if <code>*this</code> is disengaged and <code><var>rhs</var></code> is engaged, initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with <code>std::move(*<var>rhs</var>)</code>, otherwise</li>
            <li>(if both <code>*this</code> and <code><var>rhs</var></code> are engaged) assigns <code>std::move(*<var>rhs</var>)</code> to the contained value.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-returns para_num="14" id="optional.object.assign.14">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns><cxx-postconditions para_num="15" id="optional.object.assign.15">
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions><cxx-remarks para_num="16" id="optional.object.assign.16">
    
    <dt>Remarks:</dt><dd>The expression inside <code>noexcept</code> is equivalent to: <pre>is_nothrow_move_assignable&lt;T&gt;::value &amp;&amp; is_nothrow_move_constructible&lt;T&gt;::value</pre></dd>
  </cxx-remarks><cxx-exception-safety para_num="17" id="optional.object.assign.17">
    
    <dt>Exception safety:</dt><dd>If any exception is thrown, values of <code><var>init</var></code> and <code><var>rhs.init</var></code> remain unchanged. If an exception is thrown during the call to <code>T</code>'s move constructor, the state of <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s move constructor. If an exception is thrown during the call to <code>T</code>'s move assignment, the state of <code><var>*val</var></code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s move assignment.</dd>
  </cxx-exception-safety></dl>
  </cxx-function>

      <cxx-function para_num="18" id="optional.object.assign.18">
    
    <pre><code><cxx-signature>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="19" id="optional.object.assign.19">
    
    <dt>Requires:</dt><dd><code>is_constructible&lt;T, U&gt;::value</code> is <code>true</code> and <code>is_assignable&lt;U, T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="20" id="optional.object.assign.20">
    
    <dt>Effects:</dt><dd>If <code>*this</code> is engaged assigns <code>std::forward&lt;U&gt;(<var>v</var>)</code> to the contained value; otherwise initializes the contained value as if direct-non-list-initializing object of type <code>T</code> with <code>std::forward&lt;U&gt;(<var>v</var>)</code>.</dd>
  </cxx-effects><cxx-returns para_num="21" id="optional.object.assign.21">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns><cxx-postconditions para_num="22" id="optional.object.assign.22">
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-exception-safety para_num="23" id="optional.object.assign.23">
    
    <dt>Exception safety:</dt><dd>If any exception is thrown, the value of <code><var>init</var></code> remains unchanged. If an exception is thrown during the call to <code>T</code>'s constructor, the state of <code><var>v</var></code> is determined by the exception safety guarantee of <code>T</code>'s constructor. If an exception is thrown during the call to <code>T</code>'s assignment, the state of <code><var>*val</var></code> and <code><var>v</var></code> is determined by the exception safety guarantee of <code>T</code>'s assignment.</dd>
  </cxx-exception-safety><cxx-remarks para_num="24" id="optional.object.assign.24">
    
    <dt>Remarks:</dt><dd>The function shall not participate in overload resolution unless  <code>is_same&lt;typename remove_reference&lt;U&gt;::type, T&gt;::value</code> is  <code>true</code>.</dd>
  </cxx-remarks><cxx-notes para_num="25" id="optional.object.assign.25">
    
    <dt>Notes:</dt><dd>The reason for providing such generic assignment and then constraining it so that effectively <code>T</code> == <code>U</code> is to guarantee that assignment of the form <code>o = {}</code> is unambiguous.</dd>
  </cxx-notes></dl>
  </cxx-function>

      <cxx-function para_num="26" id="optional.object.assign.26">
    
    <pre><code><cxx-signature>template &lt;class... Args&gt; void emplace(Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="27" id="optional.object.assign.27">
    
    <dt>Requires:</dt><dd><code>is_constructible&lt;T, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="28" id="optional.object.assign.28">
    
    <dt>Effects:</dt><dd>Calls <code>*this = nullopt</code>. Then initializes the contained value as if constructing an object of type <code>T</code> with the arguments <code>std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects><cxx-postconditions para_num="29" id="optional.object.assign.29">
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws para_num="30" id="optional.object.assign.30">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-exception-safety para_num="31" id="optional.object.assign.31">
    
    <dt>Exception safety:</dt><dd>If an exception is thrown during the call to <code>T</code>'s constructor, <code>*this</code> is disengaged, and the previous <code><var>*val</var></code> (if any) has been destroyed.</dd>
  </cxx-exception-safety></dl>
  </cxx-function>

      <cxx-function para_num="32" id="optional.object.assign.32">
    
    <pre><code><cxx-signature>template &lt;class U, class... Args&gt; <wbr>void emplace(initializer_list&lt;U&gt; <var>il</var>, Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="33" id="optional.object.assign.33">
    
    <dt>Requires:</dt><dd><code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="34" id="optional.object.assign.34">
    
    <dt>Effects:</dt><dd>Calls <code>*this = nullopt</code>. Then initializes the contained value as if constructing an object of type <code>T</code> with the arguments <code><var>il</var>, std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects><cxx-postconditions para_num="35" id="optional.object.assign.35">
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws para_num="36" id="optional.object.assign.36">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-exception-safety para_num="37" id="optional.object.assign.37">
    
    <dt>Exception safety:</dt><dd>If an exception is thrown during the call to <code>T</code>'s constructor, <code>*this</code> is disengaged, and the previous <code><var>*val</var></code> (if any) has been destroyed.</dd>
  </cxx-exception-safety><cxx-remarks para_num="38" id="optional.object.assign.38">
    
    <dt>Remarks:</dt><dd>The function shall not participate in overload resolution unless <code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-remarks></dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.swap">
    

    <section>
      <header><span class="section-number">2.4.4</span> <h1 data-bookmark-label="2.4.4 Swap">Swap</h1> <span style="float:right"><a href="#optional.object.swap">[optional.object.swap]</a></span></header>
      
      

      <cxx-function para_num="1" id="optional.object.swap.1">
    
    <pre><code><cxx-signature>void swap(optional&lt;T&gt;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="2" id="optional.object.swap.2">
    
    <dt>Requires:</dt><dd>LValues of type T shall be swappable and <code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects para_num="3" id="optional.object.swap.3">
    
    <dt>Effects:</dt><dd>
          <ul>
            <li>If <code>*this</code> is disengaged and <code><var>rhs</var></code> is disengaged, no effect, otherwise</li>
            <li>if <code>*this</code> is engaged and <code><var>rhs</var></code> is disengaged, initializes the contained value of <code><var>rhs</var></code> by direct-initialization with <code>std::move(*(*this))</code>, followed by <code>val-&gt;T::~T(), swap(<var>init</var>, <var>rhs.init</var>)</code>, otherwise</li>
            <li>if <code>*this</code> is disengaged and <code><var>rhs</var></code> is engaged, initializes the contained value of <code>*this</code> by direct-initialization with <code>std::move(*<var>rhs</var>)</code>, followed by <code>rhs.val-&gt;T::~T(), swap(<var>init</var>, <var>rhs.init</var>)</code>, otherwise</li>
            <li>(if both <code>*this</code> and <code><var>rhs</var></code> are engaged) calls <code>swap(*(*this), *<var>rhs</var>)</code>.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-throws para_num="4" id="optional.object.swap.4">
    
    <dt>Throws:</dt><dd>Any exceptions that the expressions in the Effects clause throw.</dd>
  </cxx-throws><cxx-remarks para_num="5" id="optional.object.swap.5">
    
    <dt>Remarks:</dt><dd>The expression inside <code>noexcept</code> is equivalent to: <pre>is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; <wbr>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</pre></dd>
  </cxx-remarks><cxx-exception-safety para_num="6" id="optional.object.swap.6">
    
    <dt>Exception safety:</dt><dd>If any exception is thrown, values of <code><var>init</var></code> and <code><var>rhs.init</var></code> remain unchanged. If an exception is thrown during the call to function <code>swap</code> the state of <code><var>*val</var></code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>swap</code> for lvalues of <code>T</code>. If an exception is thrown during the call to <code>T</code>'s move constructor, the state of <code><var>*val</var></code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s move constructor.</dd>
  </cxx-exception-safety></dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.observe">
    

    <section>
      <header><span class="section-number">2.4.5</span> <h1 data-bookmark-label="2.4.5 Observers">Observers</h1> <span style="float:right"><a href="#optional.object.observe">[optional.object.observe]</a></span></header>
      
      

      <cxx-function para_num="1" id="optional.object.observe.1">
    
    <pre><code><cxx-signature>constexpr T const* operator-&gt;() const;</cxx-signature><cxx-signature>T* operator-&gt;();</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="2" id="optional.object.observe.2">
    
    <dt>Requires:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-requires><cxx-returns para_num="3" id="optional.object.observe.3">
    
    <dt>Returns:</dt><dd><code><var>val</var></code>.</dd>
  </cxx-returns><cxx-throws para_num="4" id="optional.object.observe.4">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws><cxx-remarks para_num="5" id="optional.object.observe.5">
    
    <dt>Remarks:</dt><dd>Unless <code>T</code> is a user-defined type with overloaded unary <code>operator&amp;</code>, the first function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="6" id="optional.object.observe.6">
    
    <pre><code><cxx-signature>constexpr T const&amp; operator*() const;</cxx-signature><cxx-signature>T&amp; operator*();</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="7" id="optional.object.observe.7">
    
    <dt>Requires:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-requires><cxx-returns para_num="8" id="optional.object.observe.8">
    
    <dt>Returns:</dt><dd><code>*<var>val</var></code>.</dd>
  </cxx-returns><cxx-throws para_num="9" id="optional.object.observe.9">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws><cxx-remarks para_num="10" id="optional.object.observe.10">
    
    <dt>Remarks:</dt><dd>The first function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="11" id="optional.object.observe.11">
    
    <pre><code><cxx-signature>constexpr explicit operator bool() noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="12" id="optional.object.observe.12">
    
    <dt>Returns:</dt><dd><code><var>init</var></code>.</dd>
  </cxx-returns><cxx-remarks para_num="13" id="optional.object.observe.13">
    
    <dt>Remarks:</dt><dd>this function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="14" id="optional.object.observe.14">
    
    <pre><code><cxx-signature>constexpr T const&amp; value() const;</cxx-signature><cxx-signature>T&amp; value();</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="15" id="optional.object.observe.15">
    
    <dt>Returns:</dt><dd><code><var>*val</var></code>, if <code>bool(*this)</code>.</dd>
  </cxx-returns><cxx-throws para_num="16" id="optional.object.observe.16">
    
    <dt>Throws:</dt><dd><code>bad_optional_access</code> if <code>!*this</code>.</dd>
  </cxx-throws><cxx-remarks para_num="17" id="optional.object.observe.17">
    
    <dt>Remarks:</dt><dd>The first function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="18" id="optional.object.observe.18">
    
    <pre><code><cxx-signature>template &lt;class U&gt; constexpr T value_or(U&amp;&amp; <var>v</var>) const&amp;;</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="19" id="optional.object.observe.19">
    
    <dt>Requires:</dt><dd><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_convertible&lt;U&amp;&amp;, T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-returns para_num="20" id="optional.object.observe.20">
    
    <dt>Returns:</dt><dd><code>bool(*this) ? **this : static_cast&lt;T&gt;(std::forward&lt;U&gt;(<var>v</var>))</code>.</dd>
  </cxx-returns><cxx-throws para_num="21" id="optional.object.observe.21">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-exception-safety para_num="22" id="optional.object.observe.22">
    
    <dt>Exception safety:</dt><dd>If <code><var>init</var> == true</code> and exception is thrown during the call to <code>T</code>'s constructor, the value of <code><var>init</var></code> and <code><var>v</var></code> remains unchanged and the state of <code><var>*val</var></code> is determined by the exception safety guarantee of the selected constructor of <code>T</code>. Otherwise, when exception is thrown during the call to <code>T</code>'s constructor, the value of <code><var>*this</var></code> remains unchanged and the state of <code><var>v</var></code> is determined by the exception safety guarantee of the selected constructor of <code>T</code>.</dd>
  </cxx-exception-safety><cxx-remarks para_num="23" id="optional.object.observe.23">
    
    <dt>Remarks:</dt><dd>If the selected constructor of <code>T</code> is a <code>constexpr</code> constructor, this function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="24" id="optional.object.observe.24">
    
    <pre><code><cxx-signature>template &lt;class U&gt; T value_or(U&amp;&amp; <var>v</var>) &amp;&amp;;</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="25" id="optional.object.observe.25">
    
    <dt>Requires:</dt><dd><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_convertible&lt;U&amp;&amp;, T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-returns para_num="26" id="optional.object.observe.26">
    
    <dt>Returns:</dt><dd><code>bool(*this) ? std::move(**this) : static_cast&lt;T&gt;(std::forward&lt;U&gt;(<var>v</var>))</code>.</dd>
  </cxx-returns><cxx-throws para_num="27" id="optional.object.observe.27">
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-exception-safety para_num="28" id="optional.object.observe.28">
    
    <dt>Exception safety:</dt><dd>If <code><var>init</var> == true</code> and exception is thrown during the call to <code>T</code>'s constructor, the value of <code><var>init</var></code> and <code><var>v</var></code> remains unchanged and the state of <code><var>*val</var></code> is determined by the exception safety guarantee of the <code>T</code>'s constructor. Otherwise, when exception is thrown during the call to <code>T</code>'s constructor, the value of <code><var>*this</var></code> remains unchanged and the state of <code><var>v</var></code> is determined by the exception safety guarantee of the selected constructor of <code>T</code>.</dd>
  </cxx-exception-safety></dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.inplace">
    

    <section>
      <header><span class="section-number">2.5</span> <h1 data-bookmark-label="2.5 In-place construction">In-place construction</h1> <span style="float:right"><a href="#optional.inplace">[optional.inplace]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.inplace.1">
    
    <pre><code><cxx-signature>struct in_place_t{};</cxx-signature><cxx-signature>constexpr in_place_t in_place{};</cxx-signature></code></pre>

    <dl>
      
    </dl>
  </cxx-function>

    <p para_num="2" id="optional.inplace.2">The struct <code>in_place_t</code> is an empty structure type used as a unique type to disambiguate constructor and function overloading. Specifically, <code>optional&lt;T&gt;</code> has a constructor with <code>in_place_t</code> as the first argument followed by an argument pack; this indicates that <code>T</code> should be constructed in-place (as if by a call to placement new expression) with the forwarded argument pack as parameters.
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.nullopt">
    

    <section>
      <header><span class="section-number">2.6</span> <h1 data-bookmark-label="2.6 Disengaged state indicator">Disengaged state indicator</h1> <span style="float:right"><a href="#optional.nullopt">[optional.nullopt]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.nullopt.1">
    
    <pre><code><cxx-signature>struct nullopt_t{<em>see below</em>};</cxx-signature><cxx-signature>constexpr nullopt_t nullopt(<em>unspecified</em>);</cxx-signature></code></pre>

    <dl>
      
    </dl>
  </cxx-function>

    <p para_num="2" id="optional.nullopt.2">The struct <code>nullopt_t</code> is an empty structure type used as a unique type to indicate a disengaged state for <code>optional</code> objects. In particular, <code>optional&lt;T&gt;</code> has a constructor with <code>nullopt_t</code> as single argument; this indicates that a disengaged optional object shall be constructed.
    </p>

    <p para_num="3" id="optional.nullopt.3">Type <code>nullopt_t</code> shall not have a default constructor. It shall be a literal type. Constant <code>nullopt</code> shall be initialized with an argument of literal type.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.bad_optional_access">
    

    <section>
      <header><span class="section-number">2.7</span> <h1 data-bookmark-label="2.7 Class bad_optional_access">Class <code>bad_optional_access</code></h1> <span style="float:right"><a href="#optional.bad_optional_access">[optional.bad_optional_access]</a></span></header>
      
    

<pre>class bad_optional_access : public logic_error {
public:
  explicit bad_optional_access(const string&amp; <var>what_arg</var>);
  explicit bad_optional_access(const char* <var>what_arg</var>);
};</pre>

    <p para_num="1" id="optional.bad_optional_access.1">The class <code>bad_optional_access</code> defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of a disengaged optional object.</p>

    <cxx-function para_num="2" id="optional.bad_optional_access.2">
    
    <pre><code><cxx-signature>bad_optional_access(const string&amp; <var>what_arg</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="3" id="optional.bad_optional_access.3">
    
    <dt>Effects:</dt><dd>Constructs an object of class <code>bad_optional_access</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>

    <cxx-function para_num="4" id="optional.bad_optional_access.4">
    
    <pre><code><cxx-signature>bad_optional_access(const char* <var>what_arg</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="5" id="optional.bad_optional_access.5">
    
    <dt>Effects:</dt><dd>Constructs an object of class <code>bad_optional_access</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.relops">
    

    <section>
      <header><span class="section-number">2.8</span> <h1 data-bookmark-label="2.8 Relational operators">Relational operators</h1> <span style="float:right"><a href="#optional.relops">[optional.relops]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.relops.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, const optional&lt;T&gt;&amp; <var>y</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="2" id="optional.relops.2">
    
    <dt>Requires:</dt><dd><code>T</code> shall meet the requirements of <code>EqualityComparable</code>.</dd>
  </cxx-requires><cxx-returns para_num="3" id="optional.relops.3">
    
    <dt>Returns:</dt><dd>If <code>bool(<var>x</var>) != bool(<var>y</var>)</code>, <code>false</code>; otherwise if <code>bool(<var>x</var>) == false</code>, <code>true</code>; otherwise <code>*<var>x</var> == *<var>y</var></code>.</dd>
  </cxx-returns><cxx-remarks para_num="4" id="optional.relops.4">
    
    <dt>Remarks:</dt><dd>Instantiations of this function template for which <code>*<var>x</var> == *<var>y</var></code> is a core constant expression, shall be <code>constexpr</code> functions.</dd>
  </cxx-remarks></dl>
  </cxx-function>

    <cxx-function para_num="5" id="optional.relops.5">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, const optional&lt;T&gt;&amp; <var>y</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="6" id="optional.relops.6">
    
    <dt>Requires:</dt><dd>Expression <code>less&lt;T&gt;{}(*<var>x</var>, *<var>y</var>)</code> shall be well-formed.</dd>
  </cxx-requires><cxx-returns para_num="7" id="optional.relops.7">
    
    <dt>Returns:</dt><dd>If <code>(!<var>y</var>)</code>, <code>false</code>; otherwise, if <code>(!<var>x</var>)</code>, <code>true</code>; otherwise <code>less&lt;T&gt;{}(*<var>x</var>, *<var>y</var>)</code>.</dd>
  </cxx-returns><cxx-remarks para_num="8" id="optional.relops.8">
    
    <dt>Remarks:</dt><dd>Instantiations of this function template for which <code>less&lt;T&gt;{}(*<var>x</var>, *<var>y</var>)</code> is a core constant expression, shall be <code>constexpr</code> functions.</dd>
  </cxx-remarks></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.nullops">
    

    <section>
      <header><span class="section-number">2.9</span> <h1 data-bookmark-label="2.9 Comparison with nullopt">Comparison with <code>nullopt</code></h1> <span style="float:right"><a href="#optional.nullops">[optional.nullops]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.nullops.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature><cxx-signature>template &lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="2" id="optional.nullops.2">
    
    <dt>Returns:</dt><dd><code>(!<var>x</var>)</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="3" id="optional.nullops.3">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="4" id="optional.nullops.4">
    
    <dt>Returns:</dt><dd><code>false</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="5" id="optional.nullops.5">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="6" id="optional.nullops.6">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>)</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.comp_with_t">
    

    <section>
      <header><span class="section-number">2.10</span> <h1 data-bookmark-label="2.10 Comparison with T">Comparison with <code>T</code></h1> <span style="float:right"><a href="#optional.comp_with_t">[optional.comp_with_t]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.comp_with_t.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="2" id="optional.comp_with_t.2">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? *<var>x</var> == <var>v</var> : false</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="3" id="optional.comp_with_t.3">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="4" id="optional.comp_with_t.4">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? <var>v</var> == *<var>x</var> : false</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="5" id="optional.comp_with_t.5">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="6" id="optional.comp_with_t.6">
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? less&lt;T&gt;{}(*<var>x</var>, <var>v</var>) : true</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.specalg">
    

    <section>
      <header><span class="section-number">2.11</span> <h1 data-bookmark-label="2.11 Specialized algorithms">Specialized algorithms</h1> <span style="float:right"><a href="#optional.specalg">[optional.specalg]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.specalg.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; <var>x</var>, optional&lt;T&gt;&amp; <var>y</var>) noexcept(noexcept(<var>x</var>.swap(<var>y</var>)));</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="2" id="optional.specalg.2">
    
    <dt>Effects:</dt><dd>calls <code><var>x</var>.swap(<var>y</var>)</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>

    <cxx-function para_num="3" id="optional.specalg.3">
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr optional&lt;typename decay&lt;T&gt;::type&gt; make_optional(T&amp;&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="4" id="optional.specalg.4">
    
    <dt>Returns:</dt><dd><code>optional&lt;typename decay&lt;T&gt;::type&gt;(std::forward&lt;T&gt;(<var>v</var>))</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.hash">
    

    <section>
      <header><span class="section-number">2.12</span> <h1 data-bookmark-label="2.12 Hash support">Hash support</h1> <span style="float:right"><a href="#optional.hash">[optional.hash]</a></span></header>
      
    

    <cxx-function para_num="1" id="optional.hash.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; struct hash&lt;experimental::optional&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="2" id="optional.hash.2">
    
    <dt>Requires:</dt><dd>the template specialization <code>hash&lt;T&gt;</code> shall meet the requirements of class template <code>hash</code> (<cxx-ref in="cxx" to="unord.hash">C++11 §20.8.12</cxx-ref>).
      The template specialization <code>hash&lt;optional&lt;T&gt;&gt;</code> shall meet the requirements of class template <code>hash</code>.
      For an object <code><var>o</var></code> of type <code>optional&lt;T&gt;</code>, if <code>bool(<var>o</var>) == true</code>,
      <code>hash&lt;optional&lt;T&gt;&gt;()(<var>o</var>)</code> shall evaluate to the same value as <code>hash&lt;T&gt;()(*<var>o</var>)</code>.</dd>
  </cxx-requires></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="string.view">
    

    <section>
      <header><span class="section-number">3</span> <h1 data-bookmark-label="3 string_view"><code>string_view</code></h1> <span style="float:right"><a href="#string.view">[string.view]</a></span></header>
      
  

  <p para_num="1" id="string.view.1">
    The class template <code>basic_string_view</code> describes an object that can refer to a constant contiguous sequence of char-like (<cxx-ref in="cxx" to="strings.general">C++11 §21.1</cxx-ref>) objects with the first element of the sequence at position zero.
    In the rest of this section, the type of the char-like objects held in a <code>basic_string_view</code> object is designated by <code>charT</code>.
  </p>

  <p para_num="2" id="string.view.2">
    <cxx-note>[ <em>Note:</em> The library provides implicit conversions from <code>const charT*</code> and <code>std::basic_string&lt;charT, ...&gt;</code> to <code>std::basic_string_view&lt;charT, ...&gt;</code> so that user code can accept just <code>std::basic_string_view&lt;charT&gt;</code> as a non-templated parameter wherever a sequence of characters is expected.
    User-defined types should define their own implicit conversions to <code>std::basic_string_view</code> in order to interoperate with these functions. — <em>end note</em> ]</cxx-note>
  </p>

  <p para_num="3" id="string.view.3">
    The complexity of <code>basic_string_view</code> member functions is O(1) unless otherwise specified.
  </p>

  <cxx-section id="string.view.synop">
    

    <section>
      <header><span class="section-number">3.1</span> <h1 data-bookmark-label="3.1 Header <experimental/string_view> synopsis">Header <code>&lt;experimental/string_view&gt;</code> synopsis</h1> <span style="float:right"><a href="#string.view.synop">[string.view.synop]</a></span></header>
      
    

    <pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
  <cxx-ref insynopsis="" to="string.view.template">// <i><a href="#string.view.template">3.2</a>, Class template basic_string_view</i></cxx-ref>
  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
      class basic_string_view;

  <cxx-ref insynopsis="" to="string.view.comparison">// <i><a href="#string.view.comparison">3.9</a>, basic_string_view non-member comparison functions</i></cxx-ref>
  template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; x,
                            basic_string_view&lt;charT, traits&gt; y) noexcept;
  template&lt;class charT, class traits&gt;
  constexpr bool operator!=(basic_string_view&lt;charT, traits&gt; x,
                            basic_string_view&lt;charT, traits&gt; y) noexcept;
  template&lt;class charT, class traits&gt;
  constexpr bool operator&lt; (basic_string_view&lt;charT, traits&gt; x,
                               basic_string_view&lt;charT, traits&gt; y) noexcept;
  template&lt;class charT, class traits&gt;
  constexpr bool operator&gt; (basic_string_view&lt;charT, traits&gt; x,
                            basic_string_view&lt;charT, traits&gt; y) noexcept;
  template&lt;class charT, class traits&gt;
  constexpr bool operator&lt;=(basic_string_view&lt;charT, traits&gt; x,
                               basic_string_view&lt;charT, traits&gt; y) noexcept;
  template&lt;class charT, class traits&gt;
  constexpr bool operator&gt;=(basic_string_view&lt;charT, traits&gt; x,
                            basic_string_view&lt;charT, traits&gt; y) noexcept;
  // <i>see below</i>, sufficient additional overloads of comparison functions

  <cxx-ref insynopsis="" to="string.view.io">// <i><a href="#string.view.io">3.10</a>, Inserters and extractors</i></cxx-ref>
  template&lt;class charT, class traits&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
                 basic_string_view&lt;charT, traits&gt; str);

  // basic_string_view typedef names
  typedef basic_string_view&lt;char&gt; string_view;
  typedef basic_string_view&lt;char16_t&gt; u16string_view;
  typedef basic_string_view&lt;char32_t&gt; u32string_view;
  typedef basic_string_view&lt;wchar_t&gt; wstring_view;

}  // namespace fundamentals_v1
}  // namespace experimental

  <cxx-ref insynopsis="" to="string.view.hash">// <i><a href="#string.view.hash">3.11</a>, Hash support</i></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;&gt; struct hash&lt;experimental::string_view&gt;;
  template &lt;&gt; struct hash&lt;experimental::u16string_view&gt;;
  template &lt;&gt; struct hash&lt;experimental::u32string_view&gt;;
  template &lt;&gt; struct hash&lt;experimental::wstring_view&gt;;
}  // namespace std</code></pre>

    <p para_num="1" id="string.view.synop.1">
      The function templates defined in <cxx-ref in="cxx" to="utility.swap">C++11 §20.2.2</cxx-ref> and <cxx-ref in="cxx" to="iterator.range">C++11 §24.6.5</cxx-ref> are available when <code>&lt;experimental/string_view&gt;</code> is included.
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.template">
    

    <section>
      <header><span class="section-number">3.2</span> <h1 data-bookmark-label="3.2 Class template basic_string_view">Class template <code>basic_string_view</code></h1> <span style="float:right"><a href="#string.view.template">[string.view.template]</a></span></header>
      
    

    <pre><code>namespace std {
namespace experimental {
namespace fundamentals_v1 {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
  class basic_string_view {
    public:
    // types
    typedef traits traits_type;
    typedef charT value_type;
    typedef charT* pointer;
    typedef const charT* const_pointer;
    typedef charT&amp; reference;
    typedef const charT&amp; const_reference;
    typedef <var>implementation-defined</var> const_iterator; // See <cxx-ref to="string.view.iterators"><a href="#string.view.iterators">3.4</a></cxx-ref>
    typedef const_iterator iterator;<cxx-footnote><!--
    Be sure not to introduce whitespace here, as it appears around the footnote.
  --><sup id="footnote-call-1"><a href="#footnote-body-1">1</a></sup><aside class="footnote" id="footnote-body-1"><span class="marker"><a href="#footnote-call-1">1</a>) </span>Because <code>basic_string_view</code> refers to a constant sequence, <code>iterator</code> and <code>const_iterator</code> are the same type.</aside></cxx-footnote>
    typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
    typedef const_reverse_iterator reverse_iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    static constexpr size_type npos = size_type(-1);

    <cxx-ref insynopsis="" to="string.view.cons">// <i><a href="#string.view.cons">3.3</a>, basic_string_view constructors and assignment operators</i></cxx-ref>
    constexpr basic_string_view() noexcept;
    constexpr basic_string_view(const basic_string_view&amp;) noexcept = default;
    basic_string_view&amp; operator=(const basic_string_view&amp;) noexcept = default;
    template&lt;class Allocator&gt;
    basic_string_view(const basic_string&lt;charT, traits, Allocator&gt;&amp; str) noexcept;
    constexpr basic_string_view(const charT* str);
    constexpr basic_string_view(const charT* str, size_type len);

    <cxx-ref insynopsis="" to="string.view.iterators">// <i><a href="#string.view.iterators">3.4</a>, basic_string_view iterator support</i></cxx-ref>
    constexpr const_iterator begin() const noexcept;
    constexpr const_iterator end() const noexcept;
    constexpr const_iterator cbegin() const noexcept;
    constexpr const_iterator cend() const noexcept;
    const_reverse_iterator rbegin() const noexcept;
    const_reverse_iterator rend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    <cxx-ref insynopsis="" to="string.view.capacity">// <i><a href="#string.view.capacity">3.5</a>, basic_string_view capacity</i></cxx-ref>
    constexpr size_type size() const noexcept;
    constexpr size_type length() const noexcept;
    constexpr size_type max_size() const noexcept;
    constexpr bool empty() const noexcept;

    <cxx-ref insynopsis="" to="string.view.access">// <i><a href="#string.view.access">3.6</a>, basic_string_view element access</i></cxx-ref>
    constexpr const_reference operator[](size_type pos) const;
    constexpr const_reference at(size_type pos) const;
    constexpr const_reference front() const;
    constexpr const_reference back() const;
    constexpr const_pointer data() const noexcept;

    <cxx-ref insynopsis="" to="string.view.modifiers">// <i><a href="#string.view.modifiers">3.7</a>, basic_string_view modifiers</i></cxx-ref>
    constexpr void clear() noexcept;
    constexpr void remove_prefix(size_type n);
    constexpr void remove_suffix(size_type n);
    constexpr void swap(basic_string_view&amp; s) noexcept;

    <cxx-ref insynopsis="" to="string.view.ops">// <i><a href="#string.view.ops">3.8</a>, basic_string_view string operations</i></cxx-ref>
    template&lt;class Allocator&gt;
    explicit operator basic_string&lt;charT, traits, Allocator&gt;() const;
    template&lt;class Allocator = allocator&lt;charT&gt; &gt;
    basic_string&lt;charT, traits, Allocator&gt; to_string(
      const Allocator&amp; a = Allocator()) const;

    size_type copy(charT* s, size_type n, size_type pos = 0) const;

    constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;
    constexpr int compare(basic_string_view s) const noexcept;
    constexpr int compare(size_type pos1, size_type n1, basic_string_view s) const;
    constexpr int compare(size_type pos1, size_type n1,
                          basic_string_view s, size_type pos2, size_type n2) const;
    constexpr int compare(const charT* s) const;
    constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
    constexpr int compare(size_type pos1, size_type n1,
                          const charT* s, size_type n2) const;
    constexpr size_type find(basic_string_view s, size_type pos = 0) const noexcept;
    constexpr size_type find(charT c, size_type pos = 0) const noexcept;
    constexpr size_type find(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find(const charT* s, size_type pos = 0) const;
    constexpr size_type rfind(basic_string_view s, size_type pos = npos) const noexcept;
    constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;
    constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;
    constexpr size_type rfind(const charT* s, size_type pos = npos) const;
    constexpr size_type find_first_of(basic_string_view s, size_type pos = 0) const noexcept;
    constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
    constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;
    constexpr size_type find_last_of(basic_string_view s, size_type pos = npos) const noexcept;
    constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;
    constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;
    constexpr size_type find_first_not_of(basic_string_view s, size_type pos = 0) const noexcept;
    constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
    constexpr size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;
    constexpr size_type find_last_not_of(basic_string_view s, size_type pos = npos) const noexcept;
    constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
    constexpr size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;

   private:
    const_pointer data_;  // <em>exposition only</em>
    size_type     size_;  // <em>exposition only</em>
  };
}  // namespace fundamentals_v1
}  // namespace experimental
}  // namespace std</code></pre>

    <p para_num="1" id="string.view.template.1">
      In every specialization <code>basic_string_view&lt;charT, traits&gt;</code>, the type <code>traits</code> shall satisfy the character traits requirements (<cxx-ref in="cxx" to="char.traits">C++11 §21.2</cxx-ref>),
      and the type <code>traits::char_type</code> shall name the same type as <code>charT</code>.
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.cons">
    

    <section>
      <header><span class="section-number">3.3</span> <h1 data-bookmark-label="3.3 basic_string_view constructors and assignment operators"><code>basic_string_view</code> constructors and assignment operators</h1> <span style="float:right"><a href="#string.view.cons">[string.view.cons]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.cons.1">
    
    <pre><code><cxx-signature>constexpr basic_string_view() noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="2" id="string.view.cons.2">
    
    <dt>Effects:</dt><dd>Constructs an empty <code>basic_string_view</code>.</dd>
  </cxx-effects><cxx-postconditions para_num="3" id="string.view.cons.3">
    
    <dt>Postconditions:</dt><dd><code>size_ == 0</code> and <code>data_ == nullptr</code>.</dd>
  </cxx-postconditions></dl>
  </cxx-function>

    <cxx-function para_num="4" id="string.view.cons.4">
    
    <pre><code><cxx-signature>template&lt;class Allocator&gt; <wbr>basic_string_view(const basic_string&lt;charT, traits, Allocator&gt;&amp; str) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="5" id="string.view.cons.5">
    
    <dt>Effects:</dt><dd>Constructs a <code>basic_string_view</code>, with the postconditions in <cxx-ref to="tab:string.view.ctr.1"><a href="#tab:string.view.ctr.1">Table 2</a></cxx-ref>.</dd>
  </cxx-effects><table is="cxx-table" id="tab:string.view.ctr.1">
    

    <caption>Table 2 — <wbr><caption><code>basic_string_view(const basic_string&amp;)</code> effects</caption></caption>
    
        
        <tbody><tr><th>Element</th><th>Value</th></tr>
        <tr><td><code>data_</code></td><td><code>str.data()</code></td></tr>
        <tr><td><code>size_</code></td><td><code>str.size()</code></td></tr>
      </tbody>
  </table></dl>
  </cxx-function>

    <cxx-function para_num="6" id="string.view.cons.6">
    
    <pre><code><cxx-signature>constexpr basic_string_view(const charT* str);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="7" id="string.view.cons.7">
    
    <dt>Requires:</dt><dd><cxx-range begin="str" end="str + traits::length(str)">[<code>str</code>, <code>str + traits::length(str)</code>)</cxx-range> is a valid range.</dd>
  </cxx-requires><cxx-effects para_num="8" id="string.view.cons.8">
    
    <dt>Effects:</dt><dd>Constructs a <code>basic_string_view</code> referring to the same string as <code>str</code>, with the postconditions
      in <cxx-ref to="tab:string.view.ctr.2"><a href="#tab:string.view.ctr.2">Table 3</a></cxx-ref>.</dd>
  </cxx-effects><table is="cxx-table" id="tab:string.view.ctr.2">
    

    <caption>Table 3 — <wbr><caption>basic_string_view(const charT*) effects</caption></caption>
    
      <tbody><tr><th>Element</th><th>Value</th></tr>
      <tr><td><code>data_</code></td><td><code>str</code></td></tr>
      <tr><td><code>size_</code></td><td><code>traits::length(str)</code></td></tr>
      </tbody>
  </table></dl>
  </cxx-function>

    <cxx-function para_num="9" id="string.view.cons.9">
    
    <pre><code><cxx-signature>constexpr basic_string_view(const charT* str, size_type len);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="10" id="string.view.cons.10">
    
    <dt>Requires:</dt><dd><cxx-range begin="str" end="str + len">[<code>str</code>, <code>str + len</code>)</cxx-range> is a valid range.</dd>
  </cxx-requires><cxx-effects para_num="11" id="string.view.cons.11">
    
    <dt>Effects:</dt><dd>Constructs a <code>basic_string_view</code>, with the postconditions in <cxx-ref to="tab:string.view.ctr.3"><a href="#tab:string.view.ctr.3">Table 4</a></cxx-ref>.</dd>
  </cxx-effects><table is="cxx-table" id="tab:string.view.ctr.3">
    

    <caption>Table 4 — <wbr><caption><code>basic_string_view(const charT*, size_type)</code> effects</caption></caption>
    
        <tbody><tr><th>Element</th><th>Value</th></tr>
        <tr><td><code>data_</code></td><td><code>str</code></td></tr>
        <tr><td><code>size_</code></td><td><code>len</code></td></tr>
      </tbody>
  </table></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.iterators">
    

    <section>
      <header><span class="section-number">3.4</span> <h1 data-bookmark-label="3.4 basic_string_view iterator support"><code>basic_string_view</code> iterator support</h1> <span style="float:right"><a href="#string.view.iterators">[string.view.iterators]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.iterators.1">
    
    <pre><code><cxx-signature>typedef <var>implementation-defined</var> const_iterator;</cxx-signature></code></pre>

    <dl>
      <p para_num="2" id="string.view.iterators.2">
        A constant random-access iterator type such that, for a <code>const_iterator it</code>, if <code>&amp;*(it+N)</code> is valid, then it is equal to <code>(&amp;*it)+N</code>.
      </p><p para_num="3" id="string.view.iterators.3">
        For a <code>basic_string_view str</code>, any operation that invalidates a pointer in the range <cxx-range begin="str.data()" end="str.data()+str.size()">[<code>str.data()</code>, <code>str.data()+str.size()</code>)</cxx-range> invalidates pointers, iterators, and references returned from <code>str</code>'s methods.
      </p><p para_num="4" id="string.view.iterators.4">
        All requirements on container iterators (<cxx-ref in="cxx" to="container.requirements">C++11 §23.2</cxx-ref>) apply to <code>basic_string_view::const_iterator</code> as well.
      </p></dl>
  </cxx-function>

    <cxx-function para_num="5" id="string.view.iterators.5">
    
    <pre><code><cxx-signature>constexpr const_iterator begin() const noexcept;</cxx-signature><cxx-signature>constexpr const_iterator cbegin() const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="6" id="string.view.iterators.6">
    
    <dt>Returns:</dt><dd>An iterator such that <code>&amp;*begin() == data_</code> if <code>!empty()</code>,
      or else an unspecified value such that <cxx-range begin="begin()" end="end()">[<code>begin()</code>, <code>end()</code>)</cxx-range> is a valid range.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="7" id="string.view.iterators.7">
    
    <pre><code><cxx-signature>constexpr const_iterator end() const noexcept;</cxx-signature><cxx-signature>constexpr const_iterator cend() const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="8" id="string.view.iterators.8">
    
    <dt>Returns:</dt><dd> <code>begin() + size()</code></dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="9" id="string.view.iterators.9">
    
    <pre><code><cxx-signature>const_reverse_iterator rbegin() const noexcept;</cxx-signature><cxx-signature>const_reverse_iterator crbegin() const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="10" id="string.view.iterators.10">
    
    <dt>Returns:</dt><dd> <code>const_reverse_iterator(end())</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="11" id="string.view.iterators.11">
    
    <pre><code><cxx-signature>const_reverse_iterator rend() const noexcept;</cxx-signature><cxx-signature>const_reverse_iterator crend() const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="12" id="string.view.iterators.12">
    
    <dt>Returns:</dt><dd><code>const_reverse_iterator(begin())</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.capacity">
    

    <section>
      <header><span class="section-number">3.5</span> <h1 data-bookmark-label="3.5 basic_string_view capacity"><code>basic_string_view</code> capacity</h1> <span style="float:right"><a href="#string.view.capacity">[string.view.capacity]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.capacity.1">
    
    <pre><code><cxx-signature>constexpr size_type size() const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="2" id="string.view.capacity.2">
    
    <dt>Returns:</dt><dd><code>size_</code></dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="3" id="string.view.capacity.3">
    
    <pre><code><cxx-signature>constexpr size_type length() const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="4" id="string.view.capacity.4">
    
    <dt>Returns:</dt><dd><code>size_</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="5" id="string.view.capacity.5">
    
    <pre><code><cxx-signature>constexpr size_type max_size() const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="6" id="string.view.capacity.6">
    
    <dt>Returns:</dt><dd>The largest possible number of char-like objects that can be referred to by a <code>basic_string_view</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="7" id="string.view.capacity.7">
    
    <pre><code><cxx-signature>constexpr bool empty() const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="8" id="string.view.capacity.8">
    
    <dt>Returns:</dt><dd><code>size_ == 0</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.access">
    

    <section>
      <header><span class="section-number">3.6</span> <h1 data-bookmark-label="3.6 basic_string_view element access"><code>basic_string_view</code> element access</h1> <span style="float:right"><a href="#string.view.access">[string.view.access]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.access.1">
    
    <pre><code><cxx-signature>constexpr const_reference operator[](size_type pos) const;</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="2" id="string.view.access.2">
    
    <dt>Requires:</dt><dd><code>pos &lt; size()</code>.</dd>
  </cxx-requires><cxx-returns para_num="3" id="string.view.access.3">
    
    <dt>Returns:</dt><dd><code>data_[pos]</code></dd>
  </cxx-returns><cxx-throws para_num="4" id="string.view.access.4">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws><p para_num="5" id="string.view.access.5"><cxx-note>[ <em>Note:</em> Unlike <code>basic_string::operator[]</code>,
        <code>basic_string_view::operator[](size())</code> has undefined behavior instead of returning <code>charT()</code>. — <em>end note</em> ]</cxx-note></p></dl>
  </cxx-function>

    <cxx-function para_num="6" id="string.view.access.6">
    
    <pre><code><cxx-signature>constexpr const_reference at(size_type pos) const;</cxx-signature></code></pre>

    <dl>
      <cxx-throws para_num="7" id="string.view.access.7">
    
    <dt>Throws:</dt><dd><code>out_of_range</code> if <code>pos &gt;= size()</code>.</dd>
  </cxx-throws><cxx-returns para_num="8" id="string.view.access.8">
    
    <dt>Returns:</dt><dd><code>data_[pos]</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="9" id="string.view.access.9">
    
    <pre><code><cxx-signature>constexpr const_reference front() const;</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="10" id="string.view.access.10">
    
    <dt>Requires:</dt><dd><code>!empty()</code></dd>
  </cxx-requires><cxx-returns para_num="11" id="string.view.access.11">
    
    <dt>Returns:</dt><dd><code>data_[0]</code>.</dd>
  </cxx-returns><cxx-throws para_num="12" id="string.view.access.12">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws></dl>
  </cxx-function>

    <cxx-function para_num="13" id="string.view.access.13">
    
    <pre><code><cxx-signature>constexpr const_reference back() const;</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="14" id="string.view.access.14">
    
    <dt>Requires:</dt><dd><code>!empty()</code></dd>
  </cxx-requires><cxx-returns para_num="15" id="string.view.access.15">
    
    <dt>Returns:</dt><dd><code>data_[size() - 1]</code>.</dd>
  </cxx-returns><cxx-throws para_num="16" id="string.view.access.16">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws></dl>
  </cxx-function>

    <cxx-function para_num="17" id="string.view.access.17">
    
    <pre><code><cxx-signature>constexpr const_pointer data() const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="18" id="string.view.access.18">
    
    <dt>Returns:</dt><dd><code>data_</code></dd>
  </cxx-returns><p para_num="19" id="string.view.access.19"><cxx-note>[ <em>Note:</em> Unlike <code>basic_string::data()</code> and string literals,
      <code>data()</code> may return a pointer to a buffer that is not null-terminated.
      Therefore it is typically a mistake to pass <code>data()</code> to a routine that takes just a <code>const charT*</code> and expects a null-terminated string. — <em>end note</em> ]</cxx-note></p></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.modifiers">
    

    <section>
      <header><span class="section-number">3.7</span> <h1 data-bookmark-label="3.7 basic_string_view modifiers"><code>basic_string_view</code> modifiers</h1> <span style="float:right"><a href="#string.view.modifiers">[string.view.modifiers]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.modifiers.1">
    
    <pre><code><cxx-signature>constexpr void clear() noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="2" id="string.view.modifiers.2">
    
    <dt>Effects:</dt><dd>Equivalent to <code>*this = basic_string_view()</code></dd>
  </cxx-effects></dl>
  </cxx-function>

    <cxx-function para_num="3" id="string.view.modifiers.3">
    
    <pre><code><cxx-signature>constexpr void remove_prefix(size_type n);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="4" id="string.view.modifiers.4">
    
    <dt>Requires:</dt><dd><code>n &lt;= size()</code></dd>
  </cxx-requires><cxx-effects para_num="5" id="string.view.modifiers.5">
    
    <dt>Effects:</dt><dd>Equivalent to <code>data_ += n; size_ -= n;</code></dd>
  </cxx-effects></dl>
  </cxx-function>

    <cxx-function para_num="6" id="string.view.modifiers.6">
    
    <pre><code><cxx-signature>constexpr void remove_suffix(size_type n);</cxx-signature></code></pre>

    <dl>
      <cxx-requires para_num="7" id="string.view.modifiers.7">
    
    <dt>Requires:</dt><dd><code>n &lt;= size()</code></dd>
  </cxx-requires><cxx-effects para_num="8" id="string.view.modifiers.8">
    
    <dt>Effects:</dt><dd>Equivalent to <code>size_ -= n;</code></dd>
  </cxx-effects></dl>
  </cxx-function>

    <cxx-function para_num="9" id="string.view.modifiers.9">
    
    <pre><code><cxx-signature>constexpr void swap(basic_string_view&amp; s) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="10" id="string.view.modifiers.10">
    
    <dt>Effects:</dt><dd>Exchanges the values of <code>*this</code> and <code>s</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.ops">
    

    <section>
      <header><span class="section-number">3.8</span> <h1 data-bookmark-label="3.8 basic_string_view string operations"><code>basic_string_view</code> string operations</h1> <span style="float:right"><a href="#string.view.ops">[string.view.ops]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.ops.1">
    
    <pre><code><cxx-signature>template&lt;class Allocator&gt;
explicit<cxx-footnote><!--
    Be sure not to introduce whitespace here, as it appears around the footnote.
  --><sup id="footnote-call-2"><a href="#footnote-body-2">2</a></sup><aside class="footnote" id="footnote-body-2"><span class="marker"><a href="#footnote-call-2">2</a>) </span>This conversion is explicit to avoid accidental O(N) operations on type mismatches.</aside></cxx-footnote> operator basic_string&lt;
    charT, traits, Allocator&gt;() const;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="2" id="string.view.ops.2">
    
    <dt>Effects:</dt><dd>Equivalent to <code>basic_string&lt;charT, traits, Allocator&gt;(begin(), end()).</code></dd>
  </cxx-effects><p para_num="3" id="string.view.ops.3"><cxx-note>[ <em>Note:</em> Users who want to control the allocator instance should call <code>to_string(allocator)</code>. — <em>end note</em> ]</cxx-note></p></dl>
  </cxx-function>

    <cxx-function para_num="4" id="string.view.ops.4">
    
    <pre><code><cxx-signature>template&lt;class Allocator = allocator&lt;charT&gt;&gt;
basic_string&lt;charT, traits, Allocator&gt; to_string(
    const Allocator&amp; a = Allocator()) const;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="5" id="string.view.ops.5">
    
    <dt>Returns:</dt><dd><code>basic_string&lt;charT, traits, Allocator&gt;(begin(), end(), a)</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="6" id="string.view.ops.6">
    
    <pre><code><cxx-signature>size_type copy(charT* s, size_type n, size_type pos = 0) const;</cxx-signature></code></pre>

    <dl>
      <p para_num="7" id="string.view.ops.7">Let <code>rlen</code> be the smaller of <code>n</code> and <code>size() - pos</code>.</p><cxx-throws para_num="8" id="string.view.ops.8">
    
    <dt>Throws:</dt><dd><code>out_of_range</code> if <code>pos &gt; size()</code>.</dd>
  </cxx-throws><cxx-requires para_num="9" id="string.view.ops.9">
    
    <dt>Requires:</dt><dd><cxx-range begin="s" end="s + rlen">[<code>s</code>, <code>s + rlen</code>)</cxx-range> is a valid range.</dd>
  </cxx-requires><cxx-effects para_num="10" id="string.view.ops.10">
    
    <dt>Effects:</dt><dd>Equivalent to <code>std::copy_n(begin() + pos, rlen, s).</code></dd>
  </cxx-effects><cxx-returns para_num="11" id="string.view.ops.11">
    
    <dt>Returns:</dt><dd><code>rlen</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="12" id="string.view.ops.12">
    
    <pre><code><cxx-signature>constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;</cxx-signature></code></pre>

    <dl>
      <cxx-throws para_num="13" id="string.view.ops.13">
    
    <dt>Throws:</dt><dd><code>out_of_range</code> if <code>pos &gt; size()</code>.</dd>
  </cxx-throws><cxx-effects para_num="14" id="string.view.ops.14">
    
    <dt>Effects:</dt><dd>Determines the effective length <code><var>rlen</var></code> of the string to reference as the smaller of <code>n</code> and <code>size() - pos</code>.</dd>
  </cxx-effects><cxx-returns para_num="15" id="string.view.ops.15">
    
    <dt>Returns:</dt><dd><code>basic_string_view(data()+pos, <var>rlen</var>)</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="16" id="string.view.ops.16">
    
    <pre><code><cxx-signature>constexpr int compare(basic_string_view str) const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="17" id="string.view.ops.17">
    
    <dt>Effects:</dt><dd>Determines the effective length <code><var>rlen</var></code> of the strings to compare as the smaller of <code>size()</code> and <code>str.size()</code>.
        The function then compares the two strings by calling <code>traits::compare(data(), str.data(), <var>rlen</var>)</code>.</dd>
  </cxx-effects><cxx-returns para_num="18" id="string.view.ops.18">
    
    <dt>Returns:</dt><dd>The nonzero result if the result of the comparison is nonzero.
        Otherwise, returns a value as indicated in <cxx-ref to="tab:string.view.compare"><a href="#tab:string.view.compare">Table 5</a></cxx-ref>.</dd>
  </cxx-returns><table is="cxx-table" id="tab:string.view.compare" class="center">
    

    <caption>Table 5 — <wbr><caption><code>compare()</code> results</caption></caption>
    
        
        <tbody><tr><th>Condition</th><th>Return Value</th></tr>
        <tr><td><code>size() &lt; str.size()</code></td><td><code>&lt; 0</code></td></tr>
        <tr><td><code>size() == str.size()</code></td><td><code>&nbsp; 0</code></td></tr>
        <tr><td><code>size() &gt;  str.size()</code></td><td><code>&gt; 0</code></td></tr>
      </tbody>
  </table></dl>
  </cxx-function>

    <cxx-function para_num="19" id="string.view.ops.19">
    
    <pre><code><cxx-signature>constexpr int compare(size_type pos1, size_type n1, basic_string_view str) const;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="20" id="string.view.ops.20">
    
    <dt>Effects:</dt><dd>Equivalent to <code>substr(pos1, n1).compare(str)</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>

    <cxx-function para_num="21" id="string.view.ops.21">
    
    <pre><code><cxx-signature>constexpr int compare(size_type pos1, size_type n1, basic_string_view str,
                      size_type pos2, size_type n2) const;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="22" id="string.view.ops.22">
    
    <dt>Effects:</dt><dd>Equivalent to <code>substr(pos1, n1).compare(str.substr(pos2, n2))</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>

    <cxx-function para_num="23" id="string.view.ops.23">
    
    <pre><code><cxx-signature>constexpr int compare(const charT* s) const;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="24" id="string.view.ops.24">
    
    <dt>Effects:</dt><dd>Equivalent to <code>compare(basic_string_view(s))</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>
    
    <cxx-function para_num="25" id="string.view.ops.25">
    
    <pre><code><cxx-signature>constexpr int compare(size_type pos1, size_type n1, const charT* s) const;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="26" id="string.view.ops.26">
    
    <dt>Effects:</dt><dd>Equivalent to <code>substr(pos1, n1).compare(basic_string_view(s))</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>
    
    <cxx-function para_num="27" id="string.view.ops.27">
    
    <pre><code><cxx-signature>constexpr int compare(size_type pos1, size_type n1,
                      const charT* s, size_type n2) const;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="28" id="string.view.ops.28">
    
    <dt>Effects:</dt><dd>Equivalent to <code>substr(pos1, n1).compare(basic_string_view(s, n2))</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>

    <cxx-section id="string.view.find">
    

    <section>
      <header><span class="section-number">3.8.1</span> <h1 data-bookmark-label="3.8.1 Searching basic_string_view">Searching <code>basic_string_view</code></h1> <span style="float:right"><a href="#string.view.find">[string.view.find]</a></span></header>
      
      

      <p para_num="1" id="string.view.find.1">This section specifies the <code>basic_string_view</code> member functions named
        <code>find</code>, <code>rfind</code>, <code>find_first_of</code>, <code>find_last_of</code>, <code>find_first_not_of</code>, and <code>find_last_not_of</code>.</p>

      <p para_num="2" id="string.view.find.2">Member functions in this section have complexity O(<code>size() * str.size()</code>) at worst,
        although implementations are encouraged to do better.</p>

      <p para_num="3" id="string.view.find.3">Each member function of the form</p>
      <pre><code>constexpr <var>return-type fx1</var>(const charT* s, size_type pos);</code></pre>
      <p class="cont">is equivalent to <code><var>fx1</var>(basic_string_view(s), pos)</code>.</p>

      <p para_num="4" id="string.view.find.4">Each member function of the form</p>
      <pre><code>constexpr <var>return-type fx1</var>(const charT* s, size_type pos, size_type n);</code></pre>
      <p class="cont">is equivalent to <code><var>fx1</var>(basic_string_view(s, n), pos)</code>.</p>

      <p para_num="5" id="string.view.find.5">Each member function of the form</p>
      <pre><code>constexpr <var>return-type fx2</var>(charT c, size_type pos);</code></pre>
      <p class="cont">is equivalent to <code><var>fx2</var>(basic_string_view(&amp;c, 1), pos)</code>.</p>

      <cxx-function para_num="6" id="string.view.find.6">
    
    <pre><code><cxx-signature>constexpr size_type find(basic_string_view str, size_type pos = 0) const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="7" id="string.view.find.7">
    
    <dt>Effects:</dt><dd>
          Determines the lowest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>pos &lt;= xpos</code></li>
            <li><code>xpos + str.size() &lt;= size()</code></li>
            <li><code>traits::eq(at(xpos+I), str.at(I))</code> for all elements <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-returns para_num="8" id="string.view.find.8">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns><cxx-remarks para_num="9" id="string.view.find.9">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="10" id="string.view.find.10">
    
    <pre><code><cxx-signature>constexpr size_type rfind(basic_string_view str, size_type pos = npos) const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="11" id="string.view.find.11">
    
    <dt>Effects:</dt><dd>
          Determines the highest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>xpos &lt;= pos</code></li>
            <li><code>xpos + str.size() &lt;= size()</code></li>
            <li><code>traits::eq(at(xpos+I), str.at(I))</code> for all elements <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-returns para_num="12" id="string.view.find.12">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns><cxx-remarks para_num="13" id="string.view.find.13">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="14" id="string.view.find.14">
    
    <pre><code><cxx-signature>constexpr size_type find_first_of(basic_string_view str, size_type pos = 0) const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="15" id="string.view.find.15">
    
    <dt>Effects:</dt><dd>Determines the lowest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>pos &lt;= xpos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for some element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-returns para_num="16" id="string.view.find.16">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns><cxx-remarks para_num="17" id="string.view.find.17">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="18" id="string.view.find.18">
    
    <pre><code><cxx-signature>constexpr size_type find_last_of(basic_string_view str, size_type pos = npos) const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="19" id="string.view.find.19">
    
    <dt>Effects:</dt><dd>Determines the highest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>xpos &lt;= pos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for some element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-returns para_num="20" id="string.view.find.20">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns><cxx-remarks para_num="21" id="string.view.find.21">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="22" id="string.view.find.22">
    
    <pre><code><cxx-signature>constexpr size_type find_first_not_of(basic_string_view str, size_type pos = 0) const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="23" id="string.view.find.23">
    
    <dt>Effects:</dt><dd>Determines the lowest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>pos &lt;= xpos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for no element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-returns para_num="24" id="string.view.find.24">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>. Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns><cxx-remarks para_num="25" id="string.view.find.25">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function para_num="26" id="string.view.find.26">
    
    <pre><code><cxx-signature>constexpr size_type find_last_not_of(basic_string_view str, size_type pos = npos) const noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="27" id="string.view.find.27">
    
    <dt>Effects:</dt><dd>Determines the highest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>xpos &lt;= pos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for no element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-returns para_num="28" id="string.view.find.28">
    
    <dt>Returns:</dt><dd><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</dd>
  </cxx-returns><cxx-remarks para_num="29" id="string.view.find.29">
    
    <dt>Remarks:</dt><dd>Uses <code>traits::eq()</code>.</dd>
  </cxx-remarks></dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.comparison">
    

    <section>
      <header><span class="section-number">3.9</span> <h1 data-bookmark-label="3.9 basic_string_view non-member comparison functions"><code>basic_string_view</code> non-member comparison functions</h1> <span style="float:right"><a href="#string.view.comparison">[string.view.comparison]</a></span></header>
      
    

    <p para_num="1" id="string.view.comparison.1">
      Let <code>S</code> be <code>basic_string_view&lt;charT, traits&gt;</code>, and <code>sv</code> be an instance of <code>S</code>.
      Implementations shall provide sufficient additional overloads marked <code>constexpr</code> and <code>noexcept</code>
      so that an object <code><var>t</var></code> with an implicit conversion to <code>S</code> can be compared according to <cxx-ref to="tab:string.view.comparison.overloads"><a href="#tab:string.view.comparison.overloads">Table 6</a></cxx-ref>.
    </p>

    <table is="cxx-table" id="tab:string.view.comparison.overloads" class="center">
    

    <caption>Table 6 — <wbr><caption>Additional <code>basic_string_view</code> comparison overloads</caption></caption>
    
      <tbody><tr><th>Expression</th><th>Equivalent to</th></tr>
      <tr><td><code>t == sv</code></td><td><code>S(t) == sv</code></td></tr>
      <tr><td><code>sv == t</code></td><td><code>sv == S(t)</code></td></tr>
      <tr><td><code>t != sv</code></td><td><code>S(t) != sv</code></td></tr>
      <tr><td><code>sv != t</code></td><td><code>sv != S(t)</code></td></tr>
      <tr><td><code>t &lt; sv</code></td><td><code>S(t) &lt; sv</code></td></tr>
      <tr><td><code>sv &lt; t</code></td><td><code>sv &lt; S(t)</code></td></tr>
      <tr><td><code>t &gt; sv</code></td><td><code>S(t) &gt; sv</code></td></tr>
      <tr><td><code>sv &gt; t</code></td><td><code>sv &gt; S(t)</code></td></tr>
      <tr><td><code>t &lt;= sv</code></td><td><code>S(t) &lt;= sv</code></td></tr>
      <tr><td><code>sv &lt;= t</code></td><td><code>sv &lt;= S(t)</code></td></tr>
      <tr><td><code>t &gt;= sv</code></td><td><code>S(t) &gt;= sv</code></td></tr>
      <tr><td><code>sv &gt;= t</code></td><td><code>sv &gt;= S(t)</code></td></tr>
    </tbody>
  </table>

    <cxx-example>
    
    <p>[ <em>Example:</em>
    A sample conforming implementation for operator== would be:
<pre><code>template&lt;class T&gt; using __identity = typename std::decay&lt;T&gt;::type;
template&lt;class charT, class traits&gt;
constexpr bool operator==(
    basic_string_view&lt;charT, traits&gt; lhs,
    basic_string_view&lt;charT, traits&gt; rhs) noexcept {
  return lhs.compare(rhs) == 0;
}
template&lt;class charT, class traits&gt;
constexpr bool operator==(
    basic_string_view&lt;charT, traits&gt; lhs,
    __identity&lt;basic_string_view&lt;charT, traits&gt;&gt; rhs) noexcept {
  return lhs.compare(rhs) == 0;
}
template&lt;class charT, class traits&gt;
constexpr bool operator==(
    __identity&lt;basic_string_view&lt;charT, traits&gt;&gt; lhs,
    basic_string_view&lt;charT, traits&gt; rhs) noexcept {
  return lhs.compare(rhs) == 0;
}</code></pre>
    
    </p><p>— <em>end example</em> ]
  </p></cxx-example>

    <cxx-function para_num="2" id="string.view.comparison.2">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="3" id="string.view.comparison.3">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) == 0</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="4" id="string.view.comparison.4">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator!=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="5" id="string.view.comparison.5">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) != 0</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="6" id="string.view.comparison.6">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator&lt; (basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="7" id="string.view.comparison.7">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) &lt; 0</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="8" id="string.view.comparison.8">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator&gt; (basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="9" id="string.view.comparison.9">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) &gt; 0</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="10" id="string.view.comparison.10">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator&lt;=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="11" id="string.view.comparison.11">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) &lt;= 0</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function para_num="12" id="string.view.comparison.12">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  constexpr bool operator&gt;=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns para_num="13" id="string.view.comparison.13">
    
    <dt>Returns:</dt><dd> <code>lhs.compare(rhs) &gt;= 0</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.io">
    

    <section>
      <header><span class="section-number">3.10</span> <h1 data-bookmark-label="3.10 Inserters and extractors">Inserters and extractors</h1> <span style="float:right"><a href="#string.view.io">[string.view.io]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.io.1">
    
    <pre><code><cxx-signature>template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               basic_string_view&lt;charT, traits&gt; str);</cxx-signature></code></pre>

    <dl>
      <cxx-effects para_num="2" id="string.view.io.2">
    
    <dt>Effects:</dt><dd>Equivalent to <code>os &lt;&lt; str.to_string()</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="string.view.hash">
    

    <section>
      <header><span class="section-number">3.11</span> <h1 data-bookmark-label="3.11 Hash support">Hash support</h1> <span style="float:right"><a href="#string.view.hash">[string.view.hash]</a></span></header>
      
    

    <cxx-function para_num="1" id="string.view.hash.1">
    
    <pre><code><cxx-signature>template &lt;&gt; struct hash&lt;experimental::string_view&gt;;</cxx-signature><cxx-signature>template &lt;&gt; struct hash&lt;experimental::u16string_view&gt;;</cxx-signature><cxx-signature>template &lt;&gt; struct hash&lt;experimental::u32string_view&gt;;</cxx-signature><cxx-signature>template &lt;&gt; struct hash&lt;experimental::wstring_view&gt;;</cxx-signature></code></pre>

    <dl>
      <p para_num="2" id="string.view.hash.2">The template specializations shall meet the requirements of class template hash (<cxx-ref in="cxx" to="unord.hash">C++11 §20.8.12</cxx-ref>).</p></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>




</body></html>