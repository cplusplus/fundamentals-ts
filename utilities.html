<cxx-clause id="utilities">
  <h1>General utilities library</h1>

  <cxx-section id="utility">
    <h1>Utility components</h1>

    <cxx-section id="utility.synop">
      <h1>Header <code>&lt;experimental/utility></code> synopsis</h1>

<pre><code>#include &lt;utility>

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref to="utility.erased.type"></cxx-ref>, erased-type placeholder
  struct erased_type { };

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>

    </cxx-section>

    <cxx-section id="utility.erased.type">
      <h1>Class <code>erased_type</code></h1>

      <cxx-function>
        <cxx-signature>struct erased_type { };</cxx-signature>

        <p>
          The <code>erased_type</code> <code>struct</code> is an empty <code>struct</code> that serves as a placeholder for a type <code>T</code> in situations where the actual type <code>T</code> is determined at runtime.
          For example, the nested type, <code>allocator_type</code>, is an alias for <code>erased_type</code> in classes that use <i>type-erased allocators</i> (see <cxx-ref to="memory.type.erased.allocator"></cxx-ref>).
        </p>
      </cxx-function>
    </cxx-section>
  </cxx-section>

  <cxx-section id="tuple">
    <h1>Tuples</h1>

    <cxx-section id="header.tuple.synop">
      <h1>Header &lt;experimental/tuple> synopsis</h1>

<pre><code>#include &lt;tuple>

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  // See <cxx-ref in="cxx" to="tuple.helper"></cxx-ref>, tuple helper classes
  template &lt;class T> constexpr size_t tuple_size_v
    = tuple_size&lt;T>::value;

  <cxx-ref insynopsis="" to="tuple.apply"></cxx-ref>
  template &lt;class F, class Tuple>
  constexpr decltype(auto) apply(F&& f, Tuple&& t);

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    </cxx-section>

    <cxx-section id="tuple.apply">
      <h1>Calling a function with a <code>tuple</code> of arguments</h1>

      <cxx-function>
        <cxx-signature>template &lt;class F, class Tuple>
constexpr decltype(auto) apply(F&& f, Tuple&& t);</cxx-signature>

        <cxx-effects>
          <p>Given the exposition only function</p>
          <pre><code>template &lt;class F, class Tuple, size_t... I>
constexpr decltype(auto) apply_impl(  // <i>exposition only</i>
    F&& f, Tuple&& t, index_sequence&lt;I...>) {
  return <em>INVOKE</em>(std::forward&lt;F>(f), std::get&lt;I>(std::forward&lt;Tuple>(t))...);
}</code></pre>
          <p>Equivalent to</p>
          <pre><code>return apply_impl(std::forward&lt;F>(f), std::forward&lt;Tuple>(t),
    make_index_sequence&lt;tuple_size_v&lt;decay_t&lt;Tuple>>>{});</code></pre>
        </cxx-effects>
      </cxx-function>
    </cxx-section>
  </cxx-section>

  <cxx-section id="meta">
    <h1>Metaprogramming and type traits</h1>

    <cxx-section id="meta.type.synop">
      <h1>Header &lt;experimental/type_traits> synopsis</h1>

<pre><code>#include &lt;type_traits>

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  // See <cxx-ref in="cxx" to="meta.unary.cat"></cxx-ref>, primary type categories
  template &lt;class T> constexpr bool is_void_v
    = is_void&lt;T>::value;
  template &lt;class T> constexpr bool is_null_pointer_v
    = is_null_pointer&lt;T>::value;
  template &lt;class T> constexpr bool is_integral_v
    = is_integral&lt;T>::value;
  template &lt;class T> constexpr bool is_floating_point_v
    = is_floating_point&lt;T>::value;
  template &lt;class T> constexpr bool is_array_v
    = is_array&lt;T>::value;
  template &lt;class T> constexpr bool is_pointer_v
    = is_pointer&lt;T>::value;
  template &lt;class T> constexpr bool is_lvalue_reference_v
    = is_lvalue_reference&lt;T>::value;
  template &lt;class T> constexpr bool is_rvalue_reference_v
    = is_rvalue_reference&lt;T>::value;
  template &lt;class T> constexpr bool is_member_object_pointer_v
    = is_member_object_pointer&lt;T>::value;
  template &lt;class T> constexpr bool is_member_function_pointer_v
    = is_member_function_pointer&lt;T>::value;
  template &lt;class T> constexpr bool is_enum_v
    = is_enum&lt;T>::value;
  template &lt;class T> constexpr bool is_union_v
    = is_union&lt;T>::value;
  template &lt;class T> constexpr bool is_class_v
    = is_class&lt;T>::value;
  template &lt;class T> constexpr bool is_function_v
    = is_function&lt;T>::value;

  // See <cxx-ref in="cxx" to="meta.unary.comp"></cxx-ref>, composite type categories
  template &lt;class T> constexpr bool is_reference_v
    = is_reference&lt;T>::value;
  template &lt;class T> constexpr bool is_arithmetic_v
    = is_arithmetic&lt;T>::value;
  template &lt;class T> constexpr bool is_fundamental_v
    = is_fundamental&lt;T>::value;
  template &lt;class T> constexpr bool is_object_v
    = is_object&lt;T>::value;
  template &lt;class T> constexpr bool is_scalar_v
    = is_scalar&lt;T>::value;
  template &lt;class T> constexpr bool is_compound_v
    = is_compound&lt;T>::value;
  template &lt;class T> constexpr bool is_member_pointer_v
    = is_member_pointer&lt;T>::value;

  // See <cxx-ref in="cxx" to="meta.unary.prop"></cxx-ref>, type properties
  template &lt;class T> constexpr bool is_const_v
    = is_const&lt;T>::value;
  template &lt;class T> constexpr bool is_volatile_v
    = is_volatile&lt;T>::value;
  template &lt;class T> constexpr bool is_trivial_v
    = is_trivial&lt;T>::value;
  template &lt;class T> constexpr bool is_trivially_copyable_v
    = is_trivially_copyable&lt;T>::value;
  template &lt;class T> constexpr bool is_standard_layout_v
    = is_standard_layout&lt;T>::value;
  template &lt;class T> constexpr bool is_pod_v
    = is_pod&lt;T>::value;
  template &lt;class T> constexpr bool is_literal_type_v
    = is_literal_type&lt;T>::value;
  template &lt;class T> constexpr bool is_empty_v
    = is_empty&lt;T>::value;
  template &lt;class T> constexpr bool is_polymorphic_v
    = is_polymorphic&lt;T>::value;
  template &lt;class T> constexpr bool is_abstract_v
    = is_abstract&lt;T>::value;
  template &lt;class T> constexpr bool is_final_v
    = is_final&lt;T>::value;
  template &lt;class T> constexpr bool is_signed_v
    = is_signed&lt;T>::value;
  template &lt;class T> constexpr bool is_unsigned_v
    = is_unsigned&lt;T>::value;
  template &lt;class T, class... Args> constexpr bool is_constructible_v
    = is_constructible&lt;T, Args...>::value;
  template &lt;class T> constexpr bool is_default_constructible_v
    = is_default_constructible&lt;T>::value;
  template &lt;class T> constexpr bool is_copy_constructible_v
    = is_copy_constructible&lt;T>::value;
  template &lt;class T> constexpr bool is_move_constructible_v
    = is_move_constructible&lt;T>::value;
  template &lt;class T, class U> constexpr bool is_assignable_v
    = is_assignable&lt;T, U>::value;
  template &lt;class T> constexpr bool is_copy_assignable_v
    = is_copy_assignable&lt;T>::value;
  template &lt;class T> constexpr bool is_move_assignable_v
    = is_move_assignable&lt;T>::value;
  template &lt;class T> constexpr bool is_destructible_v
    = is_destructible&lt;T>::value;
  template &lt;class T, class... Args> constexpr bool is_trivially_constructible_v
    = is_trivially_constructible&lt;T, Args...>::value;
  template &lt;class T> constexpr bool is_trivially_default_constructible_v
    = is_trivially_default_constructible&lt;T>::value;
  template &lt;class T> constexpr bool is_trivially_copy_constructible_v
    = is_trivially_copy_constructible&lt;T>::value;
  template &lt;class T> constexpr bool is_trivially_move_constructible_v
    = is_trivially_move_constructible&lt;T>::value;
  template &lt;class T, class U> constexpr bool is_trivially_assignable_v
    = is_trivially_assignable&lt;T, U>::value;
  template &lt;class T> constexpr bool is_trivially_copy_assignable_v
    = is_trivially_copy_assignable&lt;T>::value;
  template &lt;class T> constexpr bool is_trivially_move_assignable_v
    = is_trivially_move_assignable&lt;T>::value;
  template &lt;class T> constexpr bool is_trivially_destructible_v
    = is_trivially_destructible&lt;T>::value;
  template &lt;class T, class... Args> constexpr bool is_nothrow_constructible_v
    = is_nothrow_constructible&lt;T, Args...>::value;
  template &lt;class T> constexpr bool is_nothrow_default_constructible_v
    = is_nothrow_default_constructible&lt;T>::value;
  template &lt;class T> constexpr bool is_nothrow_copy_constructible_v
    = is_nothrow_copy_constructible&lt;T>::value;
  template &lt;class T> constexpr bool is_nothrow_move_constructible_v
    = is_nothrow_move_constructible&lt;T>::value;
  template &lt;class T, class U> constexpr bool is_nothrow_assignable_v
    = is_nothrow_assignable&lt;T, U>::value;
  template &lt;class T> constexpr bool is_nothrow_copy_assignable_v
    = is_nothrow_copy_assignable&lt;T>::value;
  template &lt;class T> constexpr bool is_nothrow_move_assignable_v
    = is_nothrow_move_assignable&lt;T>::value;
  template &lt;class T> constexpr bool is_nothrow_destructible_v
    = is_nothrow_destructible&lt;T>::value;
  template &lt;class T> constexpr bool has_virtual_destructor_v
    = has_virtual_destructor&lt;T>::value;

  // See <cxx-ref in="cxx" to="meta.unary.prop.query"></cxx-ref>, type property queries
  template &lt;class T> constexpr size_t alignment_of_v
    = alignment_of&lt;T>::value;
  template &lt;class T> constexpr size_t rank_v
    = rank&lt;T>::value;
  template &lt;class T, unsigned I = 0> constexpr size_t extent_v
    = extent&lt;T, I>::value;

  // See <cxx-ref in="cxx" to="meta.rel"></cxx-ref>, type relations
  template &lt;class T, class U> constexpr bool is_same_v
    = is_same&lt;T, U>::value;
  template &lt;class Base, class Derived> constexpr bool is_base_of_v
    = is_base_of&lt;Base, Derived>::value;
  template &lt;class From, class To> constexpr bool is_convertible_v
    = is_convertible&lt;From, To>::value;

  <cxx-ref insynopsis="" to="meta.trans.other"></cxx-ref>
  template &lt;class> class invocation_type; // <i>not defined</i>
  template &lt;class F, class... ArgTypes> class invocation_type&lt;F(ArgTypes...)>;
  template &lt;class> class raw_invocation_type; // <i>not defined</i>
  template &lt;class F, class... ArgTypes> class raw_invocation_type&lt;F(ArgTypes...)>;

  template &lt;class T>
    using invocation_type_t = typename invocation_type&lt;T>::type;
  template &lt;class T>
    using raw_invocation_type_t = typename raw_invocation_type&lt;T>::type;

  <cxx-ref insynopsis to="meta.detect"></cxx-ref>
  template &lt;class...> using void_t = void;

  struct nonesuch {
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&) = delete;

    void operator=(nonesuch const&) = delete;
  };

  template &lt;template&lt;class...> class Op, class... Args>
    using is_detected = <i>see below</i>;
  template &lt;template&lt;class...> class Op, class... Args>
    constexpr bool is_detected_v = is_detected&lt;Op, Args...>::value;
  template &lt;template&lt;class...> class Op, class... Args>
    using detected_t = <i>see below</i>;
  template &lt;class Default, template&lt;class...> class Op, class... Args>
    using detected_or = <i>see below</i>;
  template &lt;class Default, template&lt;class...> class Op, class... Args>
    using detected_or_t = typename detected_or&lt;Default, Op, Args...>::type;
  template &lt;class Expected, template&lt;class...> class Op, class... Args>
    using is_detected_exact = is_same&lt;Expected, detected_t&lt;Op, Args...>>;
  template &lt;class Expected, template&lt;class...> class Op, class... Args>
    constexpr bool is_detected_exact_v
      = is_detected_exact&lt;Expected, Op, Args...>::value;
  template &lt;class To, template&lt;class...> class Op, class... Args>
    using is_detected_convertible = is_convertible&lt;detected_t&lt;Op, Args...>, To>;
  template &lt;class To, template&lt;class...> class Op, class... Args>
    constexpr bool is_detected_convertible_v
      = is_detected_convertible&lt;To, Op, Args...>::value;

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>

    </cxx-section>

    <cxx-section id="meta.trans.other">
      <h1>Other type transformations</h1>

      <p>
        This sub-clause contains templates that may be used to transform one type to another following some predefined rule.
      </p>

      <p>
        Each of the templates in this subclause shall be a <cxx-term>TransformationTrait</cxx-term> (<cxx-ref in="cxx" to="meta.rqmts"></cxx-ref>).
      </p>

      <p>
        Within this section, define the <dfn>invocation parameters</dfn> of <code><em>INVOKE</em>(f, t1, t2, ..., tN)</code> as follows,
        in which <code>T1</code> is the possibly <var>cv</var>-qualified type of <code>t1</code>
        and <code>U1</code> denotes <code>T1&amp;</code> if <code>t1</code> is an lvalue
        or <code>T1&amp;&amp;</code> if <code>t1</code> is an rvalue:
      </p>
      <ul>
        <li>
          When <code>f</code> is a pointer to a member function of a class <code>T</code>
          the <cxx-term>invocation parameters</cxx-term> are <code>U1</code> followed by
          the parameters of <code>f</code> matched by <code>t2</code>, ..., <code>tN</code>.
        </li>
        <li>
          When <code>N == 1</code> and <code>f</code> is a pointer to member data of a class <code>T</code>
          the <cxx-term>invocation parameter</cxx-term> is <code>U1</code>.
        </li>
        <li>
          If <code>f</code> is a class object,
          the <cxx-term>invocation parameters</cxx-term> are the parameters matching <code>t1</code>, ..., <code>tN</code>
          of the best viable function (<cxx-ref in="cxx" to="over.match.best"></cxx-ref>)
          for the arguments <code>t1</code>, ..., <code>tN</code>
          among the function call operators of <code>f</code>.
        </li>
        <li>
          In all other cases,
          the <cxx-term>invocation parameters</cxx-term> are the parameters of <code>f</code>
          matching <code>t1</code>, ... <code>tN</code>.
        </li>
      </ul>
      <p>
        In all of the above cases,
        if an argument <code>tI</code> matches the ellipsis in the function's <cxx-term>parameter-declaration-clause</cxx-term>,
        the corresponding <cxx-term>invocation parameter</cxx-term> is defined to be
        the result of applying the default argument promotions (<cxx-ref in="cxx" to="expr.call"></cxx-ref>) to <code>tI</code>.
      </p>

      <cxx-example>
        Assume <code>S</code> is defined as
        <pre><code>struct S {
  int f(double const &amp;) const;
  void operator()(int, int);
  void operator()(char const *, int i = 2, int j = 3);
  void operator()(...);
};</code></pre>
        <ul>
          <li>The invocation parameters of <code><em>INVOKE</em>(&amp;S::f, S(), 3.5)</code> are <code>(S &amp;&amp;, double const &amp;)</code>.</li>
          <li>The invocation parameters of <code><em>INVOKE</em>(S(), 1, 2)</code> are <code>(int, int)</code>.</li>
          <li>The invocation parameters of <code><em>INVOKE</em>(S(), "abc", 5)</code> are <code>(const char *, int)</code>.
          The defaulted parameter <code>j</code> does not correspond to an argument.</li>
          <li>The invocation parameters of <code><em>INVOKE</em>(S(), locale(), 5)</code> are <code>(locale, int)</code>.
          Arguments corresponding to ellipsis maintain their types.</li>
        </ul>
      </cxx-example>

      <table is="cxx-table" id="tab:meta.trans.other">
        <caption>Other type transformations</caption>
        <thead>
          <tr><th>Template</th><th>Condition</th><th>Comments</th></tr>
        </thead>
        <tr>
          <td>
            <code>template &lt;class Fn, class... ArgTypes&gt;<br/>
            struct raw_invocation_type&lt;<w-br></w-br>Fn(ArgTypes...)&gt;;</code>
          </td>
          <td>
            <code>Fn</code> and all types in the parameter pack <code>ArgTypes</code>
            shall be complete types, (possibly cv-qualified) <code>void</code>, or arrays of unknown bound.
          </td>

          <td>
            <em>see below</em>
          </td>
        </tr>
        <tr>
          <td>
            <code>template &lt;class Fn, class... ArgTypes&gt;<br/>
            struct invocation_type&lt;<w-br></w-br>Fn(ArgTypes...)&gt;;</code>
          </td>
          <td>
            <code>Fn</code> and all types in the parameter pack <code>ArgTypes</code>
            shall be complete types, (possibly cv-qualified) <code>void</code>,
            or arrays of unknown bound.
          </td>
          <td>
            <em>see below</em>
          </td>
        </tr>
      </table>

      <p>
        Access checking is performed as if in a context unrelated to <code>Fn</code> and <code>ArgTypes</code>.
        Only the validity of the immediate context of the expression is considered.
        <cxx-note>The compilation of the expression can result in side effects
        such as the instantiation of class template specializations and function template specializations,
        the generation of implicitly-defined functions, and so on.
        Such side effects are not in the "immediate context"
        and can result in the program being ill-formed.</cxx-note>
      </p>

      <p>
        The nested typedef <code>raw_invocation_type&lt;Fn(ArgTypes...)&gt;::type</code> shall be defined as follows.
        If the expression <code><em>INVOKE</em>(declval&lt;Fn&gt;(), declval&lt;ArgTypes&gt;()...)</code>
        is ill-formed when treated as an unevaluated operand (<cxx-ref in="cxx" to="expr"></cxx-ref>),
        there shall be no member <code>type</code>. Otherwise:
      </p>
      <ul>
        <li>Let <code>R</code> denote <code>result_of_t&lt;Fn(ArgTypes...)&gt;</code>.</li>
        <li>Let the types <code>Ti</code> be the <cxx-term>invocation parameters</cxx-term>
        of <code><em>INVOKE</em>(declval&lt;Fn&gt;(), <nobr>declval&lt;ArgTypes&gt;()...)</code></nobr>.</li>
        <li>Then the member typedef <code>type</code> shall name the function type <code>R(T1, T2, ...)</code>.</li>
      </ul>

      <p>
        The nested typedef <code>invocation_type&lt;Fn(ArgTypes...)&gt;::type</code> shall be defined as follows.
        If <code>raw_invocation_type&lt;Fn(ArgTypes...)&gt;::type</code> does not exist, there shall be no member typedef <code>type</code>.
        Otherwise:
      </p>
      <ul>
        <li>Let <code>A1, A2,</code> … denote <code>ArgTypes...</code></li>
        <li>Let <code>R(T1, T2, …)</code> denote <code>raw_invocation_type_t&lt;Fn(ArgTypes...)&gt;</code></li>
        <li>
          Then the member typedef <code>type</code> shall name the function type <code>R(U1, U2, …)</code>
          where <code>Ui</code> is <code>decay_t&lt;Ai&gt;</code> if <code>declval&lt;Ai&gt;()</code> is an rvalue
          otherwise <code>Ti</code>.
        </li>
      </ul>
    </cxx-section>

    <cxx-section id="meta.detect">
      <h1>Detection idiom</h1>

      <pre><code>template &lt;class Default, class AlwaysVoid,
          template&lt;class...> class Op, class... Args>
struct DETECTOR { // <i>exposition only</i>
  using value_t = false_type;
  using type = Default;
};

template &lt;class Default, template&lt;class...> class Op, class... Args>
struct DETECTOR&lt;Default, void_t&lt;Op&lt;Args...>>, Op, Args...> { // <i>exposition only</i>
  using value_t = true_type;
  using type = Op&lt;Args...>;
};

template &lt;template&lt;class...> class Op, class... Args>
  using is_detected = typename DETECTOR&lt;nonesuch, void, Op, Args...>::value_t;

template &lt;template&lt;class...> class Op, class... Args>
  using detected_t = typename DETECTOR&lt;nonesuch, void, Op, Args...>::type;

template &lt;class Default, template&lt;class...> class Op, class... Args>
  using detected_or = DETECTOR&lt;Default, void, Op, Args...>;</code></pre>

      <cxx-example>
        <pre><code>// <i>archetypal helper alias for a copy assignment operation:</i>
template &lt;class T>
  using copy_assign_t = decltype(declval&lt;T&>() = declval&lt;T const &>());

// <i>plausible implementation for the is_assignable type trait:</i>
template &lt;class T>
  using is_copy_assignable = is_detected&lt;copy_assign_t, T>;

// <i>plausible implementation for an augmented is_assignable type trait</i>
// <i>that also checks the return type:</i>
template &lt;class T>
  using is_canonical_copy_assignable = is_detected_exact&lt;T&, copy_assign_t, T>;</code></pre>
      </cxx-example>

      <cxx-example>
        <pre><code>// <i>archetypal helper alias for a particular type member:</i>
template &lt;class T>
  using diff_t = typename T::difference_type;

// <i>alias the type member, if it exists, otherwise alias </i>ptrdiff_t<i>:</i>
template &lt;class Ptr>
  using difference_type = detected_or_t&lt;ptrdiff_t, diff_t, Ptr>;</code></pre>
      </cxx-example>
    </cxx-section>
  </cxx-section>

  <cxx-section id="ratio">
    <h1>Compile-time rational arithmetic</h1>

    <cxx-section id="header.ratio.synop">
      <h1>Header &lt;experimental/ratio> synopsis</h1>

<pre><code>#include &lt;ratio>

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  // See <cxx-ref in="cxx" to="ratio.comparison"></cxx-ref>, ratio comparison
  template &lt;class R1, class R2> constexpr bool ratio_equal_v
    = ratio_equal&lt;R1, R2>::value;
  template &lt;class R1, class R2> constexpr bool ratio_not_equal_v
    = ratio_not_equal&lt;R1, R2>::value;
  template &lt;class R1, class R2> constexpr bool ratio_less_v
    = ratio_less&lt;R1, R2>::value;
  template &lt;class R1, class R2> constexpr bool ratio_less_equal_v
    = ratio_less_equal&lt;R1, R2>::value;
  template &lt;class R1, class R2> constexpr bool ratio_greater_v
    = ratio_greater&lt;R1, R2>::value;
  template &lt;class R1, class R2> constexpr bool ratio_greater_equal_v
    = ratio_greater_equal&lt;R1, R2>::value;

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    </cxx-section>
  </cxx-section>

  <cxx-section id="time">
    <h1>Time utilities</h1>

    <cxx-section id="header.chrono.synop">
      <h1>Header &lt;experimental/chrono> synopsis</h1>

<pre><code>#include &lt;chrono>

namespace std {
namespace chrono {
namespace experimental {
inline namespace fundamentals_v2 {

  // See <cxx-ref in="cxx" to="time.traits"></cxx-ref>, customization traits
  template &lt;class Rep> constexpr bool treat_as_floating_point_v
    = treat_as_floating_point&lt;Rep>::value;

} // namespace fundamentals_v2
} // namespace experimental
} // namespace chrono
} // namespace std</code></pre>
    </cxx-section>
  </cxx-section>

  <cxx-section id="syserror">
    <h1>System error support</h1>

    <cxx-section id="header.system_error.synop">
      <h1>Header &lt;experimental/system_error> synopsis</h1>

<pre><code>#include &lt;system_error>

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  // See <cxx-ref in="cxx" to="syserr"></cxx-ref>, System error support
  template &lt;class T> constexpr bool is_error_code_enum_v
    = is_error_code_enum&lt;T>::value;
  template &lt;class T> constexpr bool is_error_condition_enum_v
    = is_error_condition_enum&lt;T>::value;

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    </cxx-section>
  </cxx-section>

  <cxx-section id="propagate_const">
    <h1>Class template <code>propagate_const</code></h1>

    <cxx-section id="propagate_const.general">
      <h1>Class template <code>propagate_const</TT> general</code></h1>

      <p>
        <code>propagate_const</code> is a wrapper around a pointer-like object type <code>T</code>
        which treats the wrapped pointer as a pointer to <code>const</code> when
        the wrapper is accessed through a <code>const</code> access path.
      </p>
    </cxx-section>

    <cxx-section id="propagate_const.synopsis">
      <h1>Header <code>&lt;experimental/propagate_const&gt;</code> synopsis</h1>

<pre><code>namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {
    template &lt;class T&gt; class propagate_const {
    public:
      typedef remove_reference_t&lt;decltype(*declval&lt;T&amp;&gt;())&gt; element_type;

      <cxx-ref insynopsis to="propagate_const.ctor"></cxx-ref>
      constexpr propagate_const() = default;
      propagate_const(const propagate_const&amp; p) = delete;
      constexpr propagate_const(propagate_const&amp;&amp; p) = default;
      template &lt;class U&gt;
        <i>see below</i> constexpr propagate_const(propagate_const&lt;U&gt;&amp;&amp; pu);
      template &lt;class U&gt;
        <i>see below</i> constexpr propagate_const(U&amp;&amp; u);

      <cxx-ref insynopsis to="propagate_const.assignment"></cxx-ref>
      propagate_const&amp; operator=(const propagate_const&amp; p) = delete;
      constexpr propagate_const&amp; operator=(propagate_const&amp;&amp; p) = default;
      template &lt;class U&gt;
        constexpr propagate_const&amp; operator=(propagate_const&lt;U&gt;&amp;&amp; pu);
      template &lt;class U&gt;
        constexpr propagate_const&amp; operator=(U&amp;&amp; u);

      <cxx-ref insynopsis to="propagate_const.const_observers"></cxx-ref>
      explicit constexpr operator bool() const;
      constexpr const element_type* operator-&gt;() const;
      constexpr operator const element_type*() const; // <i>Not always defined</i>
      constexpr const element_type&amp; operator*() const;
      constexpr const element_type* get() const;

      <cxx-ref insynopsis to="propagate_const.non_const_observers"></cxx-ref>
      constexpr element_type* operator-&gt;();
      constexpr operator element_type*(); // <i>Not always defined</i>
      constexpr element_type&amp; operator*();
      constexpr element_type* get();

      <cxx-ref insynopsis to="propagate_const.modifiers"></cxx-ref>
      constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);

    private:
      T t_; //<i>exposition only</i>
    };

    <cxx-ref insynopsis to="propagate_const.relational"></cxx-ref>
    template &lt;class T&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);
    template &lt;class T&gt;
      constexpr bool operator==(nullptr_t, const propagate_const&lt;T&gt;&amp; pu);

    template &lt;class T&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);
    template &lt;class T&gt;
      constexpr bool operator!=(nullptr_t, const propagate_const&lt;T&gt;&amp; pu);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);

    <cxx-ref insynopsis to="propagate_const.algorithms"></cxx-ref>
    template &lt;class T&gt;
      constexpr void swap(propagate_const&lt;T&gt;&amp; pt, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>);

    <cxx-ref insynopsis to="propagate_const.underlying"></cxx-ref>
    template &lt;class T&gt;
      constexpr const T&amp; get_underlying(const propagate_const&lt;T&gt;&amp; pt) noexcept;
    template &lt;class T&gt;
      constexpr T&amp; get_underlying(propagate_const&lt;T&gt;&amp; pt) noexcept;
  } // inline namespace fundamentals_v2
  } // namespace experimental

  <cxx-ref insynopsis to="propagate_const.hash"></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt;
    struct hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;

  <cxx-ref insynopsis to="propagate_const.comparison_function_objects"></cxx-ref>
  template &lt;class T&gt; struct equal_to;
  template &lt;class T&gt;
    struct equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct not_equal_to;
  template &lt;class T&gt;
    struct not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct less;
  template &lt;class T&gt;
    struct less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct greater;
  template &lt;class T&gt;
    struct greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct less_equal;
  template &lt;class T&gt;
    struct less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct greater_equal;
  template &lt;class T&gt;
    struct greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
} // namespace std</code></pre>
    </cxx-section>

    <cxx-section id="propagate_const.requirements">
      <h1><code>propagate_const</code> requirements on <code>T</code></h1>

      <p>
        <code>T</code> shall be an object pointer type or a class type for which
        <code>decltype(*declval&lt;T&amp;&gt;())</code> is an lvalue reference; otherwise
        the program is ill-formed.
      </p>
      <p>
        If <code>T</code> is an array type, reference type, pointer to function type or
        pointer to (possibly cv-qualified) <code>void</code>, then the program is
        ill-formed.
      </p>
      <p>
        <cxx-note><code>propagate_const&lt;const int*&gt;</code> is well-formed</cxx-note>
      </p>

      <cxx-section id="propagate_const.class_type_requirements">
        <h1><code>propagate_const</code> requirements on class type <code>T</code></h1>

        <p>
          If <code>T</code> is class
          type then it shall satisfy the following requirements. In this sub-clause
          <code>t</code> denotes a non-<code>const</code> lvalue of type <code>T</code>, <code>ct</code>
          is a <code>const T&amp;</code> bound to <code>t</code>,  <code>element_type</code> denotes
          an object type.
        </p>

        <p>
          <code>T</code> and <code>const T</code> shall be contextually convertible to <code>bool</code>.
        </p>
        <p>If <code>T</code> is implicitly convertible to <code>element_type*</code>,
          <code>(element_type*)t == t.get()</code> shall be <code>true</code>.
        </p>
        <p>
          If <code>const T</code> is implicitly convertible to <code>const element_type*</code>,
          <code>(const element_type*)ct == ct.get()</code> shall be <code>true</code>.
        </p>

        <table is="cxx-table">
          <caption>Requirements on class types <code>T</code></caption>
          <tr>
            <th>Expression</th>
            <th>Return type</th>
            <th>Pre-conditions</th>
            <th>Operational semantics</th>
          </tr>
          <tr>
            <td><code>t.get()</code></td>
            <td><code>element_type*</code></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>ct.get()</code></td>
            <td><code>const element_type*</code> or <code>element_type*</code></td>
            <td><code></code></td>
            <td><code>t.get() == ct.get()</code>.</td>
          </tr>
          <tr>
            <td><code>*t</code></td>
            <td><code>element_type&amp;</code></td>
            <td><code>t.get() != nullptr</code></td>
            <td><code>*t</code> refers to the same object as <code>*(t.get())</code></td>
          </tr>
          <tr>
            <td><code>*ct</code></td>
            <td><code>const element_type&amp;</code> or <code>element_type&amp;</code>
            </td>
            <td><code>ct.get() != nullptr</code></td>
            <td><code>*ct</code> refers to the same object as <code>*(ct.get())</code>
            </td></tr>
          <tr>
            <td><code>t.operator-&gt;()</code></td>
            <td><code>element_type*</code></td>
            <td><code>t.get() != nullptr</code></td>
            <td><code>t.operator-&gt;() == t.get()</code></td></tr>
          <tr>
            <td><code>ct.operator-&gt;()</code></td>
            <td><code>const element_type*</code> or <code>element_type*</code></td>
            <td><code>ct.get() != nullptr</code></td>
            <td><code>ct.operator-&gt;() == ct.get()</code></td></tr>
          <tr>
            <td><code>(bool)t</code></td>
            <td><code>bool</code></td>
            <td><code></code></td>
            <td><code>(bool)t</code> is equivalent to <code>t.get() != nullptr</code></td>
          </tr>
          <tr>
            <td><code>(bool)ct</code></td>
            <td><code>bool</code></td>
            <td><code></code></td>
            <td><code>(bool)ct</code> is equivalent to <code>ct.get() != nullptr</code></td>
          </tr>
        </table>
      </cxx-section>
    </cxx-section>

    <cxx-section id="propagate_const.ctor">
      <h1><code>propagate_const</code> constructors</h1>

      <p>
        <cxx-note>The following constructors are conditionally specified as
          <code>explicit</code>.  This is typically implemented by declaring two such
          constructors, of which at most one  participates in overload resolution.</cxx-note>
      </p>
      <cxx-function>
        <cxx-signature>template &lt;class U&gt;
<i>see below</i> constexpr propagate_const(propagate_const&lt;U&gt;&amp;&amp; pu);</cxx-signature>

        <cxx-remarks>
          This constructor shall not participate in overload resolution unless
          <code>is_constructible_v&lt;T, U&amp;&amp;&gt;</code>.
          The constructor is specified as <code>explicit</code> if and only if
          <code>!is_convertible_v&lt;U&amp;&amp;, T&gt;.</code>
        </cxx-remarks>
        <cxx-effects>
          Initializes <code>t_</code> as if
          direct-non-list-initializing an object of type <code>T</code> with the
          expression <code>std::move(pu.t_)</code>.
        </cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class U&gt;
<i>see below</i> constexpr propagate_const(U&amp;&amp; u);</cxx-signature>

        <cxx-remarks>
          This constructor shall not participate in overload resolution unless
          <code>is_constructible_v&lt;T, U&amp;&amp;&gt;</code>
          and <code>decay_t&lt;U&gt;</code> is not a specialization of <code>propagate_const</code>.
          The constructor is specified as <code>explicit</code> if and only if
          <code>!is_convertible_v&lt;U&amp;&amp;, T&gt;.</code>
        </cxx-remarks>
        <cxx-effects>
          Initializes <code>t_</code> as if
          direct-non-list-initializing an object of type <code>T</code> with
          the expression <code>std::forward&lt;U&gt;(u)</code>.
        </cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.assignment">
      <h1><code>propagate_const</code> assignment</h1>

      <cxx-function>
        <cxx-signature>template &lt;class U&gt;
constexpr propagate_const operator=(propagate_const&lt;U&gt;&amp;&amp; pu);</cxx-signature>

        <cxx-remarks>
          This function shall not participate in overload resolution unless
          <code>U</code> is implicitly convertible to <code>T</code>.
        </cxx-remarks>
        <cxx-effects><code>t_ = std::move(pu.t_)</code>.</cxx-effects>
        <cxx-returns><code>*this</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class U&gt;
constexpr propagate_const operator=(U&amp;&amp; u);</cxx-signature>

        <cxx-remarks>
          This function shall not participate in overload resolution unless
          <code>U</code> is implicitly convertible to <code>T</code> and
          <code>decay_t&lt;U&gt;</code> is not a specialization of <code>propagate_const</code>.
        </cxx-remarks>
        <cxx-effects><code>t_ = std::forward&lt;U&gt;(u)</code>.</cxx-effects>
        <cxx-returns><code>*this</code>.</cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.const_observers">
      <h1><code>propagate_const</code> const observers</h1>

      <cxx-function>
        <cxx-signature>explicit constexpr operator bool() const;</cxx-signature>

        <cxx-returns><code>(bool)t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr const element_type* operator-&gt;() const;</cxx-signature>

        <cxx-requires><code>get() != nullptr</code>.</cxx-requires>
        <cxx-returns><code>get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr operator const element_type*() const;</cxx-signature>

        <cxx-returns><code>get()</code>.</cxx-returns>
        <cxx-remarks>
          This function shall not participate in overload resolution unless
          <code>T</code> is an object pointer type or
          has an implicit conversion to <code>const element_type*</code>.
        </cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr const element_type&amp; operator*() const;</cxx-signature>

        <cxx-requires><code>get() != nullptr</code>.</cxx-requires>
        <cxx-returns><code>*get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr const element_type* get() const;</cxx-signature>

        <cxx-returns>
          <code>t_</code> if <code>T</code> is an object pointer type,
          otherwise <code>t_.get()</code>.
        </cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.non_const_observers">
      <h1><code>propagate_const</code> non-const observers</h1>

      <cxx-function>
        <cxx-signature>constexpr element_type* operator-&gt;();</cxx-signature>

        <cxx-requires><code>get() != nullptr</code>.</cxx-requires>
        <cxx-returns><code>get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr operator element_type*();</cxx-signature>

        <cxx-returns><code>get()</code>.</cxx-returns>
        <cxx-remarks>
          This function shall not participate in overload resolution unless
          <code>T</code> is an object pointer type or
          has an implicit conversion to <code>element_type*</code>.
        </cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr element_type&amp; operator*();</cxx-signature>

        <cxx-requires><code>get() != nullptr</code>.</cxx-requires>
        <cxx-returns><code>*get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr element_type* get();</cxx-signature>

        <cxx-returns>
          <code>t_</code> if <code>T</code> is an object pointer type,
          otherwise <code>t_.get()</code>.
        </cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.modifiers">
      <h1><code>propagate_const</code> modifiers</h1>

      <cxx-function>
        <cxx-signature>constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);</cxx-signature>

        <p>
          The constant-expression in the exception-specification is <code>noexcept(swap(t_, pt.t_))</code>.
        </p>

        <cxx-effects><code>swap(t_, pt.t_)</code>.</cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.relational">
      <h1><code>propagate_const</code> relational operators</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);</cxx-signature>

        <cxx-returns><code>pt.t_ == nullptr</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator==(nullptr_t, const propagate_const&lt;T&gt;&amp; pt);</cxx-signature>

        <cxx-returns><code>nullptr == pt.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);</cxx-signature>

        <cxx-returns><code>pt.t_ != nullptr</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator!=(nullptr_t, const propagate_const&lt;T&gt;&amp; pt);</cxx-signature>

        <cxx-returns><code>nullptr != pt.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ == pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ != pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ &lt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ &gt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ &lt;= pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ &gt;= pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>

        <cxx-returns><code>pt.t_ == u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>
        <cxx-returns><code>pt.t_ != u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>

        <cxx-returns><code>pt.t_ &lt; u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>

        <cxx-returns><code>pt.t_ &gt; u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>

        <cxx-returns><code>pt.t_ &lt;= u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>

        <cxx-returns><code>pt.t_ &gt;= u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t == pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t != pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t &lt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t &gt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t &lt;= pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t &gt;= pu.t_</code>.</cxx-returns>
      </cxx-function>
    </cxx-section>
    <cxx-section id="propagate_const.algorithms">
      <h1><code>propagate_const</code> specialized algorithms</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr void swap(propagate_const&lt;T&gt;&amp; pt1, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>);</cxx-signature>

        <p>
          The constant-expression in the exception-specification is <code>noexcept(swap(pt1.t_, pt2.t_))</code>.
        </p>

        <cxx-effects><code>swap(pt1.t_, pt2.t_)</code>.</cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.underlying">
      <h1><code>propagate_const</code> underlying pointer access</h1>

      <p>
        Access to the underlying object pointer type is
        through free functions rather than member functions.
        These functions are intended to resemble cast operations to encourage caution when using them.
      </p>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr const T&amp; get_underlying(const propagate_const&lt;T&gt;&amp; pt) noexcept;</cxx-signature>

        <cxx-returns>
          a reference to the underlying object pointer type.
        </cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr T&amp; get_underlying(propagate_const&lt;T&gt;&amp; pt) noexcept;</cxx-signature>

        <cxx-returns>
          a reference to the underlying object pointer type.
        </cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.hash">
      <h1><code>propagate_const</code> hash support</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For an object <code>p</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p)</code>
          shall evaluate to the same value as <code>hash&lt;T&gt;()(p.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>hash&lt;T&gt;</code> shall be well-formed and well-defined,
          and shall meet the requirements of class template hash.
        </cxx-requires>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.comparison_function_objects">
      <h1><code>propagate_const</code> comparison function objects</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>equal_to&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>equal_to&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p, q)</code>
          shall evaluate to the same value as <code>not_equal_to&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>not_equal_to&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>less&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>less&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>greater&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>greater&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>less_equal&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>less_equal&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>greater_equal&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>greater_equal&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>
    </cxx-section>
  </cxx-section>
</cxx-clause>
