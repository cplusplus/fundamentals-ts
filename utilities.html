<cxx-clause id="utilities">
  <h1>General utilities library</h1>

  <cxx-section id="propagate_const">
    <h1>Constness propagation</h1>

    <cxx-section id="propagate_const.syn">
      <h1>Header <code>&lt;experimental/propagate_const&gt;</code> synopsis</h1>

      <pre><code>namespace std {
  namespace experimental::inline fundamentals_v3 {

    <cxx-ref insynopsis to="propagate_const.overview"></cxx-ref>
    template &lt;class T&gt; class propagate_const;

    <cxx-ref insynopsis to="propagate_const.relational"></cxx-ref>
    template &lt;class T&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);
    template &lt;class T&gt;
      constexpr bool operator==(nullptr_t, const propagate_const&lt;T&gt;&amp; pu);

    template &lt;class T&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);
    template &lt;class T&gt;
      constexpr bool operator!=(nullptr_t, const propagate_const&lt;T&gt;&amp; pu);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);

    <cxx-ref insynopsis to="propagate_const.algorithms"></cxx-ref>
    template &lt;class T&gt;
      constexpr void swap(propagate_const&lt;T&gt;&amp; pt, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>);

    <cxx-ref insynopsis to="propagate_const.underlying"></cxx-ref>
    template &lt;class T&gt;
      constexpr const T&amp; get_underlying(const propagate_const&lt;T&gt;&amp; pt) noexcept;
    template &lt;class T&gt;
      constexpr T&amp; get_underlying(propagate_const&lt;T&gt;&amp; pt) noexcept;

  } // namespace experimental::inline fundamentals_v3

  <cxx-ref insynopsis to="propagate_const.hash"></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt;
    struct hash&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;

  <cxx-ref insynopsis to="propagate_const.comparison_function_objects"></cxx-ref>
  template &lt;class T&gt; struct equal_to;
  template &lt;class T&gt;
    struct equal_to&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct not_equal_to;
  template &lt;class T&gt;
    struct not_equal_to&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct less;
  template &lt;class T&gt;
    struct less&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct greater;
  template &lt;class T&gt;
    struct greater&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct less_equal;
  template &lt;class T&gt;
    struct less_equal&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct greater_equal;
  template &lt;class T&gt;
    struct greater_equal&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;

} // namespace std</code></pre>
    </cxx-section>

    <cxx-section id="propagate_const.tmpl">
      <h1>Class template <code>propagate_const</code></h1>

      <cxx-section id="propagate_const.overview">
        <h1>Overview</h1>

        <pre><code>namespace std::experimental::inline fundamentals_v3 {

  template &lt;class T&gt; class propagate_const {
  public:
    using element_type = remove_reference_t&lt;decltype(*declval&lt;T&amp;&gt;())&gt;;

    <cxx-ref insynopsis to="propagate_const.ctor"></cxx-ref>
    constexpr propagate_const() = default;
    propagate_const(const propagate_const&amp; p) = delete;
    constexpr propagate_const(propagate_const&amp;&amp; p) = default;
    template &lt;class U&gt;
      explicit(!is_convertible_v&lt;U, T&gt;) constexpr propagate_const(propagate_const&lt;U&gt;&amp;&amp; pu);
    template &lt;class U&gt;
      explicit(!is_convertible_v&lt;U, T&gt;) constexpr propagate_const(U&amp;&amp; u);

    <cxx-ref insynopsis to="propagate_const.assignment"></cxx-ref>
    propagate_const&amp; operator=(const propagate_const&amp; p) = delete;
    constexpr propagate_const&amp; operator=(propagate_const&amp;&amp; p) = default;
    template &lt;class U&gt;
      constexpr propagate_const&amp; operator=(propagate_const&lt;U&gt;&amp;&amp; pu);
    template &lt;class U&gt;
      constexpr propagate_const&amp; operator=(U&amp;&amp; u);

    <cxx-ref insynopsis to="propagate_const.const_observers"></cxx-ref>
    explicit constexpr operator bool() const;
    constexpr const element_type* operator-&gt;() const;
    constexpr operator const element_type*() const; // <i>Not always defined</i>
    constexpr const element_type&amp; operator*() const;
    constexpr const element_type* get() const;

    <cxx-ref insynopsis to="propagate_const.non_const_observers"></cxx-ref>
    constexpr element_type* operator-&gt;();
    constexpr operator element_type*(); // <i>Not always defined</i>
    constexpr element_type&amp; operator*();
    constexpr element_type* get();

    <cxx-ref insynopsis to="propagate_const.modifiers"></cxx-ref>
    constexpr void swap(propagate_const&amp; pt) noexcept(is_nothrow_swappable&lt;T&gt;);

  private:
    T t_; //<i>exposition only</i>
  };

} // namespace std::experimental::inline fundamentals_v3</code></pre>

        <p>
          <code>propagate_const</code> is a wrapper around a pointer-like object type <code>T</code>
          which treats the wrapped pointer as a pointer to <code>const</code> when
          the wrapper is accessed through a <code>const</code> access path.
        </p>
      </cxx-section>

      <cxx-section id="propagate_const.requirements">
        <h1>General requirements on <code>T</code></h1>

        <p>
          <code>T</code> shall be a cv-unqualified pointer-to-object type or a cv-unqualified class type for which
          <code>decltype(*declval&lt;T&amp;&gt;())</code> is an lvalue reference to object type; otherwise
          the program is ill-formed.
        </p>
        <p>
          <cxx-note><code>propagate_const&lt;const int*&gt;</code> is well-formed but <code>propagate_const&lt;int* const&gt; is not</code>.</cxx-note>
        </p>

      </cxx-section>

      <cxx-section id="propagate_const.class_type_requirements">
        <h1>Requirements on class type <code>T</code></h1>

        <p>
          If <code>T</code> is class
          type then it shall satisfy the following requirements. In this subclause
          <code>t</code> denotes an lvalue of type <code>T</code>, <code>ct</code>
          denotes <code>as_const(t)</code>.
        </p>

        <p>
          <code>T</code> and <code>const T</code> shall be contextually convertible to <code>bool</code>.
        </p>
        <p>If <code>T</code> is implicitly convertible to <code>element_type*</code>,
          <code>(element_type*)t == t.get()</code> shall be <code>true</code>.
        </p>
        <p>
          If <code>const T</code> is implicitly convertible to <code>const element_type*</code>,
          <code>(const element_type*)ct == ct.get()</code> shall be <code>true</code>.
        </p>

        <table is="cxx-table">
          <caption>Requirements on class types <code>T</code></caption>
          <tr>
            <th>Expression</th>
            <th>Return type</th>
            <th>Pre-conditions</th>
            <th>Operational semantics</th>
          </tr>
          <tr>
            <td><code>t.get()</code></td>
            <td><code>element_type*</code></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>ct.get()</code></td>
            <td><code>const element_type*</code> or <code>element_type*</code></td>
            <td><code></code></td>
            <td><code>t.get() == ct.get()</code>.</td>
          </tr>
          <tr>
            <td><code>*t</code></td>
            <td><code>element_type&amp;</code></td>
            <td><code>t.get() != nullptr</code></td>
            <td><code>*t</code> refers to the same object as <code>*(t.get())</code></td>
          </tr>
          <tr>
            <td><code>*ct</code></td>
            <td><code>const element_type&amp;</code> or <code>element_type&amp;</code></td>
            <td><code>ct.get() != nullptr</code></td>
            <td><code>*ct</code> refers to the same object as <code>*(ct.get())</code></td>
          </tr>
          <tr>
            <td><code>t.operator-&gt;()</code></td>
            <td><code>element_type*</code></td>
            <td><code>t.get() != nullptr</code></td>
            <td><code>t.operator-&gt;() == t.get()</code></td></tr>
          <tr>
            <td><code>ct.operator-&gt;()</code></td>
            <td><code>const element_type*</code> or <code>element_type*</code></td>
            <td><code>ct.get() != nullptr</code></td>
            <td><code>ct.operator-&gt;() == ct.get()</code></td></tr>
          <tr>
            <td><code>(bool)t</code></td>
            <td><code>bool</code></td>
            <td><code></code></td>
            <td><code>(bool)t</code> is equivalent to <code>t.get() != nullptr</code></td>
          </tr>
          <tr>
            <td><code>(bool)ct</code></td>
            <td><code>bool</code></td>
            <td><code></code></td>
            <td><code>(bool)ct</code> is equivalent to <code>ct.get() != nullptr</code></td>
          </tr>
        </table>
      </cxx-section>

      <cxx-section id="propagate_const.ctor">
        <h1>Constructors</h1>

        <cxx-function>
          <cxx-signature>template &lt;class U&gt;
explicit(!is_convertible_v&lt;U, T&gt;) constexpr propagate_const(propagate_const&lt;U&gt;&amp;&amp; pu);</cxx-signature>

          <cxx-constraints>
            <code>is_constructible_v&lt;T, U&gt;</code> is true.
          </cxx-constraints>
          <cxx-effects>
            Initializes <code>t_</code> as if
            direct-non-list-initializing an object of type <code>T</code> with the
            expression <code>std::move(pu.t_)</code>.
          </cxx-effects>
        </cxx-function>

        <cxx-function>
          <cxx-signature>template &lt;class U&gt;
explicit(!is_convertible_v&lt;U, T&gt;) constexpr propagate_const(U&amp;&amp; u);</cxx-signature>

          <cxx-constraints>
            <code>is_constructible_v&lt;T, U&gt;</code> is true
            and <code>decay_t&lt;U&gt;</code> is not a specialization of <code>propagate_const</code>.
          </cxx-constraints>
          <cxx-effects>
            Initializes <code>t_</code> as if
            direct-non-list-initializing an object of type <code>T</code> with
            the expression <code>std::forward&lt;U&gt;(u)</code>.
          </cxx-effects>
        </cxx-function>
      </cxx-section>

      <cxx-section id="propagate_const.assignment">
        <h1>Assignment</h1>

        <cxx-function>
          <cxx-signature>template &lt;class U&gt;
constexpr propagate_const&amp; operator=(propagate_const&lt;U&gt;&amp;&amp; pu);</cxx-signature>

          <cxx-constraints>
            <code>U</code> is implicitly convertible to <code>T</code>.
          </cxx-constraints>
          <cxx-effects><code>t_ = std::move(pu.t_)</code>.</cxx-effects>
          <cxx-returns><code>*this</code>.</cxx-returns>
        </cxx-function>

        <cxx-function>
          <cxx-signature>template &lt;class U&gt;
constexpr propagate_const&amp; operator=(U&amp;&amp; u);</cxx-signature>

          <cxx-constraints>
            <code>U</code> is implicitly convertible to <code>T</code> and
            <code>decay_t&lt;U&gt;</code> is not a specialization of <code>propagate_const</code>.
          </cxx-constraints>
          <cxx-effects><code>t_ = std::forward&lt;U&gt;(u)</code>.</cxx-effects>
          <cxx-returns><code>*this</code>.</cxx-returns>
        </cxx-function>
      </cxx-section>

      <cxx-section id="propagate_const.const_observers">
        <h1>Const observers</h1>

        <cxx-function>
          <cxx-signature>explicit constexpr operator bool() const;</cxx-signature>

          <cxx-returns><code>(bool)t_</code>.</cxx-returns>
        </cxx-function>

        <cxx-function>
          <cxx-signature>constexpr const element_type* operator-&gt;() const;</cxx-signature>

          <cxx-preconditions><code>get() != nullptr</code>.</cxx-preconditions>
          <cxx-returns><code>get()</code>.</cxx-returns>
        </cxx-function>

        <cxx-function>
          <cxx-signature>constexpr operator const element_type*() const;</cxx-signature>

          <cxx-constraints>
            <code>T</code> is an object pointer type or
            has an implicit conversion to <code>const element_type*</code>.
          </cxx-constraints>
          <cxx-returns><code>get()</code>.</cxx-returns>
        </cxx-function>

        <cxx-function>
          <cxx-signature>constexpr const element_type&amp; operator*() const;</cxx-signature>

          <cxx-preconditions><code>get() != nullptr</code>.</cxx-preconditions>
          <cxx-returns><code>*get()</code>.</cxx-returns>
        </cxx-function>

        <cxx-function>
          <cxx-signature>constexpr const element_type* get() const;</cxx-signature>

          <cxx-returns>
            <code>t_</code> if <code>T</code> is an object pointer type,
            otherwise <code>t_.get()</code>.
          </cxx-returns>
        </cxx-function>
      </cxx-section>

    <cxx-section id="propagate_const.non_const_observers">
      <h1>Non-const observers</h1>

      <cxx-function>
        <cxx-signature>constexpr element_type* operator-&gt;();</cxx-signature>

        <cxx-preconditions><code>get() != nullptr</code>.</cxx-preconditions>
        <cxx-returns><code>get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr operator element_type*();</cxx-signature>

        <cxx-constraints>
          <code>T</code> is an object pointer type or
          has an implicit conversion to <code>element_type*</code>.
        </cxx-constraints>
        <cxx-returns><code>get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr element_type&amp; operator*();</cxx-signature>

        <cxx-preconditions><code>get() != nullptr</code>.</cxx-preconditions>
        <cxx-returns><code>*get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr element_type* get();</cxx-signature>

        <cxx-returns>
          <code>t_</code> if <code>T</code> is an object pointer type,
          otherwise <code>t_.get()</code>.
        </cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.modifiers">
      <h1>Modifiers</h1>

      <cxx-function>
        <cxx-signature>constexpr void swap(propagate_const&amp; pt) noexcept(is_nothrow_swappable&lt;T&gt;);</cxx-signature>

        <cxx-preconditions>
          Lvalues of type <code>T</code> are swappable
          (<cxx-ref in="cxx" to="swappable.requirements"></cxx-ref>).
        </cxx-preconditions>
        <cxx-effects><code>swap(t_, pt.t_)</code>.</cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.relational">
      <h1>Relational operators</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);</cxx-signature>

        <cxx-returns><code>pt.t_ == nullptr</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator==(nullptr_t, const propagate_const&lt;T&gt;&amp; pt);</cxx-signature>

        <cxx-returns><code>nullptr == pt.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);</cxx-signature>

        <cxx-returns><code>pt.t_ != nullptr</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator!=(nullptr_t, const propagate_const&lt;T&gt;&amp; pt);</cxx-signature>

        <cxx-returns><code>nullptr != pt.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ == pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ != pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ &lt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ &gt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ &lt;= pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>pt.t_ &gt;= pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>

        <cxx-returns><code>pt.t_ == u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>
        <cxx-returns><code>pt.t_ != u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>

        <cxx-returns><code>pt.t_ &lt; u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>

        <cxx-returns><code>pt.t_ &gt; u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>

        <cxx-returns><code>pt.t_ &lt;= u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);</cxx-signature>

        <cxx-returns><code>pt.t_ &gt;= u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t == pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t != pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t &lt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t &gt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t &lt;= pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);</cxx-signature>

        <cxx-returns><code>t &gt;= pu.t_</code>.</cxx-returns>
      </cxx-function>
    </cxx-section>
    <cxx-section id="propagate_const.algorithms">
      <h1>Specialized algorithms</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr void swap(propagate_const&lt;T&gt;&amp; pt1, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>);</cxx-signature>

        <cxx-constraints><code>is_swappable_v&lt;T&gt;</code> is <code>true</code>.</cxx-constraints>
        <cxx-effects>Equivalent to: <code>pt1.swap(pt2)</code>.</cxx-effects>
        <cxx-remarks>The expression inside <code>noexcept</code> is equivalent to:
          <pre><code>noexcept(pt1.swap(pt2))</code></pre>
        </cxx-remarks>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.underlying">
      <h1>Underlying pointer access</h1>

      <p>
        Access to the underlying object pointer type is
        through free functions rather than member functions.
        These functions are intended to resemble cast operations to encourage caution when using them.
      </p>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr const T&amp; get_underlying(const propagate_const&lt;T&gt;&amp; pt) noexcept;</cxx-signature>

        <cxx-returns>
          a reference to the underlying object pointer type.
        </cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr T&amp; get_underlying(propagate_const&lt;T&gt;&amp; pt) noexcept;</cxx-signature>

        <cxx-returns>
          a reference to the underlying object pointer type.
        </cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.hash">
      <h1>Hash support</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct hash&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          The specialization <code>hash&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;</code>
          is enabled (<cxx-ref in="cxx" to="unord.hash"></cxx-ref>) if and only if <code>hash&lt;T&gt;</code> is enabled.
          When enabled, for an object <code>p</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>hash&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;()(p)</code>
          evaluates to the same value as <code>hash&lt;T&gt;()(p.t_)</code>.
        </p>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.comparison_function_objects">
      <h1>Comparison function objects</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct equal_to&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>equal_to&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>equal_to&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-mandates>
          The specialization <code>equal_to&lt;T&gt;</code> is well-formed.
        </cxx-mandates>
        <cxx-preconditions>
          The specialization <code>equal_to&lt;T&gt;</code> is well-defined.
        </cxx-preconditions>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct not_equal_to&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>not_equal_to&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;()(p, q)</code>
          shall evaluate to the same value as <code>not_equal_to&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-mandates>
          The specialization <code>not_equal_to&lt;T&gt;</code> is well-formed.
        </cxx-mandates>
        <cxx-preconditions>
          The specialization <code>not_equal_to&lt;T&gt;</code> is well-defined.
        </cxx-preconditions>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct less&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>less&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;()(p, q)</code>
          shall evaluate to the same value as <code>less&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-mandates>
          The specialization <code>less&lt;T&gt;</code> is well-formed.
        </cxx-mandates>
        <cxx-preconditions>
          The specialization <code>less&lt;T&gt;</code> is well-defined.
        </cxx-preconditions>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct greater&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>greater&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;()(p, q)</code>
          shall evaluate to the same value as <code>greater&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-mandates>
          The specialization <code>greater&lt;T&gt;</code> is well-formed.
        </cxx-mandates>
        <cxx-preconditions>
          The specialization <code>greater&lt;T&gt;</code> is well-defined.
        </cxx-preconditions>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct less_equal&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>less_equal&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;()(p, q)</code>
          shall evaluate to the same value as <code>less_equal&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-mandates>
          The specialization <code>less_equal&lt;T&gt;</code> is well-formed.
        </cxx-mandates>
        <cxx-preconditions>
          The specialization <code>less_equal&lt;T&gt;</code> is well-defined.
        </cxx-preconditions>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct greater_equal&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>greater_equal&lt;experimental::fundamentals_v3::propagate_const&lt;T&gt;&gt;()(p, q)</code>
          shall evaluate to the same value as <code>greater_equal&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-mandates>
          The specialization <code>greater_equal&lt;T&gt;</code> is well-formed.
        </cxx-mandates>
        <cxx-preconditions>
          The specialization <code>greater_equal&lt;T&gt;</code> is well-defined.
        </cxx-preconditions>
      </cxx-function>
    </cxx-section>
  </cxx-section>
  </cxx-section>

  <cxx-section id="scopeguard">
    <h1>Scope guard support</h1>

    <cxx-section id="scope.syn">
      <h1>Header <code>&lt;experimental/scope&gt;</code> synopsis</h1>

      <pre><code>namespace std::experimental::inline fundamentals_v3 {

  <cxx-ref insynopsis to="scopeguard.exit"></cxx-ref>
  template &lt;class EF&gt;
    class scope_exit;
  template &lt;class EF&gt;
    class scope_fail;
  template &lt;class EF&gt;
    class scope_success;

  <cxx-ref insynopsis to="scopeguard.uniqueres"></cxx-ref>
  template &lt;class R, class D&gt;
    class unique_resource;

  <cxx-ref insynopsis to="scopeguard.uniqueres.create"></cxx-ref>
  template &lt;class R, class D, class S=decay_t&lt;R&gt;&gt;
    unique_resource&lt;decay_t&lt;R&gt;, decay_t&lt;D&gt;&gt;
      make_unique_resource_checked(R&amp;&amp; r, const S&amp; invalid, D&amp;&amp; d) noexcept(<i>see below</i>);

} // namespace std::experimental::inline fundamentals_v3</code></pre>

    </cxx-section>

    <cxx-section id="scopeguard.exit">
      <h1>Class templates <code>scope_exit</code>, <code>scope_fail</code>, and <code>scope_success</code></h1>

      <p>The class templates <code>scope_exit</code>, <code>scope_fail</code>,
        and <code>scope_success</code> define scope guards that wrap a
        function object to be called on their destruction.</p>

      <p>In this subclause, the placeholder <code><i>scope-guard</i></code>
        denotes each of these class templates. In descriptions of the
        class members, <code><i>scope-guard</i></code> refers to the enclosing
        class.</p>

      <pre><code>namespace std::experimental::inline fundamentals_v3 {

  template &lt;class EF&gt; class <i>scope-guard</i> {
  public:
    template &lt;class EFP&gt;
      explicit <i>scope-guard</i>(EFP&amp;&amp; f) noexcept(<i>see below</i>);
    <i>scope-guard</i>(<i>scope-guard</i>&amp;&amp; rhs) noexcept(<i>see below</i>);

    <i>scope-guard</i>(const <i>scope-guard</i>&amp;) = delete;
    <i>scope-guard</i>&amp; operator=(const <i>scope-guard</i>&amp;) = delete;
    <i>scope-guard</i>&amp; operator=(<i>scope-guard</i>&amp;&amp;) = delete;

    ~<i>scope-guard</i> () noexcept(<i>see below</i>);

    void release() noexcept;

  private:
    EF exit_function;                                 // <i>exposition only</i>
    bool execute_on_destruction{true};                // <i>exposition only</i>
    int uncaught_on_creation{uncaught_exceptions()};  // <i>exposition only</i>
  };

  template &lt;class EF&gt;
    <i>scope-guard</i>(EF) -&gt; <i>scope-guard</i>&lt;EF&gt;;

}  // namespace std::experimental::inline fundamentals_v3</code></pre>

      <p>The class template <code>scope_exit</code> is a general-purpose
        scope guard that calls its exit function when a scope is exited. The
        class templates <code>scope_fail</code> and <code>scope_success</code>
        share the <code>scope_exit</code> interface, only the situation when the
        exit function is called differs.</p>
      <cxx-example><pre><code>void grow(vector&lt;int&gt;&amp; v) {
  scope_success guard([]{ cout &lt;&lt; "Good!" &lt;&lt; endl; });
  v.resize(1024);
}</code></pre></cxx-example>

      <p><cxx-note>If the exit function object of a <code>scope_success</code>
          or <code>scope_exit</code> object refers to a local variable
          of the function where it is defined, e.g., as a lambda capturing
          the variable by reference, and that variable is used as a return
          operand in that function, it is possible for that variable to already have been
          returned when the <code><i>scope-guard</i></code>&rsquo;s destructor
          executes, calling the exit function. This can lead to surprising
          behavior.</cxx-note></p>

      <p>Template argument <code>EF</code> shall be a function object type
        (<cxx-ref in="cxx" to="function.objects"></cxx-ref>), lvalue reference
        to function, or lvalue reference to function object type. If <code>EF</code>
        is an object type, it shall meet the <cxx-17concept>Cpp17Destructible</cxx-17concept>
        requirements (C++20 Table 30). Given an lvalue <code>g</code> of type
        <code>remove_reference_t&lt;EF&gt;</code>, the expression
        <code>g()</code> shall be well-formed.</p>

      <p>The constructor parameter <code>f</code> in the following constructors
        shall be a reference to a function or a reference to a function
        object (<cxx-ref in="cxx" to="function.objects"></cxx-ref>).</p>

      <cxx-function>
        <cxx-signature>template &lt;class EFP&gt;
explicit <i>scope-guard</i>(EFP&amp;&amp; f) noexcept(
    is_nothrow_constructible_v&lt;EF, EFP&gt; ||
    is_nothrow_constructible_v&lt;EF, EFP&amp;&gt);</cxx-signature>

        <cxx-constraints>
          <code>is_same_v&lt;remove_cvref_t&lt;EFP&gt;,
          <i>scope-guard</i>&gt;</code> is <code>false</code> and
          <code>is_constructible_v&lt;EF, EFP&gt;</code> is <code>true</code>.
        </cxx-constraints>

        <cxx-mandates>
          The expression <code>f()</code> is well-formed.
        </cxx-mandates>

        <cxx-preconditions>
          Calling <code>f()</code> has well-defined behavior.
          For <code>scope_exit</code> and <code>scope_fail</code>,
          calling <code>f()</code> does not throw an exception.
        </cxx-preconditions>

        <cxx-effects>
          If <code>EFP</code> is not an lvalue reference type and
          <code>is_nothrow_constructible_v&lt;EF, EFP&gt;</code>
          is <code>true</code>, initialize <code>exit_function</code>
          with <code>std::forward&lt;EFP&gt;(f)</code>;
          otherwise initialize <code>exit_function</code> with <code>f</code>.
          For <code>scope_exit</code> and <code>scope_fail</code>,
          if the initialization of <code>exit_function</code> throws an exception,
          calls <code>f()</code>.
          <cxx-note>For <code>scope_success</code>, <code>f()</code> will not be
          called if the initialization fails.</cxx-note>
        </cxx-effects>

        <cxx-throws>
          Any exception thrown during the initialization of <code>exit_function</code>.
        </cxx-throws>
      </cxx-function>

      <cxx-function>
        <cxx-signature><i>scope-guard</i>(<i>scope-guard</i>&amp;&amp; rhs) noexcept(<i>see below</i>)</cxx-signature>

        <cxx-constraints>
          <code>(is_nothrow_move_constructible_v&lt;EF&gt; || is_copy_constructible_v&lt;EF&gt;)</code>
          is <code>true</code>.
        </cxx-constraints>

        <cxx-preconditions>
          If <code>EF</code> is an object type:
          <ul>
            <li>if <code>is_nothrow_move_constructible_v&lt;EF&gt;</code> is <code>true</code>,
              <code>EF</code> meets the <cxx-17concept>Cpp17MoveConstructible</cxx-17concept> requirements (C++20 Table 26),</li>
            <li>otherwise <code>EF</code> meets the <cxx-17concept>Cpp17CopyConstructible</cxx-17concept> requirements (C++20 Table 27).</li>
          </ul>
        </cxx-preconditions>

        <cxx-effects>
          If <code>is_nothrow_move_constructible_v&lt;EF&gt;</code> is <code>true</code>,
          initializes <code>exit_function</code> with <code>std::forward&lt;EF&gt;(rhs.exit_function)</code>,
          otherwise initializes <code>exit_function</code> with <code>rhs.exit_function</code>.
          Initializes <code>execute_on_destruction</code> from <code>rhs.execute_on_destruction</code> and
          <code>uncaught_on_creation</code> from <code>rhs.uncaught_on_creation</code>.
          If construction succeeds, call <code>rhs.release()</code>.
          <cxx-note>Copying instead of moving provides the strong exception guarantee.</cxx-note>
        </cxx-effects>

        <cxx-postconditions>
          <code>execute_on_destruction</code> yields the value <code>rhs.execute_on_destruction</code>
          yielded before the construction. <code>uncaught_on_creation</code> yields the value
          <code>rhs.uncaught_on_creation</code> yielded before the construction.
        </cxx-postconditions>

        <cxx-throws>
          Any exception thrown during the initialization of <code>exit_function</code>.
        </cxx-throws>

        <cxx-remarks>
          The expression inside <code>noexcept</code> is equivalent to:
          <pre><code>is_nothrow_move_constructible_v&lt;EF&gt; || is_nothrow_copy_constructible_v&lt;EF&gt;</code></pre>
        </cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>~scope_exit() noexcept(true);</cxx-signature>
        <cxx-effects>
          Equivalent to:
          <pre><code>if (execute_on_destruction)
  exit_function();</code></pre>
        </cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>~scope_fail() noexcept(true);</cxx-signature>
        <cxx-effects>
          Equivalent to:
          <pre><code>if (execute_on_destruction &amp;&amp; uncaught_exceptions() &gt; uncaught_on_creation)
  exit_function();</code></pre>
        </cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>~scope_success() noexcept(noexcept(exit_function()));</cxx-signature>
        <cxx-effects>
          Equivalent to:
          <pre><code>if (execute_on_destruction &amp;&amp; uncaught_exceptions() &lt;= uncaught_on_creation)
  exit_function();</code></pre>
          <cxx-note>
            If <code>noexcept(exit_function())</code> is <code>false</code>,
            <code>exit_function()</code> may throw an exception,
            notwithstanding the restrictions of <cxx-ref in="cxx" to="res.on.exception.handling"></cxx-ref>.
          </cxx-note>
        </cxx-effects>
        <cxx-throws>
          Any exception thrown by <code>exit_function()</code>.
        </cxx-throws>
      </cxx-function>

      <cxx-function>
        <cxx-signature>void release() noexcept;</cxx-signature>
        <cxx-effects>
          Equivalent to <code>execute_on_destruction = false</code>.
        </cxx-effects>
      </cxx-function>

    </cxx-section>

    <cxx-section id="scopeguard.uniqueres">

      <h1>Class template <code>unique_resource</code></h1>

      <cxx-section id="scopeguard.uniqueres.overview">
        <h1>Overview</h1>

        <pre><code>namespace std::experimental::inline fundamentals_v3 {

  template &lt;class R, class D&gt; class unique_resource {
  public:
    <cxx-ref insynopsis to="scopeguard.uniqueres.ctor"></cxx-ref>
    unique_resource();
    template &lt;class RR, class DD&gt;
      unique_resource(RR&amp;&amp; r, DD&amp;&amp; d) noexcept(<i>see below</i>);
    unique_resource(unique_resource&amp;&amp; rhs) noexcept(<i>see below</i>);

    <cxx-ref insynopsis to="scopeguard.uniqueres.dtor"></cxx-ref>
    ~unique_resource();

    <cxx-ref insynopsis to="scopeguard.uniqueres.assign"></cxx-ref>
    unique_resource&amp; operator=(unique_resource&amp;&amp; rhs) noexcept(<i>see below</i>);

    <cxx-ref insynopsis to="scopeguard.uniqueres.members"></cxx-ref>
    void reset() noexcept;
    template &lt;class RR&gt;
      void reset(RR&amp;&amp; r);
    void release() noexcept;
    const R&amp; get() const noexcept;
    <i>see below</i> operator*() const noexcept;
    R operator-&gt;() const noexcept;
    const D&amp; get_deleter() const noexcept;

  private:
    using R1 = conditional_t&lt;is_reference_v&lt;R&gt;, reference_wrapper&lt;remove_reference_t&lt;R&gt;&gt;, R&gt;;  // <i>exposition only</i>
    R1 resource;                  // <i>exposition only</i>
    D deleter;                    // <i>exposition only</i>
    bool execute_on_reset{true};  // <i>exposition only</i>
  };

  template&lt;class R, class D&gt;
    unique_resource(R, D) -&gt; unique_resource&lt;R, D&gt;;

}  // namespace std::experimental::inline fundamentals_v3</code></pre>

        <p>
          <cxx-note><code>unique_resource</code> is a universal RAII wrapper for resource handles.
            Typically, such resource handles are of trivial type and come with a factory function
            and a clean-up or deleter function that do not throw exceptions. The clean-up function
            together with the result of the creation function is used to create a <code>unique_resource</code>
            variable, that on destruction will call the clean-up function. Access to the underlying
            resource handle is achieved through <code>get()</code> and in case of a pointer type
            resource through a set of convenience pointer operator functions.</cxx-note>
        </p>

        <p>
          The template argument <code>D</code> shall meet the requirements of a
          <cxx-17concept>Cpp17Destructible</cxx-17concept> (C++20 Table 30) function object type
          (<cxx-ref in="cxx" to="function.objects"></cxx-ref>), for which,
          given a lvalue <code>d</code> of type <code>D</code> and a lvalue <code>r</code> of
          type <code>R</code>, the expression <code>d(r)</code> shall be well-formed.
          <code>D</code> shall either meet the <cxx-17concept>Cpp17CopyConstructible</cxx-17concept> requirements
          (C++20 Table 27), or <code>D</code> shall meet the <cxx-17concept>Cpp17MoveConstructible</cxx-17concept> requirements
          (C++20 Table 26) and <code>is_nothrow_move_constructible_v&lt;D&gt;</code> shall be <code>true</code>.
        </p>

        <p>
          For the purpose of this subclause, a resource type <code>T</code>
          is an object type that meets the requirements of <cxx-17concept>Cpp17CopyConstructible</cxx-17concept>
          (C++20 Table 27), or is an object type that meets the requirements of <cxx-17concept>Cpp17MoveConstructible</cxx-17concept>
          (C++20 Table 26) and <code>is_nothrow_move_constructible_v&lt;T&gt;</code> is <code>true</code>,
          or is an lvalue reference to a resource type. <code>R</code> shall be a resource type.
        </p>

        <p>
          For the scope of the adjacent subclauses,
          let <code><i>RESOURCE</i></code> be defined as follows:
          <ul>
            <li><code>resource.get()</code> if <code>is_reference_v&lt;R&gt;</code> is <code>true</code>,</li>
            <li><code>resource</code> otherwise.</li>
          </ul>
        </p>
      </cxx-section>

      <cxx-section id="scopeguard.uniqueres.ctor">
        <h1>Constructors</h1>

        <cxx-function>
          <cxx-signature>unique_resource()</cxx-signature>
          <cxx-constraints>
            <code>is_default_constructible_v&lt;R&gt; &amp;&amp;
            is_default_constructible_v&lt;D&gt;</code> is <code>true</code>.
          </cxx-constraints>
          <cxx-effects>
            Value-initializes <code>resource</code> and <code>deleter</code>;
            <code>execute_on_reset</code> is initialized with <code>false</code>.
          </cxx-effects>
        </cxx-function>

        <cxx-function>
          <cxx-signature>template &lt;class RR, class DD&gt;
unique_resource(RR&amp;&amp; r, DD&amp;&amp; d) noexcept(<i>see below</i>)</cxx-signature>

          <cxx-constraints>
            <pre><code>is_constructible_v&lt;R1, RR&gt; &amp;&amp;
is_constructible_v&lt;D , DD&gt; &amp;&amp;
(is_nothrow_constructible_v&lt;R1, RR&gt; || is_constructible_v&lt;R1,RR&amp;&gt;) &amp;&amp;
(is_nothrow_constructible_v&lt;D , DD&gt; || is_constructible_v&lt;D ,DD&amp;&gt;)</code></pre>
            is <code>true</code>.
            <cxx-note>
              The first two conditions prohibit initialization from an rvalue reference when either <code>R1</code>
              or <code>D</code> is a specialization of <code>reference_wrapper</code>.
            </cxx-note>
          </cxx-constraints>

          <cxx-mandates>
            The expressions <code>d(r)</code>, <code>d(<i>RESOURCE</i>)</code>
            and <code>deleter(<i>RESOURCE</i>)</code> are well-formed.
          </cxx-mandates>

          <cxx-preconditions>
            Calling <code>d(r)</code>, <code>d(<i>RESOURCE</i>)</code>
            or <code>deleter(<i>RESOURCE</i>)</code> has well-defined behavior and
            does not throw an exception.
          </cxx-preconditions>

          <cxx-effects>
            If <code>is_nothrow_constructible_v&lt;R1, RR&gt;</code> is <code>true</code>,
            initializes <code>resource</code> with <code>std::forward&lt;RR&gt;(r)</code>,
            otherwise initializes <code>resource</code> with <code>r</code>.
            Then, if <code>is_nothrow_constructible_v&lt;D, DD&gt;</code> is true,
            initializes <code>deleter</code> with <code>std::forward&lt;DD&gt;(d)</code>,
            otherwise initializes <code>deleter</code> with <code>d</code>.
            If initialization of <code>resource</code> throws an exception,
            calls <code>d(r)</code>.
            If initialization of <code>deleter</code> throws an exception, calls <code>d(<i>RESOURCE</i>)</code>.
            <cxx-note>
              The explained mechanism ensures no leaking of resources.
            </cxx-note>
          </cxx-effects>

          <cxx-throws>
            Any exception thrown during initialization of <code>resource</code> or <code>deleter</code>.
          </cxx-throws>

          <cxx-remarks>
            The expression inside <code>noexcept</code> is equivalent to:
            <pre><code>(is_nothrow_constructible_v&lt;R1, RR&gt; || is_nothrow_constructible_v&lt;R1, RR&amp;&gt;) &amp;&amp;
(is_nothrow_constructible_v&lt;D , DD&gt; || is_nothrow_constructible_v&lt;D , DD&amp;&gt;)</code></pre>
          </cxx-remarks>
        </cxx-function>

        <cxx-function>
          <cxx-signature>unique_resource(unique_resource&amp;&amp; rhs) noexcept(<i>see below</i>);</cxx-signature>

          <cxx-effects>
            First, initialize <code>resource</code> as follows:
            <ul>
              <li>If <code>is_nothrow_move_constructible_v&lt;R1&gt;</code> is
                <code>true</code>, from <code>std::move(rhs.resource)</code>;</li>
              <li>otherwise, from <code>rhs.resource</code>.</li>
            </ul>
            <cxx-note>
              If initialization of <code>resource</code> throws an exception,
              <code>rhs</code> is left owning the resource and will free it in due time.
            </cxx-note>
            Then, initialize <code>deleter</code> as follows:
            <ul>
              <li>If <code>is_nothrow_move_constructible_v&lt;D&gt;</code> is
                <code>true</code>, from <code>std::move(rhs.deleter)</code>;</li>
              <li>otherwise, from <code>rhs.deleter</code>.</li>
            </ul>
            If initialization of <code>deleter</code> throws an exception and
            <code>is_nothrow_move_constructible_v&lt;R1&gt;</code> is <code>true</code>
            and <code>rhs.execute_on_reset</code> is true:
            <pre><code>rhs.deleter(<i>RESOURCE</i>);
rhs.release();</code></pre>
            Finally, <code>execute_on_reset</code> is initialized with
            <code>exchange(rhs.execute_on_reset, false)</code>.
            <cxx-note>
              The explained mechanism ensures no leaking and no double release of resources.
            </cxx-note>
          </cxx-effects>

          <cxx-remarks>
            The expression inside <code>noexcept</code> is equivalent to:
            <pre><code>is_nothrow_move_constructible_v&lt;R1&gt; &amp;&amp; is_nothrow_move_constructible_v&lt;D&gt;</code></pre>
          </cxx-remarks>
        </cxx-function>
      </cxx-section>

      <cxx-section id="scopeguard.uniqueres.dtor">
        <h1>Destructor</h1>

        <cxx-function>
          <cxx-signature>~unique_resource();</cxx-signature>
          <cxx-effects>Equivalent to <code>reset()</code>.</cxx-effects>
        </cxx-function>
      </cxx-section>

      <cxx-section id="scopeguard.uniqueres.assign">
        <h1>Assignment</h1>

        <cxx-function>
          <cxx-signature>unique_resource&amp; operator=(unique_resource&amp;&amp; rhs) noexcept(<i>see below</i>);</cxx-signature>

          <cxx-preconditions>
            If <code>is_nothrow_move_assignable_v&lt;R1&gt;</code> is <code>true</code>,
            <code>R1</code> meets the <cxx-17concept>Cpp17MoveAssignable</cxx-17concept> (C++20 Table 28)
            requirements; otherwise <code>R1</code>
            meets the <cxx-17concept>Cpp17CopyAssignable</cxx-17concept> (C++20 Table 29) requirements.
            If <code>is_nothrow_move_assignable_v&lt;D&gt;</code> is <code>true</code>,
            <code>D</code> meets the <cxx-17concept>Cpp17MoveAssignable</cxx-17concept> (C++20 Table 28) requirements;
            otherwise <code>D</code> meets the <cxx-17concept>Cpp17CopyAssignable</cxx-17concept> (C++20 Table 29) requirements.
          </cxx-preconditions>

          <cxx-effects>
            Equivalent to:
            <pre><code>reset();
if constexpr (is_nothrow_move_assignable_v&lt;R1&gt;) {
  if constexpr (is_nothrow_move_assignable_v&lt;D&gt;) {
    resource = std::move(rhs.resource);
    deleter = std::move(rhs.deleter);
  } else {
    deleter = rhs.deleter;
    resource = std::move(rhs.resource);
  }
} else {
  if constexpr (is_nothrow_move_assignable_v&lt;D&gt;) {
    resource = rhs.resource;
    deleter = std::move(rhs.deleter);
  } else {
    resource = rhs.resource;
    deleter = rhs.deleter;
  }
}
execute_on_reset = exchange(rhs.execute_on_reset, false);</code></pre>
            <cxx-note>
              If a copy of a member throws an exception, this mechanism leaves
              <code>rhs</code> intact and <code>*this</code> in the released state.
            </cxx-note>
          </cxx-effects>

          <cxx-returns><code>*this</code>.</cxx-returns>

          <cxx-throws>
            Any exception thrown during a copy-assignment of a member that
            cannot be moved without an exception.
          </cxx-throws>

          <cxx-remarks>
            The expression inside <code>noexcept</code> is equivalent to:
            <pre><code>is_nothrow_move_assignable_v&lt;R1&gt; &amp;&amp; is_nothrow_move_assignable_v&lt;D&gt;</code></pre>
          </cxx-remarks>
        </cxx-function>
      </cxx-section>

      <cxx-section id="scopeguard.uniqueres.members">
        <h1>Other member functions</h1>

        <cxx-function>
          <cxx-signature>void reset() noexcept;</cxx-signature>

          <cxx-effects>
            Equivalent to:
            <pre><code>if (execute_on_reset) {
  execute_on_reset = false;
  deleter(<i>RESOURCE</i>);
}</code></pre>
          </cxx-effects>
        </cxx-function>

        <cxx-function>
          <cxx-signature>template &lt;class RR&gt; void reset(RR&amp;&amp; r);</cxx-signature>

          <cxx-constraints>
            the selected assignment expression statement assigning <code>resource</code> is well-formed.
          </cxx-constraints>

          <cxx-mandates>
            The expression <code>deleter(r)</code> is well-formed.
          </cxx-mandates>

          <cxx-preconditions>
            Calling <code>deleter(r)</code> has well-defined behavior
            and does not throw an exception.
          </cxx-preconditions>

          <cxx-effects>
            Equivalent to:
            <pre><code>reset();
if constexpr (is_nothrow_assignable_v&lt;R1&amp;, RR&gt;) {
  resource = std::forward&lt;RR&gt;(r);
} else {
  resource = as_const(r);
}
execute_on_reset = true;</code></pre>
            If copy-assignment of <code>resource</code> throws an exception,
            calls <code>deleter(r)</code>.
          </cxx-effects>
        </cxx-function>

        <cxx-function>
          <cxx-signature>void release() noexcept;</cxx-signature>
          <cxx-effects>Equivalent to <code>execute_on_reset = false</code>.</cxx-effects>
        </cxx-function>

        <cxx-function>
          <cxx-signature>const R&amp; get() const noexcept;</cxx-signature>
          <cxx-returns><code>resource</code>.</cxx-returns>
        </cxx-function>

        <cxx-function>
          <cxx-signature><i>see below</i> operator*() const noexcept;</cxx-signature>
          <cxx-constraints>
            <code>is_pointer_v&lt;R&gt;</code> is <code>true</code> and
            <code>is_void_v&lt;remove_pointer_t&lt;R&gt;&gt;</code> is <code>false</code>.
          </cxx-constraints>
          <cxx-effects>Equivalent to: <code>return *get();</code></cxx-effects>
          <cxx-remarks>
            The return type is <code>add_lvalue_reference_t&lt;remove_pointer_t&lt;R&gt;&gt;</code>.
          </cxx-remarks>
        </cxx-function>

        <cxx-function>
          <cxx-signature>R operator->() const noexcept;</cxx-signature>
          <cxx-constraints>
            <code>is_pointer_v&lt;R&gt;</code> is <code>true</code>.
          </cxx-constraints>
          <cxx-returns><code>get()</code>.</cxx-returns>
        </cxx-function>

        <cxx-function>
          <cxx-signature>const D&amp; get_deleter() const noexcept;</cxx-signature>
          <cxx-returns><code>deleter</code>.</cxx-returns>
        </cxx-function>
      </cxx-section>

      <cxx-section id="scopeguard.uniqueres.create">
        <h1><code>unique_resource</code> creation</h1>

        <cxx-function>
          <cxx-signature>template &lt;class R, class D, class S=decay_t&lt;R&gt;&gt;
unique_resource&lt;decay_t&lt;R&gt;, decay_t&lt;D&gt;&gt;
  make_unique_resource_checked(R&amp;&amp; resource, const S&amp; invalid, D&amp;&amp; d)
  noexcept(is_nothrow_constructible_v&lt;decay_t&lt;R&gt;, R&gt; &amp;&amp;
           is_nothrow_constructible_v&lt;decay_t&lt;D&gt;, D&gt;);</cxx-signature>

          <cxx-mandates>
            The expression <code>(resource == invalid ? true : false)</code> is well-formed.
          </cxx-mandates>
          <cxx-preconditions>
            Evaluation of the expression <code>(resource == invalid ? true : false)</code>
            has well-defined behavior and does not throw an exception.
          </cxx-preconditions>

          <cxx-effects>
            Returns an object constructed with members initialized from
            <code>std::forward&lt;R&gt;(resource), std::forward&lt;D&gt;(d)</code>,
            and <code>!bool(resource == invalid)</code>.
            Any failure during construction of the return value will not call <code>d(resource)</code>
            if <code>bool(resource == invalid)</code> is <code>true</code>.
          </cxx-effects>
        </cxx-function>

        <p>
          <cxx-note>
            This creation function exists to avoid calling a deleter function
            with an invalid argument.
          </cxx-note>
        </p>
        <cxx-example>
          The following example shows its use to avoid calling <code>fclose</code>
          when <code>fopen</code> fails.
          <pre><code>auto file = make_unique_resource_checked(
    ::fopen("potentially_nonexistent_file.txt", "r"),
    nullptr,
    [](auto fptr){ ::fclose(fptr); });</code></pre>
        </cxx-example>
      </cxx-section>
    </cxx-section>
  </cxx-section>

  <cxx-section id="meta">
    <h1>Metaprogramming and type traits</h1>

    <cxx-section id="meta.type.syn">
      <h1>Header &lt;experimental/type_traits> synopsis</h1>

<pre><code>#include &lt;type_traits>

namespace std::experimental::inline fundamentals_v3 {

  <cxx-ref insynopsis="" to="meta.trans.other"></cxx-ref>
  template &lt;class> class invocation_type; // <i>not defined</i>
  template &lt;class F, class... ArgTypes> class invocation_type&lt;F(ArgTypes...)>;
  template &lt;class> class raw_invocation_type; // <i>not defined</i>
  template &lt;class F, class... ArgTypes> class raw_invocation_type&lt;F(ArgTypes...)>;

  template &lt;class T>
    using invocation_type_t = typename invocation_type&lt;T>::type;
  template &lt;class T>
    using raw_invocation_type_t = typename raw_invocation_type&lt;T>::type;

  <cxx-ref insynopsis to="meta.detect"></cxx-ref>
  struct nonesuch;

  template &lt;template&lt;class...> class Op, class... Args>
    using is_detected = <i>see below</i>;
  template &lt;template&lt;class...> class Op, class... Args>
    inline constexpr bool is_detected_v
      = is_detected&lt;Op, Args...>::value;
  template &lt;template&lt;class...> class Op, class... Args>
    using detected_t = <i>see below</i>;
  template &lt;class Default, template&lt;class...> class Op, class... Args>
    using detected_or = <i>see below</i>;
  template &lt;class Default, template&lt;class...> class Op, class... Args>
    using detected_or_t = typename detected_or&lt;Default, Op, Args...>::type;
  template &lt;class Expected, template&lt;class...> class Op, class... Args>
    using is_detected_exact = is_same&lt;Expected, detected_t&lt;Op, Args...>>;
  template &lt;class Expected, template&lt;class...> class Op, class... Args>
    inline constexpr bool is_detected_exact_v
      = is_detected_exact&lt;Expected, Op, Args...>::value;
  template &lt;class To, template&lt;class...> class Op, class... Args>
    using is_detected_convertible = is_convertible&lt;detected_t&lt;Op, Args...>, To>;
  template &lt;class To, template&lt;class...> class Op, class... Args>
    inline constexpr bool is_detected_convertible_v
      = is_detected_convertible&lt;To, Op, Args...>::value;

} // namespace std::experimental::inline fundamentals_v3</code></pre>

    </cxx-section>

    <cxx-section id="meta.trans.other">
      <h1>Other type transformations</h1>

      <p>
        This subclause contains templates that may be used to transform one type to another following some predefined rule.
      </p>

      <p>
        Each of the templates in this subclause shall be a <cxx-term>TransformationTrait</cxx-term> (<cxx-ref in="cxx" to="meta.rqmts"></cxx-ref>).
      </p>

      <p>
        Within this section, define the <dfn>invocation parameters</dfn> of <code><em>INVOKE</em>(f, t1, t2, ..., tN)</code> as follows,
        in which <code>T1</code> is the possibly <var>cv</var>-qualified type of <code>t1</code>
        and <code>U1</code> denotes <code>T1&amp;</code> if <code>t1</code> is an lvalue
        or <code>T1&amp;&amp;</code> if <code>t1</code> is an rvalue:
      </p>
      <ul>
        <li>
          When <code>f</code> is a pointer to a member function of a class <code>T</code>
          the <cxx-term>invocation parameters</cxx-term> are <code>U1</code> followed by
          the parameters of <code>f</code> matched by <code>t2</code>, ..., <code>tN</code>.
        </li>
        <li>
          When <code>N == 1</code> and <code>f</code> is a pointer to member data of a class <code>T</code>
          the <cxx-term>invocation parameter</cxx-term> is <code>U1</code>.
        </li>
        <li>
          If <code>f</code> is a class object,
          the <cxx-term>invocation parameters</cxx-term> are the parameters matching <code>t1</code>, ..., <code>tN</code>
          of the best viable function (<cxx-ref in="cxx" to="over.match.best"></cxx-ref>)
          for the arguments <code>t1</code>, ..., <code>tN</code>
          among the function call operators and surrogate call functions of <code>f</code>.
        </li>
        <li>
          In all other cases,
          the <cxx-term>invocation parameters</cxx-term> are the parameters of <code>f</code>
          matching <code>t1</code>, ... <code>tN</code>.
        </li>
      </ul>
      <p>
        In all of the above cases,
        if an argument <code>tI</code> matches the ellipsis in the function's <cxx-term>parameter-declaration-clause</cxx-term>,
        the corresponding <cxx-term>invocation parameter</cxx-term> is defined to be
        the result of applying the default argument promotions (<cxx-ref in="cxx" to="expr.call"></cxx-ref>) to <code>tI</code>.
      </p>

      <cxx-example>
        Assume <code>S</code> is defined as
        <pre><code>struct S {
  int f(double const &amp;) const;
  void operator()(int, int);
  void operator()(char const *, int i = 2, int j = 3);
  void operator()(...);
};</code></pre>
        <ul>
          <li>The invocation parameters of <code><em>INVOKE</em>(&amp;S::f, S(), 3.5)</code> are <code>(S &amp;&amp;, double const &amp;)</code>.</li>
          <li>The invocation parameters of <code><em>INVOKE</em>(S(), 1, 2)</code> are <code>(int, int)</code>.</li>
          <li>The invocation parameters of <code><em>INVOKE</em>(S(), "abc", 5)</code> are <code>(const char *, int)</code>.
          The defaulted parameter <code>j</code> does not correspond to an argument.</li>
          <li>The invocation parameters of <code><em>INVOKE</em>(S(), locale(), 5)</code> are <code>(locale, int)</code>.
          Arguments corresponding to ellipsis maintain their types.</li>
        </ul>
      </cxx-example>

      <table is="cxx-table" id="tab:meta.trans.other">
        <caption>Other type transformations</caption>
        <thead>
          <tr><th>Template</th><th>Condition</th><th>Comments</th></tr>
        </thead>
        <tr>
          <td>
            <code>template &lt;class Fn, class... ArgTypes&gt;<br/>
            struct raw_invocation_type&lt;<w-br></w-br>Fn(ArgTypes...)&gt;;</code>
          </td>
          <td>
            <code>Fn</code> and all types in the parameter pack <code>ArgTypes</code>
            shall be complete types, (possibly cv-qualified) <code>void</code>, or arrays of unknown bound.
          </td>

          <td>
            <em>see below</em>
          </td>
        </tr>
        <tr>
          <td>
            <code>template &lt;class Fn, class... ArgTypes&gt;<br/>
            struct invocation_type&lt;<w-br></w-br>Fn(ArgTypes...)&gt;;</code>
          </td>
          <td>
            <code>Fn</code> and all types in the parameter pack <code>ArgTypes</code>
            shall be complete types, (possibly cv-qualified) <code>void</code>,
            or arrays of unknown bound.
          </td>
          <td>
            <em>see below</em>
          </td>
        </tr>
      </table>

      <p>
        Access checking is performed as if in a context unrelated to <code>Fn</code> and <code>ArgTypes</code>.
        Only the validity of the immediate context of the expression is considered.
        <cxx-note>The compilation of the expression can result in side effects
        such as the instantiation of class template specializations and function template specializations,
        the generation of implicitly-defined functions, and so on.
        Such side effects are not in the "immediate context"
        and can result in the program being ill-formed.</cxx-note>
      </p>

      <p>
        The member <code>raw_invocation_type&lt;Fn(ArgTypes...)&gt;::type</code> shall be defined as follows.
        If the expression <code><em>INVOKE</em>(declval&lt;Fn&gt;(), declval&lt;ArgTypes&gt;()...)</code>
        is ill-formed when treated as an unevaluated operand (<cxx-ref in="cxx" to="expr"></cxx-ref>),
        there shall be no member <code>type</code>. Otherwise:
      </p>
      <ul>
        <li>Let <code>R</code> denote <code>result_of_t&lt;Fn(ArgTypes...)&gt;</code>.</li>
        <li>Let the types <code>Ti</code> be the <cxx-term>invocation parameters</cxx-term>
        of <code><em>INVOKE</em>(declval&lt;Fn&gt;(), <nobr>declval&lt;ArgTypes&gt;()...)</code></nobr>.</li>
        <li>Then the member <code>type</code> shall name the function type <code>R(T1, T2, ...)</code>.</li>
      </ul>

      <p>
        The member <code>invocation_type&lt;Fn(ArgTypes...)&gt;::type</code> shall be defined as follows.
        If <code>raw_invocation_type&lt;Fn(ArgTypes...)&gt;::type</code> does not exist, there shall be no member <code>type</code>.
        Otherwise:
      </p>
      <ul>
        <li>Let <code>A1, A2,</code>  denote <code>ArgTypes...</code></li>
        <li>Let <code>R(T1, T2, )</code> denote <code>raw_invocation_type_t&lt;Fn(ArgTypes...)&gt;</code></li>
        <li>
          Then the member <code>type</code> shall name the function type <code>R(U1, U2, )</code>
          where <code>Ui</code> is <code>decay_t&lt;Ai&gt;</code> if <code>declval&lt;Ai&gt;()</code> is an rvalue
          otherwise <code>Ti</code>.
        </li>
      </ul>
    </cxx-section>

    <cxx-section id="meta.detect">
      <h1>Detection idiom</h1>

      <pre><code>struct nonesuch {
  ~nonesuch() = delete;
  nonesuch(nonesuch const&) = delete;
  void operator=(nonesuch const&) = delete;
};</code></pre>
      <p>
        <code>nonesuch</code> has no default constructor
        (<cxx-ref in="cxx" to="class.ctor"></cxx-ref>) or initializer-list constructor
        (<cxx-ref in="cxx" to="dcl.init.list"></cxx-ref>), and is not an aggregate
        (<cxx-ref in="cxx" to="dcl.init.aggr"></cxx-ref>).
      </p>

      <pre><code>template &lt;class Default, class AlwaysVoid,
          template&lt;class...> class Op, class... Args>
struct DETECTOR { // <i>exposition only</i>
  using value_t = false_type;
  using type = Default;
};

template &lt;class Default, template&lt;class...> class Op, class... Args>
struct DETECTOR&lt;Default, void_t&lt;Op&lt;Args...>>, Op, Args...> { // <i>exposition only</i>
  using value_t = true_type;
  using type = Op&lt;Args...>;
};

template &lt;template&lt;class...> class Op, class... Args>
  using is_detected = typename DETECTOR&lt;nonesuch, void, Op, Args...>::value_t;

template &lt;template&lt;class...> class Op, class... Args>
  using detected_t = typename DETECTOR&lt;nonesuch, void, Op, Args...>::type;

template &lt;class Default, template&lt;class...> class Op, class... Args>
  using detected_or = DETECTOR&lt;Default, void, Op, Args...>;</code></pre>

      <cxx-example>
        <pre><code>// <i>archetypal helper alias for a copy assignment operation:</i>
template &lt;class T>
  using copy_assign_t = decltype(declval&lt;T&>() = declval&lt;T const &>());

// <i>plausible implementation for the is_assignable type trait:</i>
template &lt;class T>
  using is_copy_assignable = is_detected&lt;copy_assign_t, T>;

// <i>plausible implementation for an augmented is_assignable type trait</i>
// <i>that also checks the return type:</i>
template &lt;class T>
  using is_canonical_copy_assignable = is_detected_exact&lt;T&, copy_assign_t, T>;</code></pre>
      </cxx-example>

      <cxx-example>
        <pre><code>// <i>archetypal helper alias for a particular type member:</i>
template &lt;class T>
  using diff_t = typename T::difference_type;

// <i>alias the type member, if it exists, otherwise alias </i>ptrdiff_t<i>:</i>
template &lt;class Ptr>
  using difference_type = detected_or_t&lt;ptrdiff_t, diff_t, Ptr>;</code></pre>
      </cxx-example>
    </cxx-section>
  </cxx-section>
</cxx-clause>
