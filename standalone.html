<html><head>
  <meta charset="utf-8">
  
  
  
  
  
  
  
  
  
  
  
  
  
<title>Working Draft, Technical Specification on C++ Extensions for Library Fundamentals</title><style>template { display: none ! important; }element { display: none ! important; }[unresolved] { opacity: 0; display: block; overflow: hidden; }[resolved] { display: block; overflow: hidden; transition: opacity 0.2s ease 0s; }[unresolved] { opacity: 0; display: block; overflow: hidden; }[resolved] { display: block; overflow: hidden; transition: opacity 0.2s ease 0s; }style { display: none ! important; }cxx-section { display: block; }cxx-section:target { background-color: inherit; }cxx-section:target > section > h1 { background-color: rgb(255, 238, 221); }cxx-clause { display: block; }cxx-clause:target { background-color: inherit; }cxx-clause:target > section > h1 { background-color: rgb(255, 238, 221); }cxx-toc { display: block; }cxx-toc li { list-style-type: none; }cxx-toc ol { font-weight: normal; }cxx-toc nav > ol { padding-left: 0px; font-weight: bold; }cxx-toc .marker { margin-right: 1em; }cxx-function { display: block; }cxx-function:not(:last-child) { margin-bottom: 3ex; }cxx-function > dl { margin: 0px 0px 0px 2em; }cxx-function > pre { margin: 0px; }cxx-signature { padding-left: 2em; display: block; text-indent: -2em; }cxx-attribute { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-attribute dt { float: left; font-style: italic; padding-right: 1ex; }cxx-attribute dd { margin-left: 0em; }cxx-requires { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-requires dt { float: left; font-style: italic; padding-right: 1ex; }cxx-requires dd { margin-left: 0em; }cxx-effects { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-effects dt { float: left; font-style: italic; padding-right: 1ex; }cxx-effects dd { margin-left: 0em; }cxx-synchronization { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-synchronization dt { float: left; font-style: italic; padding-right: 1ex; }cxx-synchronization dd { margin-left: 0em; }cxx-postconditions { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-postconditions dt { float: left; font-style: italic; padding-right: 1ex; }cxx-postconditions dd { margin-left: 0em; }cxx-returns { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-returns dt { float: left; font-style: italic; padding-right: 1ex; }cxx-returns dd { margin-left: 0em; }cxx-throws { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-throws dt { float: left; font-style: italic; padding-right: 1ex; }cxx-throws dd { margin-left: 0em; }cxx-exception-safety { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-exception-safety dt { float: left; font-style: italic; padding-right: 1ex; }cxx-exception-safety dd { margin-left: 0em; }cxx-remarks { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-remarks dt { float: left; font-style: italic; padding-right: 1ex; }cxx-remarks dd { margin-left: 0em; }cxx-error-conditions { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-error-conditions dt { float: left; font-style: italic; padding-right: 1ex; }cxx-error-conditions dd { margin-left: 0em; }cxx-notes { display: block; margin-top: 0.5em; margin-bottom: 0.5em; }cxx-notes dt { float: left; font-style: italic; padding-right: 1ex; }cxx-notes dd { margin-left: 0em; }cxx-titlepage { display: block; page-break-after: always; min-height: 100%; }cxx-titlepage { position: relative; }cxx-titlepage table { position: absolute; right: 0px; top: 0px; }cxx-titlepage h1 { position: absolute; top: 40%; }cxx-titlepage p.warning { position: absolute; bottom: 5%; }cxx-titlepage h1 { text-align: center; }cxx-titlepage th { text-align: left; vertical-align: top; }cxx-ednote { display: block; }cxx-ednote aside { background-color: rgb(238, 238, 238); border-color: rgb(136, 136, 136); border-style: dashed; }cxx-publish-button { display: block; }[touch-action="none"] {  }[touch-action="auto"] {  }[touch-action="pan-x"] {  }[touch-action="pan-y"] {  }[touch-action="pan-x pan-y"], [touch-action="pan-y pan-x"] {  }[touch-action="none"] {  }body [touch-action="none"] {  }[touch-action="auto"] {  }body [touch-action="auto"] {  }[touch-action="pan-x"] {  }body [touch-action="pan-x"] {  }[touch-action="pan-y"] {  }body [touch-action="pan-y"] {  }[touch-action="pan-x pan-y"], [touch-action="pan-y pan-x"] {  }body [touch-action="pan-x pan-y"], body [touch-action="pan-y pan-x"] {  }@page { margin: 10%; }@media screen {
  body { max-width: 7in; }
}html, body { height: 100%; }p { margin-top: 0.5em; margin-bottom: 0.5em; }p:first-child, ul, ol { margin-top: 0px; }aside { float: right; max-width: 40%; margin: 1ex; border: 1px solid black; padding: 1ex; }del { text-decoration: line-through; color: rgb(139, 0, 64); }ins { text-decoration: underline; color: rgb(0, 81, 0); }pre { margin-left: 1em; }cxx-clause { page-break-before: always; }@media not paged {
  cxx-clause, cxx-toc { margin-top: 3em; }
}</style></head>
<body>
<cxx-titlepage stage="draft">
    
    <table>
      
        <tr><th>Document Number:</th><td><cxx-docnum>N????</cxx-docnum></td></tr>
      
      
        <tr><th>Date:</th><td><time pubdate="">2013-11-02</time></td></tr>
      
      
      
        <tr><th>Editor:</th><td><cxx-editor>
    Jeffrey Yasskin<br>
    Google, Inc.<br>
    <cxx-email><a href="mailto:jyasskin@google.com">jyasskin@google.com</a></cxx-email>
  </cxx-editor></td></tr>
      
    </table>
    <h1>Working Draft, Technical Specification on C++ Extensions for Library Fundamentals</h1>
    
      <p class="warning"><strong>Note: this is an early draft. It’s known to be
      incomplet and incorrekt, and it has lots of b<span style="margin-left: -1.2pt; margin-right: 1pt">a</span>d<span style="width:1.5em"> </span>for<span style="margin-left:-3pt; margin-right:0.6pt">mat</span>ti<span style="position:relative; top:-0.15ex">n</span>g.</strong></p>
    
  </cxx-titlepage>

<cxx-toc>
    
    <nav>
      <h1>Contents</h1>
      
        
          <ol>
            
              <li><a href="#general"><span class="marker">1</span>General</a>
        
          <ol>
            
              <li><a href="#general.scope"><span class="marker">1.1</span>Scope</a>
        
      </li>
            
              <li><a href="#general.references"><span class="marker">1.2</span>Normative references</a>
        
      </li>
            
              <li><a href="#general.namespaces"><span class="marker">1.3</span>Namespaces and headers</a>
        
      </li>
            
              <li><a href="#general.defns"><span class="marker">1.4</span>Terms and definitions</a>
        
      </li>
            
              <li><a href="#general.plans"><span class="marker">1.5</span>Future plans (Informative)</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><a href="#optional"><span class="marker">2</span>Optional objects</a>
        
          <ol>
            
              <li><a href="#optional.general"><span class="marker">2.1</span>In general</a>
        
      </li>
            
              <li><a href="#optional.synop"><span class="marker">2.2</span>Header &lt;optional&gt; synopsis</a>
        
      </li>
            
              <li><a href="#optional.defs"><span class="marker">2.3</span>Definitions</a>
        
      </li>
            
              <li><a href="#optional.object"><span class="marker">2.4</span>optional for object types</a>
        
          <ol>
            
              <li><a href="#optional.object.ctor"><span class="marker">2.4.1</span>Constructors</a>
        
      </li>
            
              <li><a href="#optional.object.dtor"><span class="marker">2.4.2</span>Destructor</a>
        
      </li>
            
              <li><a href="#optional.object.assign"><span class="marker">2.4.3</span>Assignment</a>
        
      </li>
            
              <li><a href="#optional.object.swap"><span class="marker">2.4.4</span>Swap</a>
        
      </li>
            
              <li><a href="#optional.object.observe"><span class="marker">2.4.5</span>Observers</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><a href="#optional.inplace"><span class="marker">2.5</span>In-place construction</a>
        
      </li>
            
              <li><a href="#optional.nullopt"><span class="marker">2.6</span>Disengaged state indicator</a>
        
      </li>
            
              <li><a href="#optional.bad_optional_access"><span class="marker">2.7</span>Class bad_optional_access</a>
        
      </li>
            
              <li><a href="#optional.relops"><span class="marker">2.8</span>Relational operators</a>
        
      </li>
            
              <li><a href="#optional.nullops"><span class="marker">2.9</span>Comparison with nullopt</a>
        
      </li>
            
              <li><a href="#optional.comp_with_t"><span class="marker">2.10</span>Comparison with T</a>
        
      </li>
            
              <li><a href="#optional.specalg"><span class="marker">2.11</span>Specialized algorithms</a>
        
      </li>
            
              <li><a href="#optional.hash"><span class="marker">2.12</span>Hash support</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      
    </nav>
  </cxx-toc>

<cxx-clause id="general" title="General">
    

    <section>
      <h1>1 General <span style="float:right"><a href="#general">[general]</a></span></h1>
      
  <cxx-section id="general.scope" title="Scope">
    

    <section>
      <h1>1.1 Scope <span style="float:right"><a href="#general.scope">[general.scope]</a></span></h1>
      
    <p>This technical specification describes extensions to the C++
    Standard Library <cxx-ref to="general.references">(<a href="#general.references">1.2</a>)</cxx-ref>. These extensions are classes
    and functions that are likely to be used widely within a program
    and/or on the interface boundaries between libraries written by
    different organizations.</p>

    <p>This technical specification is non-normative. Some of the
    library components in this technical specification may be
    considered for standardization in a future version of C++, but
    they are not currently part of any C++ standard. Some of the
    components in this technical specification may never be
    standardized, and others may be standardized in a substantially
    changed form.</p>

    <p>The goal of this technical specification it to build more
    widespread existing practice for an expanded C++ standard
    library. It gives advice on extensions to those vendors who wish
    to provide them.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.references" title="Normative references">
    

    <section>
      <h1>1.2 Normative references <span style="float:right"><a href="#general.references">[general.references]</a></span></h1>
      
    <p>The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>

    <ul>
      <li>ISO/IEC 14882:2011, Programming Languages — C++</li>
    </ul>

    <p>ISO/IEC 14882:2011 is herein called the C++ Standard. The library
    described in ISO/IEC 14882:2011 clauses 17–30 is herein called the C++
    Standard Library.</p>

    <p>Unless otherwise specified, the whole of the C++ Standard's
    Library introduction [lib.library] is included into this Technical
    Specification by reference.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.namespaces" title="Namespaces and headers">
    

    <section>
      <h1>1.3 Namespaces and headers <span style="float:right"><a href="#general.namespaces">[general.namespaces]</a></span></h1>
      
    <cxx-ednote>
    
    <aside><strong>Editor's note:</strong> This section reflects the <a href="http://wiki.edg.com/twiki/bin/view/Wg21chicago2013/FundamentalsTS#What_can_go_into_a_TS">consensus
    between the LWG and LEWG at the Chicago 2013
    meeting</a>.</aside>
  </cxx-ednote>

    <p>Since the extensions described in this technical specification
    are experimental and not part of the C++ standard library, they
    should not be declared directly within namespace
    <code>std</code>. Unless otherwise specifed, all components
    described in this technical specification are declared in
    namespace <code>std::experimental::fundamentals_v1</code> or a
    subnamespace thereof.  Each header described in this technical
    specification shall import the contents of
    <code>std::experimental::fundamentals_v1</code> into
    <code>std::experimental</code> as if by</p>

    <pre><code>namespace std {
  namespace experimental {
    inline namespace fundamentals_v1 {}
  }
}</code></pre>

    <p>Unless otherwise specified, references to other entities
    described in this technical specification are assumed to be
    qualified with <code>std::experimental::fundamentals_v1::</code>,
    and references to entities described in the standard are assumed
    to be qualified with <code>std::</code>.</p>

    <p>Extensions that are expected to eventually be added to an
    existing header <code>&lt;meow&gt;</code> are provided inside the
    <code>&lt;experimental/meow&gt;</code> header, which shall include
    the standard contents of <code>&lt;meow&gt;</code> as if by</p>
    <pre><code>#include &lt;meow&gt;</code></pre>

    <p><cxx-note>[ <em>Note:</em> This implies that this technical specification cannot
    remove an existing overload of a function. — <em>end note</em> ]</cxx-note></p>

    <p>New headers are also provided in the
    <code>&lt;experimental/&gt;</code> directory, but without such an
    <code>#include</code>.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.defns" title="Terms and definitions">
    

    <section>
      <h1>1.4 Terms and definitions <span style="float:right"><a href="#general.defns">[general.defns]</a></span></h1>
      
    <p>For the purposes of this document, the terms and definitions
    given in the C++ Standard and the folowing apply.</p>

    <!--
    <cxx-section id="general.defns.foo" title="Foo">
      <p>Foo's definition.</p>
    </cxx-section>
    -->
  
    </section>
  </cxx-section>

  <cxx-section id="general.plans" title="Future plans (Informative)">
    

    <section>
      <h1>1.5 Future plans (Informative) <span style="float:right"><a href="#general.plans">[general.plans]</a></span></h1>
      
    <p>This section describes tentative plans for future versions of
    this technical specification and plans for moving content into
    future versions of the C++ Standard.</p>

    <p>The C++ committee intends to release a new version of this
    technical specification approximately every year, containing the
    library extensions we hope to add to a near-future version of the
    C++ Standard.  Future versions will define their contents in
    <code>std::experimental::fundamentals_v2</code>,
    <code>std::experimental::fundamentals_v3</code>, etc., with the
    most recent implemented version inlined into
    <code>std::experimental</code>.</p>

    <p>When an extension defined in this or a future version of this
    technical specification represents enough existing practice, it
    will be moved into the next version of the C++ Standard by
    removing the <code>experimental::fundamentals_v<var>N</var></code>
    segment of its namespace and by removing the
    <code>experimental/</code> prefix from its header's path.</p>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="optional" title="Optional objects">
    

    <section>
      <h1>2 Optional objects <span style="float:right"><a href="#optional">[optional]</a></span></h1>
      
  <cxx-section id="optional.general" title="In general">
    

    <section>
      <h1>2.1 In general <span style="float:right"><a href="#optional.general">[optional.general]</a></span></h1>
      
    <p>This subclause describes class template <code>optional</code> that represents <em>optional objects</em>. An <dfn>optional object for object types</dfn> is an object that contains the storage for another object and manages the lifetime of this contained object, if any. The contained object may be initialized after the optional object has been initialized, and may be destroyed before the optional object has been destroyed. The initialization state of the contained object is tracked by the optional object.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.synop">
    

    <section>
      <h1>2.2 <cxx-title>Header <code>&lt;optional&gt;</code> synopsis</cxx-title> <span style="float:right"><a href="#optional.synop">[optional.synop]</a></span></h1>
      
    

<pre>namespace std {
  <cxx-ref insynopsis="" to="optional.object">// <i><a href="#optional.object">2.4</a>, optional for object types</i></cxx-ref>
  template &lt;class T&gt; class optional;

  <cxx-ref insynopsis="" to="optional.inplace">// <i><a href="#optional.inplace">2.5</a>, In-place construction</i></cxx-ref>
  struct in_place_t{};
  constexpr in_place_t in_place{};

  <cxx-ref insynopsis="" to="optional.nullopt">// <i><a href="#optional.nullopt">2.6</a>, Disengaged state indicator</i></cxx-ref>
  struct nullopt_t{<em>see below</em>};
  constexpr nullopt_t nullopt(<em>unspecified</em>);

  <cxx-ref insynopsis="" to="optional.bad_optional_access">// <i><a href="#optional.bad_optional_access">2.7</a>, Class bad_optional_access</i></cxx-ref>
  class bad_optional_access;

  <cxx-ref insynopsis="" to="optional.relops">// <i><a href="#optional.relops">2.8</a>, Relational operators</i></cxx-ref>
  template &lt;class T&gt;
    constexpr bool operator==(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt;
    constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);

  <cxx-ref insynopsis="" to="optional.nullops">// <i><a href="#optional.nullops">2.9</a>, Comparison with nullopt</i></cxx-ref>
  template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
  template &lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
  template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
  template &lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;

  <cxx-ref insynopsis="" to="optional.comp_with_t">// <i><a href="#optional.comp_with_t">2.10</a>, Comparison with T</i></cxx-ref>
  template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, const T&amp;);
  template &lt;class T&gt; constexpr bool operator==(const T&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const T&amp;);
  template &lt;class T&gt; constexpr bool operator&lt;(const T&amp;, const optional&lt;T&gt;&amp;);

  <cxx-ref insynopsis="" to="optional.specalg">// <i><a href="#optional.specalg">2.11</a>, Specialized algorithms</i></cxx-ref>
  template &lt;class T&gt; void swap(optional&lt;T&gt;&amp;, optional&lt;T&gt;&amp;) noexcept(<em>see below</em>);
  template &lt;class T&gt; constexpr optional&lt;<em>see below</em>&gt; make_optional(T&amp;&amp;);

  <cxx-ref insynopsis="" to="optional.hash">// <i><a href="#optional.hash">2.12</a>, Hash support</i></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt; struct hash&lt;optional&lt;T&gt;&gt;;
} // <i>namespace std</i>
</pre>

    <p>A program that necessitates the instantiation of template <code>optional</code> for a reference type, or for possibly cv-qualified types <code>in_place_t</code> or <code>nullopt_t</code> is ill-formed.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.defs" title="Definitions">
    

    <section>
      <h1>2.3 Definitions <span style="float:right"><a href="#optional.defs">[optional.defs]</a></span></h1>
      
    <p>An instance of <code>optional&lt;T&gt;</code> is said to be <dfn>disengaged</dfn> if it has been default constructed, constructed with or assigned with a value of type <code>nullopt_t</code>, constructed with or assigned with a disengaged optional object of type <code>optional&lt;T&gt;</code>.
    </p>

    <p>An instance of <code>optional&lt;T&gt;</code> is said to be <dfn>engaged</dfn> if it is not disengaged.
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.object">
    

    <section>
      <h1>2.4 <cxx-title><code>optional</code> for object types</cxx-title> <span style="float:right"><a href="#optional.object">[optional.object]</a></span></h1>
      
    

<pre>namespace std {

  template &lt;class T&gt;
  class optional
  {
  public:
    typedef T value_type;

    <cxx-ref insynopsis="" to="optional.object.ctor">// <i><a href="#optional.object.ctor">2.4.1</a>, Constructors</i></cxx-ref>
    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    optional(const optional&amp;);
    optional(optional&amp;&amp;) noexcept(<em>see below</em>);
    constexpr optional(const T&amp;);
    constexpr optional(T&amp;&amp;);
    template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;...);
    template &lt;class U, class... Args&gt;
      constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args&amp;&amp;...);

    <cxx-ref insynopsis="" to="optional.object.dtor">// <i><a href="#optional.object.dtor">2.4.2</a>, Destructor</i></cxx-ref>
    ~optional();

    <cxx-ref insynopsis="" to="optional.object.assign">// <i><a href="#optional.object.assign">2.4.3</a>, Assignment</i></cxx-ref>
    optional&amp; operator=(nullopt_t) noexcept;
    optional&amp; operator=(const optional&amp;);
    optional&amp; operator=(optional&amp;&amp;) noexcept(<em>see below</em>);
    template &lt;class U&gt; optional&amp; operator=(U&amp;&amp;);
    template &lt;class... Args&gt; void emplace(Args&amp;&amp;...);
    template &lt;class U, class... Args&gt;
      void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);

    <cxx-ref insynopsis="" to="optional.object.swap">// <i><a href="#optional.object.swap">2.4.4</a>, Swap</i></cxx-ref>
    void swap(optional&amp;) noexcept(<em>see below</em>);

    <cxx-ref insynopsis="" to="optional.object.observe">// <i><a href="#optional.object.observe">2.4.5</a>, Observers</i></cxx-ref>
    constexpr T const* operator -&gt;() const;
    T* operator -&gt;();
    constexpr T const&amp; operator *() const;
    T&amp; operator *();
    constexpr explicit operator bool() const noexcept;
    constexpr T const&amp; value() const;
    T&amp; value();
    template &lt;class U&gt; constexpr T value_or(U&amp;&amp;) const&amp;;
    template &lt;class U&gt; T value_or(U&amp;&amp;) &amp;&amp;;

  private:
    bool init; // <i>exposition only</i>
    T*   val;  // <i>exposition only</i>
  };

} // <i>namespace std</i></pre>

    <p>Engaged instances of <code>optional&lt;T&gt;</code> where <code>T</code> is of object type shall contain a value of type <code>T</code> within its own storage. This value is referred to as the <dfn>contained value</dfn> of the optional object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value.  The contained value shall be allocated in a region of the <code>optional&lt;T&gt;</code> storage suitably aligned for the type <code>T</code>.</p>

    <p>Members <code><var>init</var></code> and <code><var>val</var></code> are provided for exposition only. Implementations need not provide those members. <code><var>init</var></code> indicates whether the <code>optional</code> object's contained value has been initialized (and not yet destroyed); <code><var>val</var></code> points to (a possibly uninitialized) contained value.
    </p>

    <p><code>T</code> shall be an object type and shall satisfy the requirements of <code>Destructible</code> (Table 24).</p>

    <cxx-section id="optional.object.ctor" title="Constructors">
    

    <section>
      <h1>2.4.1 Constructors <span style="float:right"><a href="#optional.object.ctor">[optional.object.ctor]</a></span></h1>
      
      <cxx-function>
    
    <pre><code><cxx-signature>constexpr optional&lt;T&gt;::optional() noexcept;</cxx-signature><cxx-signature>constexpr optional&lt;T&gt;::optional(nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>*this</code> is disengaged.</dd>
  </cxx-postconditions><cxx-remarks>
    
    <dt>Remarks:</dt><dd>No <code>T</code> object referenced is initialized. For every object type <code>T</code> these constructors shall be <code>constexpr</code> constructors (7.1.5).</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>optional&lt;T&gt;::optional(const optional&lt;T&gt;&amp; <var>rhs</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>If <code><var>rhs</var></code> is engaged initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>*<var>rhs</var></code>.</dd>
  </cxx-effects><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>optional&lt;T&gt;::optional(optional&lt;T&gt;&amp;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>If <code><var>rhs</var></code> is engaged initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(*<var>rhs</var>)</code>. <code>bool(<var>rhs</var>)</code> is unchanged.</dd>
  </cxx-effects><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>The expression inside <code>noexcept</code> is equivalent to:<pre>is_nothrow_move_constructible&lt;T&gt;::value</pre></dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>optional&lt;T&gt;::optional(const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code><var>v</var></code>.</dd>
  </cxx-effects><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>optional&lt;T&gt;::optional(T&amp;&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(<var>v</var>)</code>.</dd>
  </cxx-effects><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_constructible&lt;T, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>Initializes the contained value as if constructing an object of type <code>T</code> with the arguments <code>std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s constructor selected for the initialization is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class U, class... Args&gt; <wbr>explicit optional(in_place_t, initializer_list&lt;U&gt; <var>il</var>, Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>Initializes the contained value as if constructing an object of type <code>T</code> with the arguments <code><var>il</var>, std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>The function shall not participate in overload resolution unless <code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-remarks><cxx-remarks>
    
    <dt>Remarks:</dt><dd>If <code>T</code>'s constructor selected for the initialization is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</dd>
  </cxx-remarks></dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.dtor" title="Destructor">
    

    <section>
      <h1>2.4.2 Destructor <span style="float:right"><a href="#optional.object.dtor">[optional.object.dtor]</a></span></h1>
      
      <cxx-function>
    
    <pre><code><cxx-signature>optional&lt;T&gt;::~optional();</cxx-signature></code></pre>

    <dl>
      <cxx-effects>
    
    <dt>Effects:</dt><dd>If <code>is_trivially_destructible&lt;T&gt;::value != true</code> and <code>*this</code> is engaged, calls <code><var>val</var>-&gt;T::~T()</code>.</dd>
  </cxx-effects><cxx-remarks>
    
    <dt>Remarks:</dt><dd>If <code>is_trivially_destructible&lt;T&gt;::value == true</code> then this destructor shall be a trivial destructor.</dd>
  </cxx-remarks></dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.assign" title="Assignment">
    

    <section>
      <h1>2.4.3 Assignment <span style="float:right"><a href="#optional.object.assign">[optional.object.assign]</a></span></h1>
      
      <cxx-function>
    
    <pre><code><cxx-signature>optional&lt;T&gt;&amp; optional&lt;T&gt;::operator=(nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-effects>
    
    <dt>Effects:</dt><dd>If <code>*this</code> is engaged calls <code><var>val</var>-&gt;T::~T()</code> to destroy the contained value; otherwise no effect.</dd>
  </cxx-effects><cxx-returns>
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>*this</code> is disengaged.</dd>
  </cxx-postconditions></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>optional&lt;T&gt;&amp; optional&lt;T&gt;::operator=(const optional&lt;T&gt;&amp; <var>rhs</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_copy_assignable&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>
          <ul>
            <li>If <code>*this</code> is disengaged and <code><var>rhs</var></code> is disengaged, no effect, otherwise</li>
            <li>if <code>*this</code> is engaged and <code><var>rhs</var></code> is disengaged, destroys the contained value by calling <code><var>val</var>-&gt;T::~T()</code>, otherwise</li>
            <li>if <code>*this</code> is disengaged and <code><var>rhs</var></code> is engaged, initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with <code>*<var>rhs</var></code>, otherwise</li>
            <li>(if both <code>*this</code> and <code><var>rhs</var></code> are engaged) assigns <code>*<var>rhs</var></code> to the contained value.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-returns>
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>optional&lt;T&gt;&amp; optional&lt;T&gt;::operator=(optional&lt;T&gt;&amp;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_move_assignable&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>
          <ul>
            <li>If <code>*this</code> is disengaged and <code><var>rhs</var></code> is disengaged, no effect, otherwise</li>
            <li>if <code>*this</code> is engaged and <code><var>rhs</var></code> is disengaged, destroys the contained value by calling <code><var>val</var>-&gt;T::~T()</code>, otherwise</li>
            <li>if <code>*this</code> is disengaged and <code><var>rhs</var></code> is engaged, initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with <code>std::move(*<var>rhs</var>)</code>, otherwise</li>
            <li>(if both <code>*this</code> and <code><var>rhs</var></code> are engaged) assigns <code>std::move(*<var>rhs</var>)</code> to the contained value.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-returns>
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>bool(<var>rhs</var>) == bool(*this)</code>.</dd>
  </cxx-postconditions><cxx-remarks>
    
    <dt>Remarks:</dt><dd>The expression inside <code>noexcept</code> is equivalent to: <pre>is_nothrow_move_assignable&lt;T&gt;::value &amp;&amp; is_nothrow_move_constructible&lt;T&gt;::value</pre></dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class U&gt; optional&lt;T&gt;&amp; optional&lt;T&gt;::operator=(U&amp;&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_constructible&lt;T, U&gt;::value</code> is <code>true</code> and <code>is_assignable&lt;U, T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>If <code>*this</code> is engaged assigns <code>std::forward&lt;U&gt;(<var>v</var>)</code> to the contained value; otherwise initializes the contained value as if direct-non-list-initializing object of type <code>T</code> with <code>std::forward&lt;U&gt;(<var>v</var>)</code>.</dd>
  </cxx-effects><cxx-returns>
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-remarks>
    
    <dt>Remarks:</dt><dd>The function shall not participate in overload resolution unless  <code>is_same&lt;typename remove_reference&lt;U&gt;::type, T&gt;::value</code> is  <code>true</code>.</dd>
  </cxx-remarks><cxx-notes>
    
    <dt>Notes:</dt><dd>The reason for providing such generic assignment and then constraining it so that effectively <code>T</code> == <code>U</code> is to guarantee that assignment of the form <code>o = {}</code> is unambiguous.</dd>
  </cxx-notes></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class... Args&gt; void optional&lt;T&gt;::emplace(Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_constructible&lt;T, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>Calls <code>*this = nullopt</code>. Then initializes the contained value as if constructing an object of type <code>T</code> with the arguments <code>std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class U, class... Args&gt; <wbr>void optional&lt;T&gt;::emplace(initializer_list&lt;U&gt; <var>il</var>, Args&amp;&amp;... <var>args</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>Calls <code>*this = nullopt</code>. Then initializes the contained value as if constructing an object of type <code>T</code> with the arguments <code><var>il</var>, std::forward&lt;Args&gt;(<var>args</var>)...</code>.</dd>
  </cxx-effects><cxx-postconditions>
    
    <dt>Postconditions:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-postconditions><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>The function shall not participate in overload resolution unless <code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</dd>
  </cxx-remarks></dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.swap" title="Swap">
    

    <section>
      <h1>2.4.4 Swap <span style="float:right"><a href="#optional.object.swap">[optional.object.swap]</a></span></h1>
      
      <cxx-function>
    
    <pre><code><cxx-signature>void optional&lt;T&gt;::swap(optional&lt;T&gt;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd>LValues of type T shall be swappable and <code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-effects>
    
    <dt>Effects:</dt><dd>
          <ul>
            <li>If <code>*this</code> is disengaged and <code><var>rhs</var></code> is disengaged, no effect, otherwise</li>
            <li>if <code>*this</code> is engaged and <code><var>rhs</var></code> is disengaged, initializes the contained value of <code><var>rhs</var></code> by direct-initialization with <code>std::move(*(*this))</code>, followed by <code>val-&gt;T::~T(), swap(<var>init</var>, <var>rhs.init</var>)</code>, otherwise</li>
            <li>if <code>*this</code> is disengaged and <code><var>rhs</var></code> is engaged, initializes the contained value of <code>*this</code> by direct-initialization with <code>std::move(*<var>rhs</var>)</code>, followed by <code>rhs.val-&gt;T::~T(), swap(<var>init</var>, <var>rhs.init</var>)</code>, otherwise</li>
            <li>(if both <code>*this</code> and <code><var>rhs</var></code> are engaged) calls <code>swap(*(*this), *<var>rhs</var>)</code>.</li>
          </ul>
        </dd>
  </cxx-effects><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exceptions that the expressions in the Effects clause throw.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>The expression inside <code>noexcept</code> is equivalent to: <pre>is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; <wbr>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</pre></dd>
  </cxx-remarks></dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="optional.object.observe" title="Observers">
    

    <section>
      <h1>2.4.5 Observers <span style="float:right"><a href="#optional.object.observe">[optional.object.observe]</a></span></h1>
      
      <cxx-function>
    
    <pre><code><cxx-signature>constexpr T const* optional&lt;T&gt;::operator-&gt;() const;</cxx-signature><cxx-signature>T* optional&lt;T&gt;::operator-&gt;();</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-requires><cxx-returns>
    
    <dt>Returns:</dt><dd><code><var>val</var></code>.</dd>
  </cxx-returns><cxx-throws>
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>Unless <code>T</code> is a user-defined type with overloaded unary <code>operator&amp;</code>, the first function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>constexpr T const&amp; optional&lt;T&gt;::operator*() const;</cxx-signature><cxx-signature>T&amp; optional&lt;T&gt;::operator*();</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>*this</code> is engaged.</dd>
  </cxx-requires><cxx-returns>
    
    <dt>Returns:</dt><dd><code>*<var>val</var></code>.</dd>
  </cxx-returns><cxx-throws>
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>The first function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>constexpr explicit optional&lt;T&gt;::operator bool() noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns>
    
    <dt>Returns:</dt><dd><code><var>init</var></code>.</dd>
  </cxx-returns><cxx-remarks>
    
    <dt>Remarks:</dt><dd>this function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>constexpr T const&amp; optional&lt;T&gt;::value() const;</cxx-signature><cxx-signature>T&amp; optional&lt;T&gt;::value();</cxx-signature></code></pre>

    <dl>
      <cxx-returns>
    
    <dt>Returns:</dt><dd><code><var>*val</var></code>, if <code>bool(*this)</code>.</dd>
  </cxx-returns><cxx-throws>
    
    <dt>Throws:</dt><dd><code>bad_optional_access</code> if <code>!*this</code>.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>The first function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class U&gt; constexpr T optional&lt;T&gt;::value_or(U&amp;&amp; <var>v</var>) const&amp;;</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_convertible&lt;U&amp;&amp;, T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-returns>
    
    <dt>Returns:</dt><dd><code>bool(*this) ? **this : static_cast&lt;T&gt;(std::forward&lt;U&gt;(<var>v</var>))</code>.</dd>
  </cxx-returns><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws><cxx-remarks>
    
    <dt>Remarks:</dt><dd>If the selected constructor of <code>T</code> is a <code>constexpr</code> constructor, this function shall be a <code>constexpr</code> function.</dd>
  </cxx-remarks></dl>
  </cxx-function>

      <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class U&gt; T optional&lt;T&gt;::value_or(U&amp;&amp; <var>v</var>) &amp;&amp;;</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_convertible&lt;U&amp;&amp;, T&gt;::value</code> is <code>true</code>.</dd>
  </cxx-requires><cxx-returns>
    
    <dt>Returns:</dt><dd><code>bool(*this) ? std::move(**this) : static_cast&lt;T&gt;(std::forward&lt;U&gt;(<var>v</var>))</code>.</dd>
  </cxx-returns><cxx-throws>
    
    <dt>Throws:</dt><dd>Any exception thrown by the selected constructor of <code>T</code>.</dd>
  </cxx-throws></dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.inplace" title="In-place construction">
    

    <section>
      <h1>2.5 In-place construction <span style="float:right"><a href="#optional.inplace">[optional.inplace]</a></span></h1>
      
    <cxx-function>
    
    <pre><code><cxx-signature>struct in_place_t{};</cxx-signature><cxx-signature>constexpr in_place_t in_place{};</cxx-signature></code></pre>

    <dl>
      
    </dl>
  </cxx-function>

    <p>The struct <code>in_place_t</code> is an empty structure type used as a unique type to disambiguate constructor and function overloading. Specifically, <code>optional&lt;T&gt;</code> has a constructor with <code>in_place_t</code> as the first argument followed by an argument pack; this indicates that <code>T</code> should be constructed in-place (as if by a call to placement new expression) with the forwarded argument pack as parameters.
    </p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.nullopt" title="Disengaged state indicator">
    

    <section>
      <h1>2.6 Disengaged state indicator <span style="float:right"><a href="#optional.nullopt">[optional.nullopt]</a></span></h1>
      
    <cxx-function>
    
    <pre><code><cxx-signature>struct nullopt_t{<em>see below</em>};</cxx-signature><cxx-signature>constexpr nullopt_t nullopt(<em>unspecified</em>);</cxx-signature></code></pre>

    <dl>
      
    </dl>
  </cxx-function>

    <p>The struct <code>nullopt_t</code> is an empty structure type used as a unique type to indicate a disengaged state for <code>optional</code> objects. In particular, <code>optional&lt;T&gt;</code> has a constructor with <code>nullopt_t</code> as single argument; this indicates that a disengaged optional object shall be constructed.
    </p>

    <p>Type <code>nullopt_t</code> shall not have a default constructor. It shall be a literal type. Constant <code>nullopt</code> shall be initialized with an argument of literal type.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.bad_optional_access">
    

    <section>
      <h1>2.7 <cxx-title>Class <code>bad_optional_access</code></cxx-title> <span style="float:right"><a href="#optional.bad_optional_access">[optional.bad_optional_access]</a></span></h1>
      
    

<pre>namespace std {
  class bad_optional_access : public logic_error {
  public:
    explicit bad_optional_access(const string&amp; <var>what_arg</var>);
    explicit bad_optional_access(const char* <var>what_arg</var>);
  };
}</pre>

    <p>The class <code>bad_optional_access</code> defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of a disengaged optional object.</p>

    <cxx-function>
    
    <pre><code><cxx-signature>bad_optional_access(const string&amp; <var>what_arg</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-effects>
    
    <dt>Effects:</dt><dd>Constructs an object of class <code>bad_optional_access</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>

    <cxx-function>
    
    <pre><code><cxx-signature>bad_optional_access(const char* <var>what_arg</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-effects>
    
    <dt>Effects:</dt><dd>Constructs an object of class <code>bad_optional_access</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.relops" title="Relational operators">
    

    <section>
      <h1>2.8 Relational operators <span style="float:right"><a href="#optional.relops">[optional.relops]</a></span></h1>
      
    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, const optional&lt;T&gt;&amp; <var>y</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd><code>T</code> shall meet the requirements of <code>EqualityComparable</code>.</dd>
  </cxx-requires><cxx-returns>
    
    <dt>Returns:</dt><dd>If <code>bool(<var>x</var>) != bool(<var>y</var>)</code>, <code>false</code>; otherwise if <code>bool(<var>x</var>) == false</code>, <code>true</code>; otherwise <code>*<var>x</var> == *<var>y</var></code>.</dd>
  </cxx-returns><cxx-remarks>
    
    <dt>Remarks:</dt><dd>Instantiations of this function template for which <code>*<var>x</var> == *<var>y</var></code> is a core constant expression, shall be <code>constexpr</code> functions.</dd>
  </cxx-remarks></dl>
  </cxx-function>

    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, const optional&lt;T&gt;&amp; <var>y</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd>Expression <code>less&lt;T&gt;{}(*<var>x</var>, *<var>y</var>)</code> shall be well-formed.</dd>
  </cxx-requires><cxx-returns>
    
    <dt>Returns:</dt><dd>If <code>(!<var>y</var>)</code>, <code>false</code>; otherwise, if <code>(!<var>x</var>)</code>, <code>true</code>; otherwise <code>less&lt;T&gt;{}(*<var>x</var>, *<var>y</var>)</code>.</dd>
  </cxx-returns><cxx-remarks>
    
    <dt>Remarks:</dt><dd>Instantiations of this function template for which <code>less&lt;T&gt;{}(*<var>x</var>, *<var>y</var>)</code> is a core constant expression, shall be <code>constexpr</code> functions.</dd>
  </cxx-remarks></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.nullops">
    

    <section>
      <h1>2.9 <cxx-title>Comparison with <code>nullopt</code></cxx-title> <span style="float:right"><a href="#optional.nullops">[optional.nullops]</a></span></h1>
      
    

    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature><cxx-signature>template &lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns>
    
    <dt>Returns:</dt><dd><code>(!<var>x</var>)</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns>
    
    <dt>Returns:</dt><dd><code>false</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature></code></pre>

    <dl>
      <cxx-returns>
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>)</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.comp_with_t">
    

    <section>
      <h1>2.10 <cxx-title>Comparison with <code>T</code></cxx-title> <span style="float:right"><a href="#optional.comp_with_t">[optional.comp_with_t]</a></span></h1>
      
    

    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-returns>
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? *<var>x</var> == <var>v</var> : false</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator==(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature></code></pre>

    <dl>
      <cxx-returns>
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? <var>v</var> == *<var>x</var> : false</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>

    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-returns>
    
    <dt>Returns:</dt><dd><code>bool(<var>x</var>) ? less&lt;T&gt;{}(*<var>x</var>, <var>v</var>) : true</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.specalg" title="Specialized algorithms">
    

    <section>
      <h1>2.11 Specialized algorithms <span style="float:right"><a href="#optional.specalg">[optional.specalg]</a></span></h1>
      
    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; <var>x</var>, optional&lt;T&gt;&amp; <var>y</var>) noexcept(noexcept(<var>x</var>.swap(<var>y</var>)));</cxx-signature></code></pre>

    <dl>
      <cxx-effects>
    
    <dt>Effects:</dt><dd>calls <code><var>x</var>.swap(<var>y</var>)</code>.</dd>
  </cxx-effects></dl>
  </cxx-function>

    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; constexpr optional&lt;typename decay&lt;T&gt;::type&gt; make_optional(T&amp;&amp; <var>v</var>);</cxx-signature></code></pre>

    <dl>
      <cxx-returns>
    
    <dt>Returns:</dt><dd><code>optional&lt;typename decay&lt;T&gt;::type&gt;(std::forward&lt;T&gt;(<var>v</var>))</code>.</dd>
  </cxx-returns></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

  <cxx-section id="optional.hash" title="Hash support">
    

    <section>
      <h1>2.12 Hash support <span style="float:right"><a href="#optional.hash">[optional.hash]</a></span></h1>
      
    <cxx-function>
    
    <pre><code><cxx-signature>template &lt;class T&gt; struct hash&lt;optional&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      <cxx-requires>
    
    <dt>Requires:</dt><dd>the template specialization <code>hash&lt;T&gt;</code> shall meet the requirements of class template <code>hash</code> (20.9.12).
      The template specialization <code>hash&lt;optional&lt;T&gt;&gt;</code> shall meet the requirements of class template <code>hash</code>.
      For an object <code><var>o</var></code> of type <code>optional&lt;T&gt;</code>, if <code>bool(<var>o</var>) == true</code>,
      <code>hash&lt;optional&lt;T&gt;&gt;()(<var>o</var>)</code> shall evaluate to the same value as <code>hash&lt;T&gt;()(*<var>o</var>)</code>.</dd>
  </cxx-requires></dl>
  </cxx-function>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>



</body></html>